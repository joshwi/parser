[
    {
        "hw_type": "asa",
        "command": "show arp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<ip>\\d+.\\d+.\\d+.\\d+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "asa",
        "command": "show asp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Frame drop:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^.*\\((?P<drop>\\S+)\\)\\s+(?P<counts>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last\\s+clearing:\\s+(?P<last_clearing>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flow drop:$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "asa",
        "command": "show interface",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Interface +(?P<interface>\\S+) +\"(?P<name>\\S*)\", +is +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC address +(?P<mac_address>[\\w\\.]+), +MTU +(?P<mtu>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +address +(?P<ip>[a-z0-9\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface_state>Available) +but +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+) *(?P<ip>unassigned|\\d+.\\d+.\\d+.\\d+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +(?P<interface>\\S+) +\"(?P<name>\\S*)\", +is +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC address +(?P<mac_address>[\\w\\.]+), +MTU +(?P<mtu>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +address +(?P<ip>[a-z0-9\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface_state>Available) +but +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<packets_input>\\d+) +packets +input, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<packets_output>\\d+) +packets +output, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<packets_dropped>\\d+) +packets +dropped$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +number +is +(?P<interface_number>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +config +status +is ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +state +is +(?P<interface_state>[\\w\\ ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +vlan +config +status +is ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +vlan +state +is +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "asa",
        "command": "show inventory",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^PID: +(?P<pid>.+)( )?,+ VID: (?P<vid>.+)( )?, ",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "asa",
        "command": "show ip",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<begin>\\S+) +(?P<end>\\S+) +(?P<mask>\\S+) +(?P<free>\\d+) +(?P<held>\\d+) +(?P<in_use>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Available +Addresses:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^In +Use +Addresses:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_address>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "asa",
        "command": "show route",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<protocol>\\S+)\\s(?P<code>[A-Z].+?)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\[(?P<route_preference>[\\d\\/]+)\\]\\svia\\s+(?P<next_hop>\\S+),\\s(?P<date>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<code>\\S+)\\s(?P<network>\\S+)\\s(?P<subnet>\\S+)\\s(?:.*),\\s(?P<context_name>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<code>\\S+)\\s(?P<network>\\S+)\\s(?P<subnet>\\S+)\\s\\[(?P<route_preference>[\\d\\/]+)\\]",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)via\\s+(?P<next_hop>\\S+),\\s+(?P<context_name>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<code>\\S+)\\s(?P<network>\\S+)\\s(?P<subnet>\\S+)\\s\\[(?P<route_preference>[\\d\\/]+)\\]",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?:\\S+)\\s(?P<code>\\S+)\\s(?P<network>\\S+)\\s(?P<subnet>\\S+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "asa",
        "command": "show service_policy",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)Service-policy: +(?P<service_policy>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Class-map: (?P<class_map>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Inspect: +(((?P<inspect_3>\\S+ +\\S+) +(?P<map_3>\\S+))|((?P<inspect_2>\\S+) +(?P<map_2>\\S+))|(?P<inspect_1>\\S+)) *, +packet +(?P<packet>\\d+), +lock +fail +(?P<lock_fail>\\d+), +drop +(?P<drop>\\d+), +reset-drop +(?P<reset_drop>\\d+), +5-min-pkt-rate +(?P<five_minute_pkt_rate>\\d+) +pkts\\/sec, +v6-fail-close +(?P<v6_fail_close>\\d+) +sctp-drop-override +(?P<sctp_drop_override>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^tcp-proxy: +bytes +in +buffer +(?P<bytes_in_buffer>\\d+), +bytes +dropped +(?P<bytes_dropped>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Inspect: +(((?P<inspect_3>\\S+ +\\S+) +(?P<map_3>\\S+))|((?P<inspect_2>\\S+) +(?P<map_2>\\S+))|(?P<inspect_1>\\S+)) *, +packet +(?P<packet>\\d+), +lock +fail +(?P<lock_fail>\\d+), +drop +(?P<drop>\\d+), +reset-drop +(?P<reset_drop>\\d+), +5-min-pkt-rate +(?P<five_minute_pkt_rate>\\d+) +pkts\\/sec, +v6-fail-close +(?P<v6_fail_close>\\d+) +sctp-drop-override +(?P<sctp_drop_override>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "asa",
        "command": "show traffic",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<name>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<queue>\\S+).+?(?P<duration>\\d+\\.\\d+)\\s+\\S+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<packets>\\d+)\\s+packets\\s+(?P<bytes>\\d+)\\s+\\S*",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<packets_sec>\\d+)\\s+pkts\\/sec\\s+(?P<bytes_sec>\\d+)\\s+bytes\\/sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^1 minute input rate\\s+(?P<packets_input_1_minute>\\d+)\\s+pkts\\/sec,\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^1 minute output rate\\s+(?P<packets_output_1_minute>\\d+)\\s+pkts\\/sec,\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^1 minute drop rate,\\s+(?P<packets_drop_rate_1_minute>\\d+)\\s+pkts\\/sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^5 minute input rate\\s+(?P<packets_input_5_minute>\\d+)\\s+pkts\\/sec,\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^5 minute output rate\\s+(?P<packets_output_5_minute>\\d+)\\s+pkts\\/sec,\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^5 minute drop rate,\\s+(?P<packets_drop_rate_5_minute>\\d+)\\s+pkts\\/sec$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "asa",
        "command": "show vpn",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<status>\\S+) +(?P<role>\\S+) +(?P<failover>\\S+) +(?P<encryption>\\S+) +(?P<peers>\\d+) +(?P<cluster_ip>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<role>\\S+) +(?P<pri>\\d+) +(?P<model>\\S+) +(?P<version>\\d+) +(?P<public_ip>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<limit_1>\\d+) +(?P<used_1>\\d+) +(?P<load_1>\\d+)\\% +(?P<limit_2>\\d+) +(?P<used_2>\\d+) +(?P<load_2>\\d+)% +(?P<public_ip>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "asa",
        "command": "show vpn_sessiondb",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<name>(Load Balancing\\(Encryption\\))|(Site-to-Site VPN)|(IKEv1 +IPsec\\/L2TP +IPsec)|(AnyConnect Client)|(Clientless VPN)) +: +(?P<active>\\d+) *: +(?P<cumulative>\\d+) *: +(?P<peak_concurrent>\\d+)( *: +(?P<inactive>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Device +Total +VPN +Capacity +: +(?P<device_total_vpn_capacity>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Device +Load +: +(?P<device_load>\\d+)\\%$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>(SSL/TLS/DTLS)|(Browser)|(IKEv2 IPsec)) +: +(?P<active>\\d+) *: +(?P<cumulative>\\d+) *: +(?P<peak_concurrent>\\d+)( *: +(?P<inactive>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +Active +and +Inactive +: +(?P<total_active_and_inactive>\\d+) +Total +Cumulative +: +(?P<total_cumulative>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Device\\s+Total\\s+VPN\\s+Capacity\\s+:\\s+(?P<device_total_vpn_capacity>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>(Totals|DTLS-Tunnel|SSL-Tunnel|AnyConnect-Parent|Clientless)) +: +(?P<active>\\d+) *: +(?P<cumulative>\\d+)( *: +(?P<peak_concurrent>\\d+))?( *: (?P<inactive>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Session\\s+Type:\\s+(?P<session_type>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Username\\s+:\\s+(?P<username>\\S+)(\\s+Index\\s+:\\s+(?P<index>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Index\\s+:\\s+(?P<index>\\d+)(\\s+IP\\s+Addr\\s+:\\s+(?P<ip_addr>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Protocol\\s+:\\s(?P<protocol>[-\\w\\s]+)(\\s+VPN\\s+Client\\s+Encryption\\s+:\\s+(?P<vpn_client_encryption>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hashing\\s+:\\s+(?P<hashing>\\S+)\\s+Auth\\s+Mode\\s+:\\s+(?P<auth_mode>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hashing\\s+:\\s+(?P<protocol>\\S+):\\s+(?P<hashing>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TCP\\s+Dst\\s+Port\\s+:\\s+(?P<dst_port>\\d+)\\s+TCP\\s+Src\\s+Port\\s+:\\s+(?P<src_port>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>Bytes|Pkts)\\s+Tx\\s+:\\s+(?P<tx>\\d+)\\s+(?P<type2>Bytes|Pkts)\\s+Rx\\s+:\\s+(?P<rx>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Client\\s+Ver\\s+:\\s+(?P<client_version>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Client\\s+Type\\s+:\\s+(?P<client_type>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group\\s+:\\s+(?P<group>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Login\\s+Time\\s+:\\s+(?P<login_time>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Duration\\s+:\\s+(?P<duration>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Inactivity\\s+:\\s+(?P<inactivity>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Filter\\s+Name\\s+:\\s+(?P<filter_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Assigned\\s+IP\\s+:\\s+(?P<assigned_ip>\\S+)\\s+Public\\s+IP\\s+:\\s+(?P<public_ip>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^License\\s+:\\s+(?P<license>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Encryption\\s+:\\s+(?P<encryption>[\\s\\S]+)\\s+Hashing\\s+:\\s+(?P<hashing>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Encryption\\s+:\\s+(?P<protocol>\\S+):\\s+(?P<encryption>\\S+)(\\s+Hashing\\s+:\\s+(?P<protocol2>\\S+):\\s+(?P<hashing>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Group\\s+Policy\\s+:\\s+(?P<group_policy>\\S+))?(\\s*Tunnel\\s+Group\\s+:\\s+(?P<tunnel_group>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NAC\\s+Result\\s+:\\s+(?P<nac_result>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VLAN\\s+Mapping\\s+:\\s+(?P<vlan_mapping>\\S+)\\s+VLAN\\s+:\\s+(?P<vlan>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Audt\\s+Sess\\s+ID\\s+:\\s+(?P<audt_sess_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Security\\s+Grp\\s+:\\s+(?P<security_group>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Public\\s+IP\\s+:\\s+(?P<public_ip>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>Encryption|Hashing)\\s+:\\s+(?P<protocol>\\S+):\\s+(?P<value>\\S+)(\\s+SSL-Tunnel:\\s+(?P<ssl_tunnel>\\S+))?(\\s+DTLS-Tunnel:\\s+(?P<dtls_tunnel>\\S+))?$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "ios",
        "command": "show ntp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<mode_code>[x\\*\\#\\+\\- ])?(?P<configured>[\\~])? *(?P<remote>[\\w\\.\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\* sys.peer, +\\# selected, +\\+ candidate, +- outlyer, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\* master +\\(synced\\), +\\# master \\(unsynced\\), +\\+ ",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show access_session",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Session +count \\= +(?P<val>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>[\\w\\/\\-\\.]+) +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show archive",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^The +maximum +archive +configurations +allowed +is +(?P<max>\\d+)\\.$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^There +are +currently +(?P<total>\\d+) +archive +configurations +saved\\.$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<num>[0-9]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*!Contextual +Config +Diffs:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<line_info>(\\+|\\-)[\\w\\W]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*!List +of +(C|c)ommands:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Load +for +five +secs: +\\d+%\\/\\d+%; +one +minute:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time +source +is +\\w+, +\\*?\\d+:\\d+:\\d+\\.\\d+ +\\w+ +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(test#|Device#|Router#)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<line_info>([\\w\\W]+))$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show arp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<protocol>\\w+) +(?P<address>[\\d\\.\\:]+) +(?P<age>[\\d\\-]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<total_entries>\\w+) +IP +ARP +entries, +with ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ARP +statistics:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rcvd: +(?P<arp_in_requests>\\d+) +requests,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sent: +(?P<arp_out_requests>\\d+) +requests,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Drop +due +to +input +queue +full:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +statistics:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rcvd: +(?P<ip_rcvd_total>\\d+) +total,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_rcvd_format_errors>\\d+) +format +errors,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_rcvd_unknwn_protocol>\\d+) +unknown +protocol,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_rcvd_sec_failures>\\d+) +security +failures,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Opts: +(?P<ip_opts_end>\\d+) +end,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_opts_timestamp>\\d+) +timestamp,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_opts_strm_id>\\d+) +stream +ID,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_opts_other>\\d+) +other",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Frags: +(?P<ip_frags_reassembled>\\d+) +reassembled,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_frags_fragmented>\\d+) +fragmented,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_frags_invalid_hole>\\d+) +invalid hole$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bcast: +(?P<ip_bcast_received>\\d+) +received,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Mcast: +(?P<ip_mcast_received>\\d+) +received,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sent: +(?P<ip_sent_generated>\\d+) +generated,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Drop: +(?P<ip_drop_encap_failed>\\d+) +encapsulation",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_drop_no_route>\\d+) +no +route,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_drop_opts_denied>\\d+) +options +denied(,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ICMP +statistics:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rcvd: +(?P<icmp_received_format_errors>\\d+) +format ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<icmp_received_echo>\\d+) +echo,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<icmp_received_parameter>\\d+) +parameter,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<icmp_received_irdp_solicitations>\\d+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<icmp_received_time_exceeded>\\d+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sent: +(?P<icmp_sent_redirects>\\d+) +redirects, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<icmp_sent_mask_requests>\\d+) +mask +requests, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<icmp_sent_info_reply>\\d+) +info +reply, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<icmp_sent_irdp_solicitations>\\d+) +irdp ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^UDP +statistics:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rcvd: +(?P<udp_received_total>\\d+) +total,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sent: +(?P<udp_sent_total>\\d+) +total, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +statistics:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +clearing +of +OSPF +traffic +counters ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rcvd: +(?P<ospf_received_total>\\d+) +total, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ospf_received_hello>\\d+) +hello, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ospf_received_lnk_st_updates>\\d+) +link ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sent: +(?P<sent_total>\\d+) +total$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ospf_sent_hello>\\d+) +hello, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ospf_sent_lnk_st_updates>\\d+) +link ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PIMv2 +statistics: +Sent/Received",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total: +(?P<pimv2_total>[\\d\\/]+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Registers: +(?P<pimv2_registers>[\\d\\/]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Join/Prunes: +(?P<pimv2_join_prunes>[\\d\\/]+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bootstraps: +(?P<pimv2_bootstraps>[\\d\\/]+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Queue drops: +(?P<pimv2_queue_drops>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State-Refresh: +(?P<pimv2_state_refresh>[\\d\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +statistics: +Sent/Received",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total: +(?P<igmp_total>[\\d\\/]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Host +Queries: +(?P<igmp_host_queries>[\\d\\/]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DVMRP: +(?P<igmp_dvmrp>[\\d\\/]+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Queue drops: +(?P<igmp_queue_drops>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TCP +statistics:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rcvd: +(?P<tcp_received_total>\\d+) +total,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sent: +(?P<tcp_sent_total>\\d+) +total$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EIGRP-IPv4 +statistics:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP-EIGRP +statistics:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rcvd: +(?P<eigrp_ipv4_received_total>\\d+) +total$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sent: +(?P<eigrp_ipv4_sent_total>\\d+) +total$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +statistics:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rcvd: +(?P<bgp_received_total>\\d+) +total,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<bgp_received_keepalives>\\d+) +keepalives, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sent: +(?P<bgp_sent_total>\\d+) +total,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<bgp_sent_keepalives>\\d+) +keepalives, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Number +of +clients +registered: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<application_name>[\\w\\W]{0,20})(?P<id>\\d+)\\s+(?P<num_of_subblocks>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +number +of +entries +in +the +ARP +table: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +number +of +(?P<entry_name>[\\S\\s]+): +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface_name>[\\w\\/\\.]+) +(?P<entry_count>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Learn +ARP +Entry +Threshold +is +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<maximum_entries_name>[\\w\\W]+) +: +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show authentication_sessions",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Interface +MAC +Address +Method +Domain +Status +Session +ID",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +Identifier +Method +Domain +Status +Fg +Session +ID",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?:\\*)?Session +[Cc]ount +\\= +(?P<session_count>\\d+)(?:\\*)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?:\\*)?(?P<argument>[\\w\\s\\-]+)\\:(?:\\*)? +(?:\\*)?(?P<value>[\\w\\s\\-\\.\\./]+|\\S+)(?:\\*)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +Policies:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?:Service +)?Template: +(?P<template>\\w+) +\\(priority +(?P<priority>[0-9]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Vlan +Group: +(?P<vlan_name>\\w+): +(?P<vlan_value>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Method +status +list:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<method>[dot1x|mab]\\w+) +(?P<state>(\\w+\\s\\w+)|(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Runnable +methods +list:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^-+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Security +(?P<security_name>\\S+): +(?P<policy_status>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(.*)\\s+ Security +(?P<security_name>\\w+):(\\s+)* +(?P<policy_status>\\w+(\\s\\w+)?)(\\s+)+ Security +(?P<security_name2>\\w+):(\\s+)* +(?P<policy_status2>\\w+(\\s\\w+)?)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv6 +Address\\: +(?P<ipv6>\\S+?)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Server +Policies\\:$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show bfd",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<our_address>[\\d\\.]+)\\s+(?P<our_neighbor>[\\d\\.]+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<our_address>[\\d\\.]+) +(?P<our_neighbor>",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ld_rd>\\d+\\/\\d+)\\s+(?P<rh_rs>\\S+)\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<our_neighbor>[\\d\\.]+)\\s+(?P<ld_rd>\\d+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OurAddr:\\s+(?P<our_address>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Session +state +is +(?P<state>\\S+) +and +using",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Session +state +is +(?P<state>\\S+) +and +not ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Session\\s+Host:\\s+(?P<session_host>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Handle: +(?P<handle>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Local +Diag: +(?P<local_diag>\\d+), +Demand +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MinTxInt:\\s+(?P<min_tx_interface>\\d+),\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MinTxInt: +(?P<min_tx_interface>\\d+), +MinRxInt",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Received +MinRxInt:\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Hold(d)?own +\\(hits\\): +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Rx +Count: +(?P<count>\\d+), +Rx +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Rx +Count: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Tx +Count: +(?P<count>\\d+), +Tx +Interval +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Tx +Count: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Elapsed +time +watermarks: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Registered +protocols: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Uptime: +(?P<up_time>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last\\s+packet:\\s+Version:\\s+(?P<version>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Last\\s+packet:\\sVersion:\\s+(?P<version>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*\\-\\s+Diagnostic:\\s+(?P<diagnostic>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*State +bit: +(?P<state_bit>\\S+)\\s+\\-\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*I +Hear +You +bit: +(?P<i_hear_you_bit>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Poll\\s+bit:\\s+(?P<poll_bit>\\d+)\\s+\\-\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*C +bit: +(?P<c_bit>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multiplier: +(?P<multiplier>\\d+)\\s+\\-\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*My +Discr\\.: +(?P<my_discr>\\d+)\\s+\\-\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Min +tx +interval: +(?P<min_tx_interval>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Min\\s+Echo\\s+interval:\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Cleanup +timer +hits: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*SSO +Cleanup +Timer +called: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*SSO +Cleanup +Action +Taken: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Pseudo +pre-emptive +process +count: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPC +Tx +Failure +Count: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPC +Rx +Failure +Count: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Total +Adjs +Found: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Hol(d)?down +\\- +negotiated: +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show bgp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*For +address +family: +(?P<address_family>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +version +is +(?P<bgp_table_version>[0-9]+), +[Ll]ocal +[Rr]outer +ID +is +(?P<local_router_id>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?(?P<path_type>(i|e|c|l|a|r|I))?\\s*(?P<prefix>[a-zA-Z0-9\\.\\:\\/\\[\\]\\,\\-]+)(?: *(?P<param>[a-zA-Z0-9\\.\\:\\/\\[\\]\\,]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|m|r|\\s)+)?(?P<path_type>(i|e|c|l|a|r|I))?\\s{10,20}(?P<next_hop>[a-zA-Z0-9\\.\\:]+) +(?P<metric>(?:\\d+(?=[ \\d]{13}\\d ))?) +(?P<local_prf>(?:\\d+(?=[ \\d]{6}\\d ))?) +(?P<weight>\\d+)(?P<termination>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(?:s|x|S|d|h|m|r|\\*|\\>|\\s)+)?(?P<path_type>(?:i|e|c|l|a|r|I))? *(?P<prefix>[a-zA-Z0-9\\.\\:\\/\\-\\[\\]]+) +(?P<next_hop>[a-zA-Z0-9\\.\\:]+) +(?P<metric>(?:\\d+(?=[ \\d]{13}\\d ))?) +(?P<local_prf>(?:\\d+(?=[ \\d]{6}\\d ))?) +(?P<weight>\\d+)(?P<path>[0-9 \\S\\{\\}]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*AF-Private +Import +to +Address-Family: +(?P<af_private_import_to_address_family>[\\s\\S]+), +Pfx +Count/Limit: +(?P<pfx_count>[\\d]+)\\/+(?P<pfx_limit>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +Distinguisher *: +(?P<route_distinguisher>(\\S+))( +\\(default for vrf +(?P<default_vrf>(\\S+))\\))?( +VRF Router ID (?P<vrf_router_id>(\\S+)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^For +address +family: +(?P<address_family>[a-zA-Z0-9\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Paths: +\\((?P<paths>(?P<available_path>[0-9]+) +available\\, +(no +best +path|best +\\#(?P<best_path>[0-9]+))\\,?(?: +(table +(?P<vrf_id>\\S+?)|no +table))?,?(?: +(.*))?)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +Distinguisher: +(?P<route_distinguisher>[0-9.\\:]+)(?: +\\(default +for +vrf +(?P<vrf_id>(\\S+))\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +routing +table +entry +for +(\\[[0-9]+\\])?((?P<route_distinguisher>((\\[[0-9]+[\\:][0-9]+\\])|[0-9]+])|([0-9.]+[:][0-9]+[:])))?(\\[[0-9]+\\])?(\\[[0-9]+\\])?(?P<router_id>((\\[[0-9]+[\\.][0-9]+[\\.][0-9]+[\\.][0-9]+\\][\\/][0-9]+)|([0-9]+[\\.][0-9]+[\\.][0-9]+[\\.][0-9]+[\\/][0-9]+)|([a-zA-Z0-9]+[\\:][a-zA-Z0-9]+[\\:][a-zA-Z0-9]+[\\:][\\:][a-zA-Z0-9]+[\\/][0-9]+)|([a-zA-Z0-9]+[\\:][a-zA-Z0-9]+[\\:][a-zA-Z0-9]+[\\:][a-zA-Z0-9]+[\\:][\\:][\\/][0-9]+)|([a-zA-Z0-9]+[\\:][a-zA-Z0-9]+[\\:][a-zA-Z0-9]+[\\:][a-zA-Z0-9]+[\\:][\\:][0-9]+[\\/][0-9]+)))\\, +version +(?P<prefix_table_version>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +routing +table +entry +for +(?:(?P<rd>([0-9\\:\\[\\]]+)))?:(?P<router_id>(\\S+)),? +version +(?P<version>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<next_hop>[a-zA-Z0-9\\.\\:]+)(( +\\(metric +(?P<next_hop_igp_metric>[0-9]+)\\))|( +\\((?P<inaccessible>inaccessible)\\)))?( +\\(via +(?P<next_hop_via>[\\S\\s]+)\\))? +from +(?P<gateway>[a-zA-Z0-9\\.\\:]+) +\\((?P<originator>[0-9\\.]+)\\))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Origin +(?P<origin>[a-zA-Z]+),(?: +metric +(?P<metric>[0-9]+),?)?(?: +localpref +(?P<locprf>[0-9]+),?)?(?: +weight +(?P<weight>[0-9]+),?)?(?: +(?P<valid>valid?,))?(?: +(?P<sourced>sourced?,))?(?: +(?P<state>(internal|external|local)\\,?))?(?: +(?P<aggregate>atomic-aggregate?))?(\\,)?(?: +(?P<best>best))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Advertised +to +update-groups *:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Not +advertised +to +any +peer$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<group1>(\\d+))(?: +(?P<group2>(\\d+)) +(?P<group3>(\\d+)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Refresh +Epoch +(?P<refresh_epoch>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Extended +Community\\: +(?P<ext_community>([a-zA-Z0-9\\-\\:]+)) +ENCAP *:(?P<encap>(\\d+)) +Router +(?P<router_mac>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Extended +Community *: +(?P<ext_community>([a-zA-Z0-9\\-\\:\\s]+))(?: *, +(?P<recursive>(recursive-via-connected)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Community: +(?P<community>[\\S+\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^AGI +version\\((?P<agi_version>(\\d+))\\), +VE +Block +Size\\((?P<ve_block_size>(\\d+))\\) +Label +Base\\((?P<label_base>(\\d+))\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Originator: +(?P<originator>(\\S+)), +Cluster +list: +(?P<cluster_list>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^rx +pathid\\: +(?P<recipient_pathid>[0-9x]+)\\, +tx +pathid\\: +(?P<transfer_pathid>[0-9x]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EVPN +ESI\\: +(?P<evpn_esi>[0-9]+)\\, +Gateway +Address\\: +(?P<gateway_address>[a-zA-Z0-9\\.\\:]+)\\, +local vtep\\: +(?P<local_vtep>[a-zA-Z0-9\\.\\:]+)\\, +[L|l]abel +(?P<label>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +vxlan +vtep\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bdi\\:(?P<bdi>[A-Z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^vrf\\:(?P<vrf>[a-zA-Z0-9]+)\\, +vni\\:(?P<vni>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^local +router +mac\\:(?P<local_router_mac>[a-zA-Z0-9\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^encap\\:(?P<encap>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^vtep-ip\\:(?P<vtep_ip>[0-9\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<route_info>[a-zA-Z0-9\\-\\.\\{\\}\\s\\(\\)\\/\\:\\[\\]]+)(\\,)?(?: +\\(aggregated +by +(?P<aggregated_by>[\\w\\s\\.\\:]+)\\)(\\,))?(?: +(?P<route_status>[A-Za-z0-9\\.\\:\\/\\(\\)\\s\\[\\]\\-\\&]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^mpls +labels +in\\/out +(?P<in>\\w+)\\/(?P<out>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^For address family: +(?P<address_family>[a-zA-Z0-9\\s\\-\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +router +identifier",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +table +version +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<networks>[0-9]+) +network +entries +using",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<path>[0-9]+) +path +entries +using",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<num_entries>([0-9]+)) +BGP",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<num_community_entries>[0-9]+) +BGP +extended",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<attribute_entries>(\\S+)) +BGP",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<num_cache_entries>([0-9]+)) +BGP",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +using +(?P<total_memory>[0-9]+) +total +bytes",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +activity +(?P<activity_prefixes>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ *(?P<our_entry>\\*)?(?P<neighbor>[a-zA-Z0-9\\.\\:]+) +(?P<version>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<neighbor>[a-zA-Z0-9\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<version>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^For +address +family: +(?P<af>[a-zA-Z0-9\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +neighbor +is +(?P<neighbor>(\\S+)), +remote +AS",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +neighbor +is +(?P<neighbor>(\\S+)), +vrf",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +neighbor +is +(?P<neighbor>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Description: +(?P<description>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Administratively shut down$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +version +(?P<bgp_version>(\\d+)), +remote",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(BGP|Session) +state += +(?P<session_state>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +read +(?P<last_read>(\\S+)), +last +write",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured +hold +time +is (?P<holdtime>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Minimum +holdtime +from +neighbor +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +sessions:+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<sessions>(\\d+)) active,(?: +is +not +multisession",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +capabilities:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +refresh: +(?P<route_refresh>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Four-octets +ASN +Capability: +(?P<cap>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address +family +(?P<af_type>([a-zA-Z0-9\\s\\-]+)) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Graceful +Restart +Capability: +(?P<gr>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +Restart +timer +is +(?P<timer>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<af_type1>([a-zA-Z0-9\\s]+)) +\\(was +not",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enhanced +Refresh +Capability: +(?P<erc>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multisession +Capability: +(?P<multisession>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Stateful +switchover +support +(?P<state>(\\S+)):",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Message +statistics(( +for +(?P<state>[\\w. ]+))|(, +state +Established))?:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<qtype>(InQ|OutQ)) +depth +is +(?P<val>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<table_type>(Prefix activity|",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Default +minimum +time +between +advertisement",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address +tracking +is +(?P<status>(\\S+)), +the +RIB",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Connections +established +(?P<established>(\\d+));",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +reset +(?P<reset>(\\S+))(?:, +due +to",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Transport\\(tcp\\) +path-mtu-discovery +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Graceful-Restart +is +(?P<gr>(enabled|disabled))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Connection +state +is +(?P<state>(\\S+)), +I/O",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Connection +is +ECN +(?P<ecn_state>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +host: +(?P<local_host>(\\S+)), +Local +port:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Foreign +host: +(?P<foreign_host>(\\S+)), +Foreign",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Connection +tableid +\\(VRF\\): +(?P<val>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +output +segment +queue +size:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enqueued +packets +for +retransmit:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Event +Timers +\\(+current +time +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<item>(\\S+)) +(?P<starts>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^iss: +(?P<iss>(\\d+)) +snduna: +(?P<snduna>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^irs: +(?P<irs>(\\d+)) +rcvnxt: +(?P<rcvnxt>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^sndwnd: +(?P<sndwnd>(\\d+)) +scale: +(?P<scale>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^rcvwnd: +(?P<rcvwnd>(\\d+)) +scale: +(?P<scale>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SRTT: +(?P<srtt>(\\d+)) +ms, +RTTO: +(?P<rtto>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^minRTT: +(?P<min_rtt>(\\d+)) +ms, +maxRTT:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^uptime: +(?P<uptime>(\\d+)) +ms, +Sent +idletime:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Status +Flags: +(?P<flags>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Option +Flags: +(?P<flags>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +Precedence +value : +(?P<value>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Datagrams +\\(max +data +segment +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rcvd: +(?P<received>(\\d+)) +\\(out +of +order:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sent: (?P<sent>(\\d+)) +\\(retransmit:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Packets +received +in +fast +path: +(?P<rcv>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^fast +lock +acquisition +failures:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TCP +Semaphore +(?P<semaphore>0x[0-9a-fA-F]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +table +version +(?P<bgp_table_version>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +queue +size *: +(?P<size>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Index +(?P<index>(\\d+)), +Advertise +bit",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route-Reflector +Client$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<num>(\\d+)) +update-group +member$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Community +attribute +sent +to +this +neighbor$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Extended-community +attribute +sent +to +this",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Suppress +LDP +signaling +protocol$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Slow-peer +detection +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Slow-peer +split-update-group +dynamic +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +NLRIs +in +the +update +sent: +max",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +detected +as +dynamic +slow +peer:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dynamic +slow +peer +recovered: +(?P<val>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Refresh +Epoch: +(?P<num>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +(Sent|Received) +Refresh +Start-of-rib:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +(Sent|Received) +Refresh +End-of-rib:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Refresh-(?P<type>(In|Out)) +took +(?P<val>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SSO +is +(?P<state>(enabled|disabled))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No +active +TCP +connection$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*For +address +family:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|b|h|\\*|\\>|\\s)+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +Distinguisher *: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +version +is\n                         ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|b|h|\\*|\\>|\\s)+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*For +address +family:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +version +is\n                            ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<next_hop>[a-zA-Z0-9\\.\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +Distinguisher *: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*For +address +family:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +version +is\n                         ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(b|s|x|S|d|h|r|\\*|\\>|\\s)+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<metric>(\\d+)) +(?P<locprf>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|r|h|\\*|\\>|\\s)+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +Distinguisher *: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Global +cluster-id: +(?P<cluster_id>[0-9\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*all +\\(+inter-cluster +and +intra-cluster+\\):",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*intra-cluster:\\s+(?P<intra_cluster_configured>[a-zA-Z]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<cluster_ids>[0-9\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Neighbor: +(?P<neighbor>[\\S]+), +Address-Family: +(?P<address_family>[\\w\\s\\-\\_]+)( +\\((?P<vrf>[\\S]+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-map +(?P<route_map_name>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Template:+(?P<template_id>[0-9\\s\\S\\w]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Local +policies:+(?P<local_policies>0x[0-9A-F]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Locally +configured +session +commands:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*remote-as +(?P<remote_as>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*password +(?P<password_text>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*shutdown$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ebgp-multihop +(?P<ebgp_multihop_max_no>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*update-source +(?P<update_source>[\\d\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*transport +connection-mode +(?P<transport_connection_mode>[\\s\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*description +(?P<desc>[\\d\\S\\s\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*dont-capability-negotiate +four-octets-as$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*timers +(?P<keepalive_interval>[\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*local-as +(?P<local_as_as_no>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*disable-connected-check$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*fall-over +bfd$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Inherited +session +commands:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Template:+(?P<template_id>[0-9\\s\\S\\w]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Local +policies:+(?P<local_policies>0x[0-9A-F]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Local +disable +policies:+(?P<local_disable_policies>0x[0-9A-F]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Locally +configured +policies:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-map +(?P<remote_map_in>[0-9a-zA-Z]+) +in$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-map +(?P<route_map_out>[0-9a-zA-Z]+) +out$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*default-originate +route-map",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*soft-reconfiguration",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*maximum-prefix",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*as-override$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*allowas-in +(?P<allowas_in_as_number>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-reflector-client$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*next-hop-self$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*send-community +(?P<send_community>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*soo +(?P<soo>[\\w\\:\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Inherited policies:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*For +address +family:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*dampening",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Half-life +time\\s*:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Max +suppress +penalty:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Suppress +penalty +:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*% +dampening +not +enabled +for +base$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*For +vrf: +(?P<vrf_name>[\\w\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*% +dampening +not +enabled +for +vrf +(?P<vrf_name>[\\d\\w]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show cdp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<device_id>\\S+) +(?P<local_interface>[a-zA-Z]+[\\s]*[\\d\\/\\.]+) +(?P<hold_time>\\d+) +(?P<capability>[RTBSsHIrPDCM\\s]+)( +(?P<platform>\\S+))?(\\s+(?P<port_id>(Fa|Gi|GE).\\s*\\d*\\/*\\d*))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<device_id>\\S+) +(?P<local_interface>[a-zA-Z]+[\\s]*[\\d\\/\\.]+) +(?P<hold_time>\\d+) +(?P<capability>[RTBSsHIrPDCM\\s]+)(?: +(?P<platform>[\\w\\-]+ (\\d+)?))?( +(?P<port_id>[a-zA-Z0-9\\/]+( [a-zA-Z0-9\\/\\s]+)?))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<device_id>\\S+) +(?P<local_interface>[a-zA-Z]+[\\s]*[\\d\\/\\.]+) +(?P<hold_time>\\d+) +(?P<capability>[RTBSsHIrPDCM\\s]+)( +(?P<platform>\\S+(?: \\d+)?))?( (?P<port_id>[\\s\\S]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<device_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<local_interface>[a-zA-Z]+[\\s]*[\\d/.]+) +(?P<hold_time>\\d+) +(?P<capability>[RTBSsHIrPDCM\\s]+)( +(?P<platform>\\S+))?( (?P<port_id>[\\.a-zA-Z0-9/\\s]+))?$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show clns",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<interface>[\\w]+[\\d/.|\\s]+) +is +(?P<status>[\\w\\s]+), +line +protocol +is +(?P<line_protocol>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CLNS +protocol +processing +disabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Checksums +(?P<checksum>\\w+), +MTU +(?P<mtu>\\d+), +Encapsulation +(?P<encapsulation>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ERPDUs +(?P<erpdus>\\w+), +min. +interval +(?P<min_interval>\\d+) +msec.$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CLNS +(?P<fast_sse>\\w+) +switching +(?P<switching_status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DEC +compatibility +mode +(?P<dec_compatibilty_mod>\\w+) +for +this +interface$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Next +ESH/ISH +in +(?P<next_esh_ish>\\d+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routing +Protocol: +(?P<routing_protocol>[\\S]+)( +\\((?P<process_id>\\w+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Circuit +Type: +(?P<circuit_type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +number +(?P<interface_number>\\w+), +local +circuit +ID +(?P<local_circuit>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +Extended +Local +Circuit +ID: +(?P<neighbor_extended_local_circute_id>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<level>\\S+) +Metric: +(?P<level_metric>\\d+), +Priority: +(?P<priority>\\d+), +Circuit +ID: +(?P<circuit_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DR +ID: +(?P<dr_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<level>\\S+) +IPv6 +Metric: +(?P<level_ipv6_metric>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +active +(?P<level>\\S+) +adjacencies: +(?P<adjacencies>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Next +IS\\-IS +LAN (?P<level>\\S+) +Hello +in +(?P<level_hello>\\d+) +(?P<milli>[\\w\\(\\)]+)?seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Next\\s+IS\\-IS\\s+Hello\\s+in\\s+(?P<hello>\\d+)\\s+(?P<milli>[\\w\\(\\)]+)?seconds",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)if\\s+state\\s+(?P<if_state>DOWN|UP)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IS-IS Router: +(?P<tag_process>[\\S\\s]+?)( +\\((?P<tag>\\w+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*System Id: +(?P<system_id>[\\w\\.]+) +IS\\-Type: +(?P<is_type>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Manual +area +address\\(es\\):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<area_address>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Routing +for +area +address\\(es\\):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interfaces +supported +by +IS\\-IS:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[A-Za-z]+[\\d/.]+) \\- +(?P<topology>[\\w\\-\\ ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Redistribute:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<space>\\s{4})(?P<redistribute>[a-z\\s\\(\\)]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Distance +for +L2 +CLNS +routes: +(?P<distance>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RRR +level: +(?P<rrr_level>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Generate +narrow +metrics: +(?P<generate_narrow_metric>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Accept +narrow +metrics: +(?P<accept_narrow_metric>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Generate +wide +metrics: +(?P<generate_wide_metric>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Accept +wide +metrics: +(?P<accept_wide_metric>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tag +(?P<tag>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<system_id>[\\w\\.]+) +(?P<interface>\\S+) +(?P<snpa>[\\w\\.]+) +(?P<state>\\w+) +(?P<holdtime>\\d+) +(?P<level>[L\\d]+) +(?P<protocol>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +Address\\(es\\): +(?P<area_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +Address\\(es\\): +(?P<ip_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv6 +Address\\(es\\): +(?P<ipv6_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Uptime: +(?P<uptime>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NSF +(?P<nsf>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology: +(?P<topology>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +name: +(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tag +(?P<tag>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<system_id>[\\w\\.]+)\\s+(?P<interface>\\S+)\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +Address\\(es\\): +(?P<area_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +Address\\(es\\): +(?P<ip_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv6 +Address\\(es\\): +(?P<ipv6_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Uptime: +(?P<uptime>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NSF +(?P<nsf>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology: +(?P<topology>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +name: +(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CLNS:  +Time +since +last +clear: (?P<last_clear>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CLNS \\& +ESIS +Output: +(?P<clns_output>\\d+), +Input: +(?P<clns_input>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dropped Protocol not enabled on interface: +(?P<dropped_protocol>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CLNS +Local: +(?P<clns_local>\\d+), Forward: +(?P<clns_forward>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)CLNS +Discards:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hdr +Syntax: +(?P<hdr_syntax>\\d+), +Checksum: +(?P<checksum>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No +Route: +(?P<no_route>\\d+), +Discard +Route: +(?P<discard_route>\\d+), +Dst +Unreachable +(?P<dst_unreachable>\\d+), +Encaps. +Failed: +(?P<encaps_failed>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NLP +Unknown: +(?P<nlp_unknown>\\d+), +Not +an +IS: +(?P<not_an_is>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CLNS +Options: +Packets +(?P<packets>\\d+), +total +(?P<total>\\d+) , +bad +(?P<bad>\\d+), +GQOS +(?P<gqos>\\d+), +cngstn +exprncd +(?P<cngstn_exprncd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CLNS +Segments:  +Segmented: +(?P<segmented>\\d+), +Failed: +(?P<failed>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CLNS +Broadcasts: sent: +(?P<sent>\\d+), +rcvd: +(?P<rcvd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Echos: +Rcvd +(?P<requests>\\d+) +requests, +(?P<replied>\\d+) +replies$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sent +(?P<requests>\\d+) +requests, +(?P<replied>\\d+) +replies$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ESIS\\(sent\\/rcvd\\): +ESHs: +(?P<esh_sent>\\d+)/(?P<esh_rcvd>\\d+), +ISHs: +(?P<ish_sent>\\d+)/(?P<ish_rcvd>\\d+), +RDs: +(?P<rd_sent>\\d+)/(?P<rd_rcvd>\\d+), +QCF: +(?P<qcf_sent>\\d+)/(?P<qcf_rcvd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tunneling +\\(sent\\/rcvd\\): +IP: +(?P<ip_sent>\\d+)/(?P<ip_rcvd>\\d+), +IPv6: +(?P<ipv6_sent>\\d+)/(?P<ipv6_rcvd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tunneling +dropped +\\(rcvd\\) +IP\\/IPV6:  +(?P<tunneling_dropped>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ISO-IGRP: +Querys +\\(sent\\/rcvd\\): (?P<query_sent>\\d+)/(?P<query_rcvd>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ISO-IGRP: +Router +Hellos: +\\(sent\\/rcvd\\): +(?P<hello_sent>\\d+)\\/+(?P<hello_rcvd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ISO\\-IGRP +Syntax +Errors: +(?P<syntax_errors>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tag +(?P<tag>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Time +since +last +clear: +(?P<last_clear>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-1 +Hellos \\(sent\\/rcvd\\): +(?P<sent>\\d+)\\/(?P<rcvd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-2 +Hellos \\(sent\\/rcvd\\): +(?P<sent>\\d+)\\/(?P<rcvd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +PTP +Hellos *\\(sent\\/rcvd\\): +(?P<sent>\\d+)\\/(?P<rcvd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-1 +LSPs +sourced \\(new\\/refresh\\): +(?P<new>\\d+)\\/(?P<refresh>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-2 +LSPs +sourced \\(new\\/refresh\\): +(?P<new>\\d+)\\/(?P<refresh>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-1 +LSPs +flooded \\(sent\\/rcvd\\): +(?P<sent>\\d+)\\/(?P<rcvd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-2 +LSPs +flooded \\(sent\\/rcvd\\): +(?P<sent>\\d+)\\/(?P<rcvd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +LSP +Retransmissions: +(?P<lsp_retransmissions>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-1 +CSNPs \\(sent\\/rcvd\\): +(?P<sent>\\d+)\\/(?P<rcvd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-2 +CSNPs \\(sent\\/rcvd\\): +(?P<sent>\\d+)\\/(?P<rcvd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-1 +PSNPs \\(sent\\/rcvd\\): +(?P<sent>\\d+)\\/(?P<rcvd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-2 +PSNPs \\(sent\\/rcvd\\): +(?P<sent>\\d+)\\/(?P<rcvd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-1 +DR +Elections: +(?P<dr_elections>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-2 +DR +Elections: +(?P<dr_elections>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-1 +SPF +Calculations: +(?P<spf_calculation>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-2 +SPF +Calculations: +(?P<spf_calculation>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-1 +Partial +Route +Calculations: +(?P<partial_route_calculations>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Level\\-2 +Partial +Route +Calculations: +(?P<partial_route_calculations>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +LSP +checksum +errors +received: +(?P<lsp_checksum_errors_received>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Update +process +queue +depth: +(?P<update_process_queue_depth>[\\d\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS: +Update +process +packets +dropped: +(?P<update_process_packets_dropped>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show config",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*Owner +PID +: *(?P<owner_pid>(\\-)?\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*TTY +number +: +(?P<tty_number>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*TTY +username +: +(?P<tty_username>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*User +debug +info +: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Lock +(a|A)ctive +time +\\(in +Sec\\) +: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Parser +Configure +Lock$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*User *: *(?P<user>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*TTY *: *(?P<tty>(\\-)?\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Type *: *(?P<type>[\\w\\W]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*State *: *(?P<state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Class *: *(?P<class_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Count *: *(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Pending +Requests *: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*User +debug +info *: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Session +idle +state *: *(?P<session_idle_state>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No +of +exec +cmds +getting +executed *: *(?P<num_of_exec_cmds_executed>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No +of +exec +cmds +blocked *: *(?P<num_of_exec_cmds_blocked>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Config +wait +for +show +completion *: *(?P<config_wait_for_show_completion>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +ip +address *: *(?P<remote_ip_address>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Lock +Expiration +timer +\\(in +Sec\\) *: *(?P<lock_expiration_timer_in_sec>[\\w]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show crypto",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^((?P<cer>Certificate)|(?P<cer_name>(CA|Router Self-Signed) +Certificate))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Status: +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Certificate +Serial +Number( +\\(hex\\))?: +(?P<serial_number_in_hex>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Certificate Usage: +(?P<usage>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<issuer>Issuer)|(?P<subject>Subject)|(?P<validity_date>Validity +Date)):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?i)^cn *= *(?P<cn>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?i)^o *= *(?P<o>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Name: +(?P<name>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Serial +Number: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<crl_distribution_points>^http:[\\w\\/\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<start_date>start +date)|(?P<end_date>end +date)): +(?P<value>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Associated +Trustpoints: +(?P<trustpoints>[\\w\\-]+)( +Trustpool)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Storage: +(?P<storage>(\\S+))$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show dmvpn",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)Interface: +(?P<interfaces>\\S+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Type:(?P<type>\\S+), +NHRP Peers:(?P<nhrp_peers>(\\d+)),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)((?P<ent>(\\d+)) +(?P<peers>[a-z0-9\\.\\:]+) +)?(?P<tunnel_addr>[a-z0-9\\.\\:]+) +(?P<state>[a-zA-Z]+) +(?P<time>(\\d+\\w)+|never|[0-9\\:]+) +(?P<attrb>(\\w)+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show dot1x",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Sysauthcontrol +(?P<val>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dot1x +Protocol +Version +(?P<val>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dot1x +Info +for +(?P<intf>[\\w\\-\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\w\\s]+) +\\= +(?P<val>[\\w\\-]+)( *[\\(\\)\\s\\w]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EAP +Method +\\= +(?P<eap>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Supplicant +\\= +(?P<client>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Session +ID +\\= +(?P<session_id>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auth +SM +State +\\= +(?P<state>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auth +BEND +SM +State +\\= +(?P<state>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dot1x +(Supplicant|Authenticator) +Port +Statistics +for +(?P<intf>[\\w\\-\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RxVersion +\\= *(?P<rxversion>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(\\w+) +\\= *(\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>[\\w\\-\\/]+) +(?P<pae>\\w+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<pae>\\w+) +)?(?P<client>\\w+\\.\\w+\\.\\w+) +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Authorized +Clients +\\= +(?P<authorized_clients>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^UnAuthorized +Clients +\\= +(?P<unauthorized_clients>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +No +of +Client +\\= +(?P<total>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show fdb",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Total +Mac +Addresses +for +this +criterion: +(?P<val>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<entry>[\\w\\*] )?\\s*(?P<vlan>All|[\\d\\-]+) +(?P<mac>[\\w.]+) +(?P<entry_type>\\w+) +(?P<intfs>\\S+|[^\\s]+\\s[^\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intfs>(vPC Peer-Link)?[\\w\\/\\,\\(\\)]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<entry>[\\w\\*] )?\\s*(?P<vlan>All|[\\d\\-]+) +(?P<mac>[\\w.]+) +(?P<entry_type>\\w+) +(?P<learn>\\w+) +(?P<age>[\\d\\-\\~]+) +(?P<intfs>(vPC )?[\\w\\/\\,\\-\\(\\)\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<entry>[\\w\\*] )?\\s*(?P<vlan>All|[\\d\\-]+) +(?P<mac>[\\w.]+) +(?P<entry_type>\\w+) +(?P<protocols>[\\w\\,]+) +(?P<intfs>\\S+|[^\\s]+\\s[^\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Global +Aging +Time: +(?P<time>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<vlan>\\w+) +(?P<time>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Learning +disabled +on +vlans: +(?P<vlans>[\\w\\,\\-\\s]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show flow",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Cache +type: +(?P<cache_type>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Cache +size: +(?P<cache_size>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current +entries: +(?P<current_entries>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^High +Watermark: +(?P<high_water_mark>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flows +added: +(?P<flows_added>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flows +aged: +(?P<flows_aged>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ipv4_src_addr>\\S+) +(?P<ipv4_dst_addr>\\S+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Cache +type: +(?P<cache_type>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Cache +size: +(?P<cache_size>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current +entries: +(?P<current_entries>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^High +Watermark: +(?P<high_water_mark>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flows +added: +(?P<flows_added>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flows +aged: +(?P<flows_aged>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^- +(?P<key>[\\S\\s]+?)( +\\( +(?P<secs>\\d+) +secs\\))? +(?P<value>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_vrf_id_input>\\d+ +\\(\\S+\\)) +(?P<ipv4_src_addr>\\S+) +(?P<ipv4_dst_addr>\\S+) +(?P<intf_input>\\S+) +(?P<intf_output>\\S+) +(?P<pkts>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP VRF ID INPUT: +(?P<id>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPV4 SOURCE ADDRESS: +(?P<src>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPV4 DESTINATION ADDRESS: +(?P<dst>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^interface input: +(?P<input>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^interface output: +(?P<output>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^counter packets: +(?P<pkts>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show igmp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Global +IGMP +State +Limit *: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>[\\w\\-\\.\\/]+) +is +(?P<intf_status>[\\w\\s]+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Internet protocol processing (?P<disabled>disabled)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Internet +address +is +(?P<ip>[\\w\\/\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +is +(?P<status>\\w+) +on +interface$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current +IGMP +host +version +is +(?P<ver>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current +IGMP +router +version +is +(?P<ver>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +query +interval +is +(?P<query_interval>\\d+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +configured +query +interval +is +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +querier +timeout +is +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +configured +querier +timeout +is +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +max +query +response +time +is +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +member +query +count +is +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +member +query +response +interval +is ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Inbound +IGMP +access +group +is +(?P<group_policy>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +activity: +(?P<joins>\\d+) +joins, +(?P<leaves>\\d+) +leaves$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +IGMP +State +Limit *: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multicast +routing +is +enabled +on +interface$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multicast +TTL +threshold +is +(?P<ttl>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multicast +designated +router +\\(DR\\) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +querying +router +is +(?P<querier>[\\w\\.\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)([\\w\\.\\:]+)\\((\\d+)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multicast +Routing +table +(?P<routing_table>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface: +(?P<intf>[\\w\\.\\-\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group: +(?P<group>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flags:( *(?P<flags>[\\w\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Uptime: +(?P<up_time>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group +mode: +(?P<group_mode>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +reporter: +(?P<last_reporter>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<source>[\\w\\.\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +list +is +empty$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group +address *: +(?P<group_address>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Database *: +(?P<database>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +list *: +(?P<source_addr>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<source_addr>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show install",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\[ +(?P<location>[\\S ]+)\\] +Installed Package\\(s\\) +Information:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>\\S+) + (?P<state>\\w) +(?P<filename_version>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auto +abort +timer: +(?P<auto_abort_timer>[\\S ]+), +time +before +rollback +\\- +(?P<time_before_rollback>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auto +abort +timer: +(?P<auto_abort_timer>[\\S ]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show interface",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<interface>[\\w\\/\\.\\-]+) +is +(?P<enabled>[\\w\\s]+)(?: +\\S+)?, +line +protocol +is +(?P<line_protocol>\\w+)(?: *\\((?P<attribute>\\S+)\\)|( +\\, +Autostate +(?P<autostate>\\S+)))?.*$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\w\\/\\.\\-]+) +is +(?P<enabled>[\\w\\s]+), +line +protocol +is +(?P<line_protocol>\\w+)( *, *(?P<attribute>[\\w\\s]+))?$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Hardware +is +(?P<type>[a-zA-Z0-9\\-\\/\\s\\+]+)(, *address +is +(?P<mac_address>[a-z0-9\\.]+) *\\(bia *(?P<phys_address>[a-z0-9\\.]+)\\))?$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)Hardware +is +(?P<type>[a-zA-Z0-9\\-\\/\\+ ]+)(?P<mac_address>.*)(?P<phys_address>.*)",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Description: *(?P<description>.*)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Secondary +Address +is +(?P<ipv4>(?P<ip>[0-9\\.]+)\\/(?P<prefix_length>[0-9]+))$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Internet +[A|a]ddress +is +(?P<ipv4>(?P<ip>[0-9\\.x]+)\\/(?P<prefix_length>[0-9]+))$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU +(?P<mtu>\\d+) +bytes(, +sub +MTU +(?P<sub_mtu>\\d+))?, +BW +(?P<bandwidth>[0-9]+) +Kbit(\\/sec)?(, +RxBW +[0-9]+ +Kbit(\\/sec)?)?, +DLY +(?P<delay>[0-9]+) +usec,$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^reliability +(?P<reliability>[\\d\\/]+), +txload +(?P<txload>[\\d\\/]+), +rxload +(?P<rxload>[\\d\\/]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Encapsulation(\\(s\\):)? +(?P<encapsulation>[\\w\\s\\.]+)(, +(?P<rest>.*))?$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Keepalive +set +\\((?P<keepalive>[0-9]+) +sec\\)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<duplex_mode>\\w+)[\\-\\s]+[d|D]uplex\\, +(?P<port_speed>[\\w\\s\\/]+|[a|A]uto-[S|s]peed|Auto (S|s)peed)(?:(?:\\, +link +type +is +(?P<link_type>\\S+))?(?:\\, *(media +type +is| )*(?P<media_type>[\\w\\/\\- ]+)?)(?: +media +type)?)?$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(input|output) +flow-control +is +(?P<receive>\\w+), +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ARP +type: +(?P<arp_type>\\w+), +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +input +(?P<last_input>[\\w\\.\\:]+), +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Members +in +this +channel: +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^No\\. +of +active +members +in +this +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Member +\\d+ +: +(?P<interface>\\S+) +,",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^No\\. +of +PF_JUMBO +supported +members +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +clearing +of +\\\"show +interface\\\" +counters +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Input +queue: +(?P<size>\\d+)\\/(?P<max>\\d+)\\/",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Queueing +strategy: +(?P<queue_strategy>\\S+).*$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +queue: +(?P<size>\\d+)\\/(?P<max>\\d+)",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<load_interval>[0-9\\#]+)",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<load_interval>[0-9\\#]+)",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_pkts>[0-9]+) +packets +input, +(?P<in_octets>[0-9]+) ",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Received +(?P<in_broadcast_pkts>\\d+) +broadcasts +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_runts>[0-9]+) *runts,",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_errors>[0-9]+) +input +errors, +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_watchdog>[0-9]+) +watchdog, +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_with_dribble>[0-9]+) +input +packets +with +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_pkts>[0-9]+) +packets +output, +(?P<out_octets>[0-9]+) ",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Received +(?P<out_broadcast_pkts>\\d+) +broadcasts +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_errors>[0-9]+) +output +errors,",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_unknown_protocl_drops>[0-9]+) +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_babble>[0-9]+) +babbles, +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_lost_carrier>\\d+) +lost +carrier, +(?P<out_no_carrier>\\d+) +no +carrier(, +(?P<out_pause_output>\\d+) +pause +output)?$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_buffer_failure>[0-9]+) +output +buffer +failures, +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +is +unnumbered. +Using +address +of +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<maximum_active_vcs>\\d+) +maximum +active +VCs, +(?P<vcs_per_vp>\\d+) +VCs +per +VP, +(?P<current_vccs>\\d+) +current +VCCs$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^VC +Auto +Creation +(?P<vc_auto_creation>\\S+)\\.$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^VC +idle +disconnect +time: +(?P<vc_idle_disconnect_time>\\d+) +seconds$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>\\S+ +CRC +errors) +: +(?P<val>\\d+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>\\S+ +SAR +Timeouts) +: +(?P<val>\\d+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>\\S+ +Oversized +SDUs) +: +(?P<val>\\d+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^LCP\\s+(?P<state>\\S+)(,\\s+loopback\\s+(?P<loopback>[\\S\\s]+))?$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Base PPPoATM +(?P<base_pppoatm>\\S+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Vaccess\\s+status\\s+(?P<status>\\S+),\\s+loopback\\s+(?P<loopback>[\\S\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^DTR +is +pulsed +for +(?P<dtr_pulsed>\\d+) +seconds +on +reset$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Name: +(?P<intf>[\\w\\/\\.\\-]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Switchport: +(?P<switchport_enable>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Administrative +Mode: +(?P<switchport_mode>[\\w\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Operational +Mode: +(?P<operational_mode>[\\w\\s]+)( +\\((?P<dummy>[\\w\\s]+)? *member +of +bundle +(?P<port_channel_int>[\\w\\/\\.\\-]+)\\))?$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Administrative +Trunking +Encapsulation: +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Operational +Trunking +Encapsulation: +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Negotiation +of +Trunking: +(?P<negotiation_of_trunk>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Access +Mode +VLAN: +(?P<access_vlan>[\\d\\-]+)",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Trunking +Native +Mode +VLAN: +(?P<native_vlan>[\\d\\-]+)",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Administrative +Native +VLAN +tagging: +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Voice +VLAN: +(?P<vlan>[\\d\\-]+)",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Administrative +private-vlan +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Administrative +private-vlan +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Administrative +private-vlan +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Administrative +private-vlan +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Administrative +private-vlan +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Administrative +private-vlan +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Administrative +private-vlan +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Administrative +private-vlan +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mappings>[\\w\\(\\)\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Operational +private-vlan:",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Trunking +VLANs +Enabled: +(?P<trunk_vlans>[\\w\\-\\,\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<private_operational>[\\w\\(\\)\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<trunk_vlans>[\\d\\,\\-]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Pruning +VLANs +Enabled: +(?P<pruning_vlans>[\\w\\-]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Capture +Mode +(?P<mode>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Capture +VLANs +Allowed: +(?P<capture_vlans>[\\w\\-]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Protected: +(?P<protected>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Unknown +unicast +blocked: +(?P<block>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Unknown +multicast +blocked: +(?P<block>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Appliance +trust: +(?P<trust>[\\w\\-]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\w\\/\\.\\-]+) +is +(?P<enabled>[\\w\\s]+), +line +protocol +is +(?P<oper_status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Internet +[A|a]ddress +is +(?P<ipv4>(?P<ip>[0-9\\.]+)\\/(?P<prefix_length>[0-9]+))$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +is +unnumbered. +Using +address +of +(\\S+) +\\((?P<ipv4>(?P<ip>[0-9\\.]+))\\)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Secondary +address +(?P<ipv4>(?P<ip>[0-9\\.]+)\\/(?P<prefix_length>[0-9]+))$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Internet +[A|a]ddress +will +be +negotiated +using +(?P<negotiated>DHCP|IPCP)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Broadcast +address +is +(?P<address>[\\w\\.\\:]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Address +determined +by +(?P<file>[\\w\\s\\-]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU +is +(?P<mtu>\\d+) +bytes$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Helper +address +is +not +set$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Helper +address +is +(?P<address>[\\d\\.]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Helper +addresses +are +(?P<address>[\\w\\.\\:\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address>[\\d\\.]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Directed +broadcast +forwarding +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Multicast +reserved +groups +joined: +(?P<multicast_groups>[\\w\\s\\.]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<multicast_groups>\\d+\\.\\d+\\.\\d+\\.\\d+)",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Outgoing +Common +access +list +is +(?P<access_list>[\\w\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Outgoing +access +list +is +(?P<access_list>[\\w\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Inbound +Common +access +list +is +(?P<access_list>[\\w\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Outgoing +access +list +is +(?P<access_list>[\\w\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Proxy +ARP +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +Proxy +ARP +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Security +level +is +(?P<level>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Split +horizon +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ICMP +redirects +are +(?P<sent>[\\w\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ICMP +unreachables +are +(?P<sent>[\\w\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ICMP +mask +replies +are +(?P<sent>[\\w\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +fast +switching +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +Flow +switching +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +CEF +switching +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +CEF +switching +turbo +vector$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +Null +turbo +vector$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^VPN +Routing\\/Forwarding +\\\"(?P<vrf>[\\w\\-]+)\\\"$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Associated +unicast +routing +topologies:$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology +\\\"(?P<topo>\\w+)\\\", +operation +state +is +(?P<topo_status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +multicast +fast +switching +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +multicast +distributed +fast +switching +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +route\\-cache +flags +are +(?P<flags>[\\w\\s\\,]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Router +Discovery +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +output +packet +accounting +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +access +violation +accounting +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^TCP\\/IP +header +compression +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^RTP\\/IP +header +compression +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Probe +proxy +name +replies +are +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Policy +routing +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Network +address +translation +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +Policy +Mapping +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Input +features: +(?P<input_feature>[\\w\\s\\,]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv4 +WCCP +Redirect +outbound +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv4 +WCCP +Redirect +inbound +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv4 +WCCP +Redirect +exclude +is +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +is +unnumbered. +Using +address +of +(?P<unnumbered_intf>[\\w\\/\\-\\.]+) +\\((?P<unnumbered_ip>[\\w\\.\\:]+)\\)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\w\\/\\.\\-]+) +is",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv6 +is +(?P<status>\\w+), +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Virtual +link\\-local +address\\(es\\)\\:$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ipv6>[\\w\\:]+)",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Stateless +address +autoconfig +enabled$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Global +unicast +address\\(es\\):$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ipv6>[\\w\\:]+), +subnet +is +(?P<dum1>(?P<dum2>[\\w\\:]+))",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^valid +lifetime +(?P<valid>\\d+) +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Joined +group +address\\(es\\):$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address>[\\w\\:]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU +is +(?P<mtu>\\d+) +bytes$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^VPN +Routing\\/Forwarding +\\\"(?P<vrf>[\\w\\-]+)\\\"$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ICMP +error +messages +limited +to +one +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ICMP +redirects +are +(?P<status>\\w+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ICMP +unreachables +are +(?P<status>[\\w\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ND +DAD +is +(?P<status>\\w+), +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ND +reachable +time +is (?P<time>\\d+) +milliseconds",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ND +NS +retransmit +interval +is",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ND +advertised +reachable +time +is +(?P<time>\\d+)",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ND +advertised +retransmit +interval +is +(?P<time>\\d+)",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ND +router +advertisements +are +sent +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ND +router +advertisements +live +for +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ND +advertised +default +router +preference +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^ND +RAs +are +suppressed.*$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Hosts +use +(?P<addr_conf_method>[\\w\\s]+) +for +addresses.$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +is +unnumbered. +Using +address +of",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^No +global +unicast +address +is +configured$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>[\\w\\-\\/\\.]+) +(?P<mode>\\w+) +(?P<encapsulation>\\S+) +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>[\\w\\-\\/\\.]+) +(?P<octets>\\d+) +(?P<ucast_pkts>\\d+) +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)Port +InOctets +InUcastPkts +InMcastPkts +InBcastPkts",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)Port +OutOctets +OutUcastPkts +OutMcastPkts +OutBcastPkts",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[a-zA-Z\\-\\d\\/\\.]+)(?P<description>( (\\S)+)*)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>Tunnel\\d+) +Pim +Register +",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<protocol>[\\w\\_\\-\\s]+)\\s+(?P<pkts_in>\\d+)\\s+",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^No +traffic +sent +or +received +on +this +interface\\.$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[\\w./]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<path>[\\w\\- ]*?) +(?P<pkts_in>[\\d]+) +(?P<chars_in>[\\d]+)",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<interface>(\\S+)) +(?P<status>(\\S+)([\\s+](\\S+))?) +(?P<protocol>(\\S+))(?: +(?P<description>(.*)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interfaces>\\S+)(?:\\s+(?P<name>([\\S\\s]+)))?\\s+(?P<status>(connected|notconnect|suspended|inactive|disabled|err-disabled|monitoring))\\s+(?P<vlan>\\S+)\\s+(?P<duplex_code>[\\S\\-]+)\\s+(?P<port_speed>[\\S\\-]+)(\\s+(?P<type>.+))?$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\S\\s]+) +is +(?P<value>[\\S\\s]+)$",
                "level": 2,
                "submatch": []
            },
            {
                "match": "(?ms)^number +of +lanes +(?P<lanes>[\\d]+)$",
                "level": 2,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show ip",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)(?P<address_type>(\\S+)) +(?P<ip_address>(\\S+))(?: +(?P<port>(\\d+)))?$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show ip_nat",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<protocol>-+|udp|tcp|icmp|any) +(?P<inside_global>\\S+) +(?P<inside_local>\\S+) +(?P<outside_local>\\S+) +(?P<outside_global>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^create(?:\\:)? +(?P<create>[\\S ]+), +use(?:\\:)? +(?P<use>[\\S ]+), +timeout(?:\\:)? +(?P<timeout>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Map\\-Id\\(In\\)[\\:|\\s]+(?P<map_id_in>\\d+)(?:[\\,|\\s]+Mac\\-Address\\: +(?P<mac_address>\\S+) +Input\\-IDB\\: +(?P<input_idb>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Mac-Address: +(?P<mac_address>\\S+) +Input-IDB: +(?P<input_idb>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^entry-id: +(?P<entry_id>\\S+), +use_count:+(?P<use_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +number +of +translations: +(?P<number_of_translations>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group_id\\:(?P<group_id>\\d+) +vrf\\: +(?P<vrf_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Format\\S+ +Time\\-left +\\:(?P<time_left>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total(?: +active)? +translations: +(?P<total_translations>\\d+) +\\((?P<static>\\d+) +static\\, +(?P<dynamic>\\d+) +dynamic\\; +(?P<extended>\\d+) +extended\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_out_interfaces>Outside|Inside) +interfaces\\:(?: +(?P<direction_interfaces>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<direction_interfaces>[\\w\\d\\/\\d\\/\\d\\,\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name_1>[\\w|\\s|\\-]+)\\: +(?P<number_1>\\w+)(?:[\\,|\\s*]+(?P<name_2>[\\w|\\s|\\-]+)(?:\\:|\\s*)? +(?P<number_2>\\S+)(?: +ago)?)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<dynamic>\\w+) +mappings\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\-\\- +(?P<source>\\S+) +Source$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?:\\[Id\\: +(?P<id>\\d+)\\] )?(?P<access_method>access\\-+list|route\\-map) +(?P<access_list>[\\w\\-]+)(?: +(?P<method>pool|interface) +(?P<pool>[\\w\\/-]+) +refcount +(?P<refcount>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^pool +(?P<pool>\\S+)\\:(?: +(id +(?P<id>\\d+))\\,)?(?:( +netmask +(?P<netmask>[\\d+\\.]+))?)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^start +(?P<start>[\\d\\.]+) +end +(?P<end>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^type +(?P<type>\\w+)\\, +total +addresses +(?P<total_addresses>\\d+)\\, +allocated +(?P<allocated>\\d+) +\\((?P<allocated_percentage>\\d+)+\\%\\)\\, +misses +(?P<misses>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^max +entry\\: +max +allowed +(?P<max_allowed>\\d+)\\, +used +(?P<used>\\d+)\\, +missed +(?P<missed>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^longest +chain +in +pool\\: +(?P<pool_name>\\S+)\\+addr\\-hash\\: +(?P<addr_hash>\\d+)\\, +average +len (?P<average_len>\\d+)\\,+chains +(?P<chains>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show ip_vrf",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<vrf>[\\S]+)\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<interfaces>[\\w\\/\\.\\-]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show ipv6",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<ip>([\\w\\:]+))\\s+(?P<age>\\S+)\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip>([\\w\\:]+))\\s+(?P<trlv>\\S)\\s+(?P<age>\\S+)\\s+",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show isis",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Tag +(?P<isis_name>\\S+)\\s*:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<system_id>\\S+)\\s+(?P<type>\\S+)\\s+(?P<interface>\\S+)\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Level +System +ID +Dynamic +Hostname +\\((?P<tag>\\w+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<level>\\d+)?(\\s?(?P<star>\\*))? +(?P<system_id>[a-zA-Z\\d\\.\\:]+) +(?P<dynamic_hostname>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tag +(?P<tag>\\w+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Level +(?P<level>\\d+) +LSP +log$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<when>[\\w\\:]+) +(?P<count>\\d+)( +(?P<interface>[a-zA-Z]+[\\d/.]+))? +(?P<triggers>[\\S\\ ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tag +(?P<tag>\\w+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS\\-IS +Level\\-(?P<level>\\d+) +Link +State +Database(:)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +Address: +(?P<area_address>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NLPID: +(?P<nlp_id>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Topology: +)?(?P<topology>(IP)+[\\w]+) +\\((?P<code>[\\w\\s]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hostname: +(?P<hostname>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +Address: +(?P<ip_address>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric: +(?P<metric>\\d+) +(?P<type>[\\w\\-]+)( +\\((?P<mt_ipv6>[\\w\\-]+)\\))? +(?P<ip>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv6 +Address: +(?P<ip_address>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router +ID: +(?P<router_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^router +isis *(?P<instance>\\S*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^vrf +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show issu",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Finished +local +lock +acquisition",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No +ISSU +operation +is +in +progress$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Slot +being +modified: +(?P<slot>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Loadversion +time: +(?P<date>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +operation:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rollback: +(?P<state>(automatic)), +remaining +time",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rollback: +(?P<state>(inactive)), +(?P<reason>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Original +\\(rollback\\) +image: +(?P<orig_image>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Running +image: +(?P<run_image>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Operating +mode: +(?P<mode>(\\S+)), +terminal +state",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Notes: +runversion +executed, +active +RP +is +being",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Slot\\s*=\\s*(?P<slot>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)RP\\s+State\\s*=\\s*(?P<state>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)ISSU\\s+State\\s*=\\s*(?P<issu_state>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Boot\\s+Variable\\s*=\\s*(?P<boot_variable>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Operating\\s+Mode\\s*=\\s*(?P<operating_mode>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Primary\\s+Version\\s*=\\s*(?P<primary_version>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Secondary\\s+Version\\s*=\\s*(?P<secondary_version>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Current\\s+Version\\s*=\\s*(?P<current_version>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Variable\\s+Store\\s*=\\s*(?P<variable_store>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Finished +local +lock +acquisition",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No ISSU operation is in progress$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Slot +being +modified: +(?P<slot>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Loadversion +time: +(?P<date>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +operation:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rollback: +(?P<state>(automatic)), +remaining +time",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rollback: +(?P<state>(inactive)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Original +\\(rollback\\) +image: +(?P<image>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Running +image: +(?P<run_image>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Operating +mode: +(?P<mode>(\\S+)), +terminal +state",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Notes: +runversion +executed, +active +RP +is +being",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rollback: +(?P<state>(\\S+)), +(?P<reason>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Rollback\\s+Process\\s+State\\s*=\\s*(?P<state>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Configured\\s+Rollback\\s+Time\\s*=\\s*(?P<rollback_time>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rollback: +(?P<state>(\\S+)), +(?P<reason>.*)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show l2vpn",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Bridge-domain +(?P<bridge_domain>\\d+) +\\((?P<number_of_ports_in_all>\\d+) +ports +in +all\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: +(?P<state>\\w+) +Mac +learning: +(?P<mac_learning_state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Aging-Timer: +(?P<aging_timer>\\d+) +second\\(s\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Load +for.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time +source.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^AED +MAC +address +Policy +Tag +Age +Pseudoport$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<num_of_ports>\\d+) +ports +belonging +to +(?P<port_belonging_group>[\\w\\-\\d]+) +group +(?P<group_number>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<member_port>[\\w\\d\\-\\/\\s\\.:]+)( +\\(.*\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<aed>[\\d-]+) +(?P<mac_address>[\\w\\d\\.]+) +(?P<policy>\\w+) +(?P<tag>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +lines +which +match +regexp += +(?P<lines_match_regexp>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Service +Instance +ID: +(?P<service_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Service +(i|I)nstance +(t|T)ype: +(?P<service_instance_type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Description: +(?P<description>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Associated +Interface: +(?P<associated_interface>[\\w\\d\\-\\.\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Associated +EVC: +(?P<associated_evc>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^L2protocol +drop$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CE-Vlans: +(?P<vlans>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Encapsulation: +(?P<encapsulation>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rewrite: +(?P<rewrite>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface Dot1q Tunnel Ethertype: +(?P<dot1q_tunnel_ethertype>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: +(?P<state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EFP Statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<pkts_in>\\d+) +(?P<bytes_in>\\d+) +(?P<pkts_out>\\d+) +(?P<bytes_out>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Intiators: +(?P<intiators>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Control +policy: +(?P<control_policy>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<service_id>\\d+) +(?P<service_instance_type>\\w+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Microblock +type: +(?P<micro_block_type>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>storm-control +\\S+ +\\S+) +(?P<val>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Load +for +\\w+ +\\w+: [\\S ]+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^L2 +ACL +\\((?P<key>\\w+)\\): +(?P<val>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^L2 +ACL +(?P<key>(permit|deny) +count): +(?P<val>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\S+ ]+): +(?P<val>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\S+ +maximum +number +of +service +instances: +(?P<max_num_of_service_instances>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Service +Instance +(?P<service_instance>\\d+), Interface +(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<pkts_in>\\d+) +(?P<bytes_in>\\d+) +(?P<pkts_out>\\d+) +(?P<bytes_out>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<broadcast_key>(default)|(\\w+ +\\d+)):(?P<broadcast_value>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^System +summary$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Associated +interface: +(?P<interface>[\\w\\d\\/\\.\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<service>[\\w\\s\\d]+) +(?P<total>\\d+) +(?P<up>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VFI +name: +(?P<vfi>[\\w\\d\\-]+), +[S|s]tate:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VPN +ID: +(?P<vpn_id>\\d+)(, +VE-ID: +(?P<ve_id>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VPN +ID: +(?P<vpn_id>\\d+), +VPLS-ID: +(?P<vpls_id>\\S+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RD: +(?P<rd>[\\d\\:]+), +RT: +(?P<rt>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge-Domain +(?P<bd_id>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Pseudo-port +[I|i]nterface: +(?P<pseudo_port_interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<pw_intf>\\S+) +(?P<pw_peer_id>[\\d\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<pw_intf>\\S+) +(?P<pw_peer_id>[\\d\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<pw_intf>\\S+) +(?P<pw_peer_id>[\\d\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[\\w]+ +name: +(?P<name>[\\w\\d\\-\\/:]+), +State: +(?P<state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<pw_intf>\\S+)( +(?P<group>\\S+))? +(?P<encapsulation>\\S+(\\s{1})?\\S+(\\s{1}\\S+)?)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show lag",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*(?P<system_priority>[\\d]+), *(?P<system_id_mac>[\\w\\.\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Channel +group: +(?P<channel_group>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[\\w\\/]+) +(?P<lacp_out_pkts>[\\d]+) +(?P<lacp_in_pkts>[\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Channel +group +(?P<channel_group>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[\\w\\/]+) +(?P<flags>[\\w]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Channel +group +(?P<channel_group>[\\d]+) +neighbors$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[\\w\\/]+) +(?P<flags>[\\w]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Channel +group: +(?P<channel_group>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[\\w\\/]+) +(?P<information_out_pkts>[\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Channel +group +(?P<channel_group>[\\d]+) +neighbors$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\w\\/\\.\\-]+) +(?P<partner_name>[\\w\\-\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Channel +group +(?P<channel_group>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[\\w\\/]+) +(?P<flags>[\\w\\s]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Number +of +channel-groups +in +use: +(?P<number_of_lag_in_use>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Number +of +aggregators: +(?P<number_of_aggregators>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<bundle_id>[\\d\\s]+)(?P<name>[\\w\\-]+)\\((?P<flags>[\\w]+)\\)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<bundle_id>[\\d\\t]+)(?P<name>[\\w\\-\\t]+)\\((?P<flags>[\\w]+)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<ports>[\\w\\-\\/\\(\\)]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Global +LB +Method: *(?P<global_lb_method>[\\w-]*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*LB +Algo +type: *(?P<lb_algo_type>[\\w\\s]*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<port_channel>[\\w-]+) +: *(?P<lb_method>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Channel +group +(?P<channel_group>[\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[\\w/]+) +(?P<system_id>[\\w,.]+) +(?P<port_num>[\\w]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<lacp_port_priority>[\\d.]+) +(?P<oper_key>[\\w]+) +(?P<port_state>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<activity>[\\w]+) +(?P<timeout>Long|Short)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<collecting>Yes|No) +(?P<distributing>[\\w]+) +(?P<defaulted>[\\w]+) +(?P<expired>[\\w]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show lisp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)Sessions +for +VRF +(?P<vrf>\\S+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<peer>\\S+) +(?P<state>\\S+) +(?P<time>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Parallel +LISP +instance +limit: +(?P<limit>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<type>(IPv4|IPv6|MAC)) RLOC,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<type>(IPv4|IPv6|MAC)) RLOC,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Latest +supported +config +style:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Current +config +style:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Output +for +router +lisp",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Home +Instance +ID *: +(?P<home_inst_id>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Total +entries *: +(?P<total_entries>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<ext_type>(Provider|Subscriber)) +(?P<inst>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Output +for +router +lisp +(?P<lisp_router_id>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)LISP +Dynamic +EID +Information +for +VRF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Dynamic-EID +name: +(?P<eid_id>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Database-mapping +EID-prefix: +(?P<dyn_eid>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Registering +more-specific +dynamic-EIDs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Map-Server\\(s\\)\\: none configured, use global Map-Server$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Map-Server\\(s\\)\\: +(?P<ms>([0-9\\.\\:]+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Site-based +multicast +Map-Notify +group\\:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Number +of +roaming +dynamic-EIDs +discovered:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Last +dynamic-EID +discovered: +(?P<last>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<eid>([0-9\\.\\:]+)), +(?P<interface>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)last +activity: +(?P<last>(\\S+)), +discovered +by:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Output +for +router +lisp +(?P<router_id>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Instance +ID *: +(?P<instance_id>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Router-lisp +ID *: +(?P<router_id>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Locator +table *: +(?P<locator_table>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)EID +table *: +(?P<eid_table>[a-zA-Z0-9\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(Ingress|Egress) +Tunnel +Router ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Proxy\\-(ITR|ETR) +Router",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)NAT-traversal +Router +\\(NAT\\-RTR\\) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Mobility +First-Hop +Router *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Map +Server +\\(MS\\) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Map +Resolver +\\(MR\\) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Delegated +Database +Tree +\\(DDT\\) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Site +Registration +Limit *: +(?P<limit>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Map-Request +source *: +(?P<source>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)ITR +Map\\-Resolver\\(s\\) *: +(?P<resolvers>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<resolver>([0-9\\.\\:]+))(?: +\\*.*)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)ETR +Map\\-Server\\(s\\) *: +(?P<servers>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<server>([0-9\\.\\:]+))(?: +\\((?P<uptime>(\\S+))\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)xTR-ID *: +(?P<xtr_id>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)site-ID *: +(?P<site_id>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)ITR +local +RLOC +\\(last +resort\\) *: +(?P<val>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)ITR +use +proxy +ETR +RLOC\\(s\\) *: +(?P<val>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)ITR +Solicit +Map +Request +\\(SMR\\) *: +(?P<val>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Max +SMRs +per +map-cache +entry *: +(?P<val>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Multiple +SMR +suppression +time *: +(?P<time>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)ETR +accept +mapping +data *: +(?P<val>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)ETR +map-cache +TTL *: +(?P<val>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Locator +Status +Algorithms *:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)RLOC\\-probe +algorithm *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)RLOC\\-probe +on +route +change *: +(?P<state>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)RLOC\\-probe +on +member +change *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)LSB +reports *: +(?P<lsb_report>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)IPv4 +RLOC +minimum +mask +length *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)IPv6 +RLOC +minimum +mask +length *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Map\\-cache:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Static +mappings +configured *: +(?P<static>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Map\\-cache +size\\/+limit *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Map\\-cache +limit *: +(?P<limit>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Imported +route +count\\/limit *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Map-cache +activity +check +period *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Map\\-cache +FIB +updates *: +(?P<fib_updates>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Persistent +map\\-cache *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Source +locator +configuration:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Vlan(?P<vlan>(\\d+))\\: +(?P<address>([0-9\\.\\:]+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Database *:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Total +database +mapping +size *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Dynamic +database +mapping +limit *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)static +database +size\\/+limit *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)dynamic +database +size\\/+limit *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)route\\-import +database +size\\/+limit *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Inactive +\\(deconfig\\/away\\) +size *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)import\\-site\\-reg +database +size\\/limit *:?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)proxy +database +size *: +(?P<size>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Encapsulation +type *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Output +for +router +lisp +(?P<router_id>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)LISP +(?P<type>(IPv4|IPv6|MAC)) +Mapping +Cache +for",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<map_id>(\\S+)), +uptime: +(?P<uptime>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Negative +cache +entry, +action: +(?P<action>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<locator>(\\S+)) +(?P<uptime>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Encapsulating\\s+to\\s+proxy\\s+ETR(\\s+Encap-IID\\s+(?P<encap_to_petr_iid>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Output +for +router +lisp +(?P<router_id>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)LISP +RLOC +Membership +for +router +lisp",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Entries: +(?P<valid>(\\d+)) +valid +\\/",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<member>([0-9\\.\\:]+)) +(?P<origin>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Output +for +router +lisp +(?P<router_id>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)LISP +SMR +Table +for +router +lisp +(\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Entries: +(?P<entries>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<prefix>([0-9\\.\\/\\:]+)) +(?P<producer>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Output +for +router +lisp +(?P<router_id>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Router-lisp +ID: +(?P<router_id>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Instance +count: +(?P<val>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<vrf>(\\S+)) +(?P<interface>(\\S+))\\.(?P<iid>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<interface>(\\S+))\\.(?P<iid>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Number +of +eid-tables: +(?P<val>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Total +number +of +database +entries:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)EID-tables +with +inconsistent +locators:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Total +number +of +map-cache +entries:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)EID-tables +with +incomplete +map-cache +entries:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)EID-tables +pending +map-cache +update +to +FIB:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Output +for +router +lisp +(?P<router_id>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)LISP +ETR +(IPv4|IPv6|MAC) +Mapping +Database +for",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Entries +total +(?P<total>(\\d+)), +no-route",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<etr_eid>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<locator>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Output +for +router +lisp +(?P<router_id>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<site_name>(\\S+)) +(?P<cfgd>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Number +of +configured +sites: +(?P<val>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Number +of +registered +sites: +(?P<val>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Number +of +configured +EID +prefixes:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Number +of +registered +EID +prefixes:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Site-registration +limit +for +router +lisp",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Site-registration +count +for +router +lisp",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Sites +with +inconsistent +registrations:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Output +for +router +lisp +(?P<router_id>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Site +name: +(?P<site_name>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Allowed +configured +locators: +(?P<val>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)EID-prefix: +(?P<eid>(\\S+)) +instance-id",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)First +registered: +(?P<first>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Last +registered: +(?P<last>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Routing +table +tag: +(?P<rtt>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Origin: +(?P<origin>(\\S+))(?:, +more +specific +of",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Origin: +(?P<origin>(\\S+))(?:,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Merge +active: +(?P<merge>(Yes|No))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Proxy +reply: +(?P<proxy>(Yes|No))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)TTL: +(?P<ttl>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)State: +(?P<state>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Authentication +failures: +(?P<auth_failures>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Allowed +locators +mismatch: +(?P<mismatch>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)ETR +(?P<etr>(\\S+)), +last +registered",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)TTL +(?P<ttl>(\\S+)),(?: +(?P<merge>(no merge)),)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)state +(?P<state>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)xTR-ID +(?P<xtr_id>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)site-ID +(?P<site_id>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)sourced +by +(?P<source>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<locator>(\\S+)) +(?P<local>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +for +router +lisp +(?P<router_id>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)LISP +(?P<stat_type>(\\S+)) +Statistics",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Control Packets:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Errors:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Map-Register +records +in\\/out: +(?P<in>(\\d+))\\/(?P<out>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Map-Notify +records +in\\/out: +(?P<in>(\\d+))\\/(?P<out>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Authentication +failures: +(?P<auth_failures>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>([a-zA-Z\\-\\/\\s]+))\\: +(?P<value>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<mr>([a-zA-Z0-9\\.\\:]+)) +(?P<last_reply>(\\S+))",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show lldp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Status: +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LLDP +(?P<pattern>[\\w\\s]+) +(?P<value>\\d+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local\\s+Intf:\\s+(?P<intf>[\\w\\/\\.\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port\\s+id:\\s+(?P<port_id>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Chassis\\s+id:\\s+(?P<chassis_id>[\\w\\.\\:\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port\\s+Description:\\s+(?P<desc>[\\w\\/\\.\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^System\\s+Name(?: +-|:)\\s+(?P<name>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^System\\s+Description:.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<msg>(Cisco +IOS +Software|Technical Support|Copyright|Cisco IP Phone).*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<msg>(Compile|Avaya|IP Phone|{).*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time\\s+remaining:\\s+(?P<time_remaining>\\w+)\\s+seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^System\\s+Capabilities:\\s+(?P<capab>[\\w\\,\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enabled\\s+Capabilities:\\s+(?P<capab>[\\w\\,\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(IP|IPV6):\\s+(?P<ip>[\\w\\.:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Management\\s+Addresses\\s+-\\s+(?P<ip>not\\sadvertised)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auto\\s+Negotiation\\s+\\-\\s+(?P<auto_negotiation>[\\w\\s\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Physical\\s+media\\s+capabilities:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<physical_media_capabilities>[\\S\\(\\s]+(HD|FD)[\\)])$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Media\\s+Attachment\\s+Unit\\s+type:\\s+(?P<unit_type>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^^Vlan\\s+ID:\\s+(?P<vlan_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total\\s+entries\\s+displayed:\\s+(?P<entry>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MED\\s+Information:.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<head>(H/W|F/W|S/W))\\s+revision:\\s+(?P<revision>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Manufacturer:\\s+(?P<manufacturer>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Model:\\s+(?P<model>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Capabilities:\\s*(?P<capabilities>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Device\\s+type:\\s+(?P<device_type>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Network\\s+Policy\\(Voice(\\s+(?P<voice_signal>Signal))?\\):\\s+VLAN\\s+(?P<vlan>\\d+),\\s+(?P<tagged>tagged),\\s+Layer-2 priority:\\s+(?P<layer_2_priority>\\d+),\\s+DSCP:\\s+(?P<dscp>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<device_type>PD device),\\s+Power\\s+source:\\s+(?P<power_source>\\S+),\\s+Power\\s+Priority:\\s+(?P<power_priority>\\S+),\\s+Wattage:\\s+(?P<wattage>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Location\\s+-\\s+(?P<location>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Serial\\s+number:\\s+(?P<serial_number>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<pattern>[\\w\\s]+): +(?P<value>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>[\\w\\/\\-\\.]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\w\\s]+): +(?P<value>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total\\s+entries\\s+displayed:\\s+(?P<entry>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<device_id>.{20})(?P<interfaces>\\S+)\\s+(?P<hold_time>\\d+)\\s+(?P<capabilities>[A-Z,]+)?\\s+(?P<port_id>\\S+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show logging",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)Syslog +logging: +(?P<enable_disable>\\S+) +\\(+(?P<messages_dropped>\\d+) +messages +dropped, +(?P<messages_rate_limited>\\d+) +messages +rate-limited, +(?P<flushes>\\d+) +flushes, +(?P<overruns>\\d+) +overruns, +xml +(?P<xml>\\S+), filtering +(?P<filtering>\\S+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<tag>\\S+) +logging: +(?P<status>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<tag>\\S+) +logging: +level +(?P<level>\\S+), +(?P<messages_logged>\\d+) +messages +logged, +xml +(?P<xml>\\S+),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)filtering +(?P<filtering>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Exception +Logging: size +\\((?P<size_bytes>\\d+) +bytes+\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Count +and +timestamp +logging +messages: +(?P<count_and_time_stamp_logging_messages>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<tag>File +logging): +(?P<status>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Persistent\\s+logging:\\s+(?P<status>\\w+)(,\\s+url\\s+(?P<url>[\\w:/]+),\\s+disk\\s+space\\s+(?P<disk_space_bytes>\\d+)\\s+bytes,\\s+file\\s+size\\s+(?P<file_size_bytes>\\d+)\\s+bytes,\\s+batch\\s+size\\s+(?P<batch_size_bytes>\\d+)\\s+bytes)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<tag>Trap) +logging: +level +(?P<level>\\S+), +(?P<message_lines_logged>\\d+) +message +lines +logged$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Logging +to (?P<logging_to>[\\d\\.]+) +\\((?P<protocol>\\S+) +port +(?P<port>\\d+), +audit +(?P<audit>\\S+),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)link +(?P<link>\\S+)\\),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<message_lines_logged>\\d+) +message +lines +logged,$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<message_lines_rate_limited>\\d+) +message +lines +rate-limited,$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<message_lines_dropped_by_md>\\d+) +message +lines +dropped-by-MD,$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)xml +(?P<xml>\\S+), +sequence +number +(?P<sequence_number>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Logging Source-Interface: +VRF +Name:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<interface>\\S+)+(?P<vrf>\\S+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Log +Buffer +\\((?P<vrf>\\d+) +bytes+\\):$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show mcast",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<address_family>[\\w\\W]+)? *[mM]ulticast",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\((?P<source_address>[\\w\\:\\.\\*\\/]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Incoming +interface:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Incoming +interface:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RPF +nbr: *(?P<rpf_nbr>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Outgoing +interface +list:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<outgoing_interface>[a-zA-Z0-9\\/\\.\\-]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Mroute: +(?P<mroute>[\\w\\:\\.\\/]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multicast +Routing: +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multicast +Multipath: +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multicast +Route +limit: +(?P<status>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multicast +Fallback +group +mode: +(?P<mode>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +multicast +boundaries +configured +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MoFRR: +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show memory",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<head>\\w+) +(?P<total>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tracekey *: +(?P<tracekey>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tracekey *: +(?P<tracekey>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<memory>[\\w\\s]*memory)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address>\\S+) +(?P<size>\\d+) +(?P<pid>\\d+) +(?P<alloc_proc>\\S+) +(?P<name>\\S+) +(?P<alloc_pc>.*)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show mld",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Global +State +Limit *: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>[\\w\\-\\.\\/]+) +is +(?P<intf_status>[\\w\\s]+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Internet +address +is +(?P<ip>[\\w\\/\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +is +(?P<status>\\w+) +on +interface$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current +MLD +version +is +(?P<ver>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +query +interval +is +(?P<query_interval>\\d+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +querier +timeout +is +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +max +query +response +time +is +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +member +query +response +interval +is ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Inbound +MLD +access +group +is *: +(?P<group_policy>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +activity: +(?P<joins>\\d+) +joins, +(?P<leaves>\\d+) +leaves$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +State +Limit *: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +querying +router +is +(?P<querier>[\\w\\.\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface: +(?P<intf>[\\w\\.\\-\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group: +(?P<group>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Host +mode: +(?P<host_mode>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Uptime: +(?P<up_time>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router +mode: +(?P<filter_mode>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +reporter: +(?P<last_reporter>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +Address +Uptime +Expires +Fwd +Flags$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<source>[\\w\\.\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group +address *: +(?P<group_address>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Database *: +(?P<database>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group +mode +ssm *: +(?P<mode>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +list *: +(?P<source_addr>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<source_addr>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show monitor",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)Session +(?P<session>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Type *: +(?P<type>([a-zA-Z\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Status *: +(?P<status>([a-zA-Z\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +Ports +:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<key>(TX Only|Both)) *: +(?P<src_val>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +Subinterfaces:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>(Both)) *: +(?P<val>([\\w\\/\\.]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +VLANs +:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>(RX Only)) *: +(?P<rx_val>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Filter +Access-Group: +(?P<filter_access_group>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Destination +Ports +: +(?P<destination_ports>([a-zA-Z0-9\\/\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Destination +IP +Address +: +(?P<destination_ip_address>([0-9\\.\\:]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Destination +ERSPAN +ID +: +(?P<destination_erspan_Id>([0-9]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Origin +IP +Address *: +(?P<origin_ip_address>([0-9\\.\\:]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +ERSPAN +ID +: +(?P<source_erspan_Id>([0-9]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +IP +Address +: +(?P<source_ip_address>([0-9\\.\\:]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +RSPAN +VLAN :+ (?P<source_rspan_vlan>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dest +RSPAN +VLAN :+ (?P<dest_rspan_vlan>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU +: +(?P<mtu>([0-9]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Status +Information +for +Capture +(?P<status_information>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Target +Type:+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface: +(?P<interface>([\\w\\s\\/]+)), +Direction *:+ (?P<direction>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Status +: +(?P<status>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<filter_details_type>([\\w\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Destination +IP: +(?P<destination_ip>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Protocol: +(?P<protocol>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Buffer +Details:+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Buffer +Type: +(?P<buffer_type>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Buffer +Size +\\(in MB\\): +(?P<buffer_size>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^File +Details:+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Associated +file +name: +(?P<file_name>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +size +of +files+\\(in MB\\): +(?P<file_size>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +files +in +ring: +(?P<file_number>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Size +of +buffer+\\(in MB\\): +(?P<size_of_buffer>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Limit +Details:+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +Packets +to +capture: +(?P<packets_number>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Packet +Capture +duration: +(?P<packets_capture_duaration>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Packet +Size +to +capture: +(?P<packets_size>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +number +of +packets +to +capture +per +second: +(?P<maximum_packets_number>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Packet +sampling +rate: +(?P<packet_sampling_rate>(\\d+))",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show mpls",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^LDP +Feature +Set +Manager: +(S|s)tate +(?P<state_initialized>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +features:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ldp_features>[\\w\\-]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Protocol version: +(?P<version>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Session +hold +time: +(?P<session_holdtime>\\d+) +sec;",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Discovery +hello: +holdtime: +(?P<holdtime>\\d+) +sec; +interval: +(?P<interval>\\d+) +sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Discovery +targeted +hello: +holdtime: +(?P<targeted_holdtime>\\d+) +sec; +interval:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Downstream +on +Demand +max +hop +count: +(?P<maxhop_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +for +targeted +sessions$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +initial\\/maximum +backoff: +(?P<initial>\\w+)/+(?P<maximum>\\w+) sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +loop +detection: +(?P<loop_detection>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +NSR: +(?P<nsr>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Label +Request +Acks:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +chkpt +msg +sent: +(?P<msg_sent>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +chkpt +msg +in +queue: +(?P<queue>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +chkpt +msg +in +state +none: +(?P<state_none>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +chkpt +msg +in +state +send: +(?P<state_send>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +chkpt +msg +in +state +wait: +(?P<state_wait>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address +Withdraw +Acks:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Session +Sync:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<session_sync_keys>^(Number)[\\S\\s]+): (?P<session_sync_values>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer +LDP +Ident: *(?P<peer_ldp>[\\d\\.]+):(?P<label_space_id>\\d+); +Local +LDP +Ident +(?P<local_ldp>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TCP +connection: *(?P<tcp_connection>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: *(?P<state>\\w+); +Msgs +sent\\/rcvd: *(?P<msg_sent>\\d+)\\/(?P<msg_rcvd>\\d+);",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Up +time: *(?P<up_time>[\\w\\:]+)(; +UID: *(?P<uid>\\d+); +Peer +Id +(?P<peer_id>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[A-Za-z]+[\\d/.]+)((,|;) +Src +IP +addr: *(?P<src_ip_address>[\\d\\.]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^holdtime: *(?P<holdtime>\\d+) +ms, +hello +interval: *(?P<hello_interval>\\d+) +ms$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Addresses +bound +to +peer +LDP +Ident:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address_bound_peer_ldp>[\\d\\.\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer +holdtime: *(?P<peer_holdtime>\\d+) +ms; +KA +interval: *(?P<ka_interval>\\d+) +ms;",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Password: +(?P<password>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NSR: +(?P<nsr>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Capabilities +Sent:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[ICCP \\(type +(?P<type>\\w+)\\) +MajVer +(?P<maj_ver>\\d+) +MinVer +(?P<min_ver>\\d+)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[Dynamic +Announcement \\((?P<dynamic_anouncement>\\w+)\\)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[mLDP +Point\\-to\\-Multipoint \\((?P<mldp_point_to_multipoint>\\w+)\\)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[mLDP +Multipoint\\-to\\-Multipoint \\((?P<mldp_multipoint_to_multipoint>\\w+)\\)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[Typed +Wildcard \\((?P<typed_wildcard>\\w+)\\)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Capabilities +Received:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[None\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRF +(?P<vrf>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^([\\w]+ +entry: +)?(?P<lib_entry>[\\d\\.\\/]+), +rev +(?P<rev>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^local +binding: +label: +(?P<local_label>\\S+)( +\\(owner +(?P<owner>\\w+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<advertised_to>[\\d\\.\\:\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^remote +binding: +lsr: +(?P<lsr>[\\d\\.]+):(?P<label_space_id>[\\d]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +Capabilities +\\- +\\[\\<description\\> +\\(\\<type\\>\\)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[ICCP \\(type +(?P<type>\\w+)\\) +MajVer +(?P<maj_ver>\\d+) +MinVer +(?P<min_ver>\\d+)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[Dynamic +Announcement \\((?P<dynamic_anouncement>\\w+)\\)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[mLDP +Point\\-to\\-Multipoint \\((?P<mldp_point_to_multipoint>\\w+)\\)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[mLDP +Multipoint\\-to\\-Multipoint \\((?P<mldp_multipoint_to_multipoint>\\w+)\\)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[Typed +Wildcard \\((?P<typed_wildcard>\\w+)\\)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(VRF +(?P<vrf>\\S+):)? *Local +LDP +Identifier:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<local_ldp_identifier>[\\d\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Discovery +Sources:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<interface>\\S+) +)?\\((?P<session>[\\w]+)\\): *(?P<xmit>xmit)?\\/?(?P<recv>recv)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enabled: +(?P<enabled>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello +interval: +(?P<hello_interval_ms>\\d+) +ms;",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ldp_tdp>\\w+) +Id:(?P<space>\\s{1,2})?(?P<ldp_tdp_id>[\\d\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Src +IP +addr: +(?P<source_ip_address>[\\d\\.]+);",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hold +time: +(?P<holdtime_sec>\\d+) +sec; +Proposed +local\\/peer:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Reachable +via +(?P<reachable_via>[\\d\\.\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Password: +(?P<password>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Clients: +(?P<clients>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<source>[\\d\\.]+) +\\-> +(?P<destination>[\\d\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Targeted +Hellos:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +(?P<configured>[\\w\\s]+); +(LDP\\-IGP +Synchronization ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Sync|SYNC) +status: +sync +(?P<sync_status>[\\w\\s]+); +peer +(?P<reachable>[\\w\\s]+).$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sync +delay +time: +(?P<delay_time>\\d+) +seconds \\((?P<left_time>\\d+) +seconds +left\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGP +holddown +time: +(?P<holddown_time>[\\w\\s]+).?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer +LDP +Ident: +(?P<peer_ldp_ident>\\S+).?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGP +enabled: +(?P<igp_enabled>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)((?P<local_label>\\d+|[Nn]one) +)?(?:\\[(?P<t>(?:T|M)+)\\] +)?(?P<outgoing_label>(\\w+|(No|Pop) +Label)) +(?P<prefix_or_tunnel_id>[\\S]+) +\\\\$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<bytes_label_switched>\\d+)( +(?P<interface>\\S+))?( +(?P<next_hop>[\\w\\.]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?:(?P<local_label>\\w+) +)?(?:\\[(?P<t>(?:T|M)+)\\] +)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<local_label>\\w+) +)?(\\[(?P<t>(T)+)\\] +)?(?P<outgoing_label>((A|a)ggregate|(No|Pop) Label|(No|Pop) tag|\\d|\\d\\/)+)?(\\[(?P<t1>(T)+)\\] +)? +(?P<prefix_or_tunnel_id>[\\w\\.\\[\\]\\-\\s]+) +(?P<bytes_label_switched>\\d+)( +(?P<interface>\\S+))?( +(?P<next_hop>[\\w\\.]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC\\/Encaps=(?P<mac>\\d+)\\/(?P<encaps>\\d+), +MRU=(?P<mru>[\\d]+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<code>[0-9A-F]+)( +(?P<lstack>\\w+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VPN +route: +(?P<vpn_route>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No +output +feature +configured$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<method>\\S+) +load\\-sharing, +slots: +(?P<slots>[\\d\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(B|b)roadcast$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRF +(?P<vrf>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>(?!Interface)[\\S]+) +(?P<ip>((Y|y)es|(N|n)o)+)( +\\((?P<session>\\w+)\\))? +(?P<tunnel>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +(?P<interface>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Type +(?P<type>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +labeling +enabled \\(+(?P<session>\\w+)\\)( +\\:)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +config$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LSP +Tunnel +labeling +((?P<lsp_tunnel_enabled>\\w+) )?enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +FRR +labeling +((?P<lp_frr_labeling>\\w+) )?enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +labeling +((?P<bgp_labeling>\\w+) )?enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MPLS +(?P<mpls_status>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU \\= +(?P<mtu>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +interface: +(?P<interface>[\\w\\d\\/\\.\\s\\-]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +interface: +(?P<interface>[\\w\\W]+) +(?P<state>\\w+), +line +protocol +(?P<line_protocol_status>\\w+), +(?P<protocol>\\w+) +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Destination +address: +(?P<address>[\\d\\.]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Preferred +path: +(?P<preferred_path>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Default +path: +(?P<default_path>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tunnel +label: +(?P<tunnel_label>\\S+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Next +hop: +(?P<next_hop>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +interface: +(?P<output_interface>\\S+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Create +time: +(?P<create_time>\\S+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Signaling +protocol: +(?P<signaling_protocol>\\S+)(,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MPLS +VC +labels: +local +(?P<mpls_local>\\w+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group +ID: +local +(?P<group_id_local>[\\w\\W]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU: +local +(?P<mtu_local>\\w+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +interface +description:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Targeted +Hello: +(?P<targeted_hello_ip>\\S+)\\([A-Z]+ +Id\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC Withdraw: +sent +(?P<sent>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sequencing: +receive +(?P<receive>\\S+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VC +statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(transit +)?packet +totals: +receive",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(transit +)?byte +totals: +receive",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(transit +)?packet +drops: +receive",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(transit +)?packet +drops: +receive +(?P<pkts_drop_receive>\\d+), +seq +error +(?P<seq_error>\\d+), +send +(?P<pkts_drop_send>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<local_intf>[\\w\\W]{0,13}) +(?P<local_circuit>",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last +label +FSM +state +change +time: +(?P<last_label_fsm_state_change_time>\\d+:\\d+:\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Graceful +restart: +(?P<graceful_restart>[\\w\\W]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Non +stop +routing: +(?P<non_stop_routing>[\\w\\W]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Status +TLV +support +\\(local\\/remote\\) +: +(?P<status_tlv_support>[\\w\\W]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*LDP +route +watch +: +(?P<ldp_route_enabled>[\\w\\W]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last +(?P<last_status_name>[\\w\\W]+) +status +(rcvd): (?P<received>[\\w\\W]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last +(?P<last_status_name>[\\w\\W]+) +status +(sent): (?P<sent>[\\w\\W]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Label\\/status +state +machine +: +(?P<label_state_machine>[\\w\\W]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show nbar",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<interface>Gig.+|Ten.+|Fast.+ |Port.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<protocol>[\\w\\-]+) +(?P<In_Packet_Count>[\\d]+) +(?P<Out_Packet_Count>[\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<In_Byte_Count>[\\d]+) +(?P<Out_Byte_Count>[\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<In_Bitrate>[\\d]+) +(?P<Out_Bitrate>[\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<In_Bitrate_Max>[\\d]+) +(?P<Out_Bitrate_Max>[\\d]+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show netconf",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Netconf +Sessions: +(?P<open>\\d+) +open, +maximum +is +(?P<maximum>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +sessions *: +(?P<session_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<session_id>\\d+) +(?P<transport>\\S+) +(?P<username>\\S+) +(?P<source_host>\\S+) +(?P<global_lock>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +sessions *: +(?P<session_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^session-id *: +(?P<session_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>\\S+) *: +(?P<data>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +sessions *: +(?P<session_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^session-id *: +(?P<session_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>\\S+) *: +(?P<data>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show ntp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<mode_code>[x\\*\\#\\+\\- ])?(?P<configured>[\\~])? *(?P<remote>[\\w\\.\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Clock +is +(?P<clock_state>\\w+)(?P<leapsecond> +\\(adding +leap +second\\))?,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Clock +is +(?P<clock_state>\\w+), +stratum +(?P<stratum>\\d+), +no +reference +clock$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^nominal +freq +is +(?P<nom_freq>[\\d\\.]+) +Hz, actual +freq +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ntp +uptime +is +(?P<uptime>[\\d\\s\\w\\/\\(\\)]+), +resolution +is +(?P<resolution>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^reference +time +is +(?P<reftime>[\\w\\s\\.\\:\\(\\)]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^clock +offset +is +(?P<offset>[\\d\\.]+) +msec, +root +delay +is +(?P<rootdelay>[\\d\\.]+) +msec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^root +dispersion +is +(?P<rootdispersion>[\\d\\.]+) +msec, +peer +dispersion +is +(?P<peerdispersion>[\\d\\.]+) +msec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^loopfilter +state +is +(?P<leap_status>[\\",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^system +poll +interval +is +(?P<poll>\\d+), +last +update +was +(?P<last_update>[\\d\\s\\w]+).*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address>[\\w\\.\\:]+) +(?P<configured>\\w+),( +(?P<ip_type>ipv4|ipv6),)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ref +ID +(?P<refid>[\\w\\.]+)( +)?, +time +(?P<input_time>[\\w\\:\\s\\(\\)\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^our +mode +(?P<mode>\\w+), +peer +mode +(?P<peer_mode>\\w+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^root +delay +(?P<root_delay_msec>[\\d\\.]+) +msec, +root +disp +(?P<root_disp>[\\d\\.]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^delay +(?P<delay_msec>[\\d\\.]+) +msec, +offset +(?P<offset_msec>[\\d\\.\\-]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^precision +(?P<precision>[\\d\\*]+), +version +(?P<version>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^assoc +(id|ID) +(?P<assoc_id>\\d+), +assoc +name +(?P<assoc_name>[\\w\\.]+),?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^assoc +in +packets +(?P<assoc_in_packets>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^org +time +(?P<org_time>[\\w\\:\\s\\(\\)\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(rec|rcv) +time +(?P<rec_time>[\\w\\:\\s\\(\\)\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^xmt +time +(?P<xmt_time>[\\w\\:\\s\\(\\)\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^filtdelay +\\= +(?P<filtdelay>[\\d\\s\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^filtoffset +\\= +(?P<filtoffset>[\\d\\s\\.\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^filterror +\\= +(?P<filterror>[\\d\\s\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^minpoll +\\= +(?P<minpoll>\\d+), +maxpoll +\\= +(?P<maxpoll>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show ospf",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^OSPF +Router +with +ID +\\((?P<router_id>(\\S+))\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +Segment +Routing +Local +Blocks +in +Area",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<value>\\*)?(?P<router_id>\\S+) +(?P<sr_capable>Yes|No)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?:^VRF +(?P<vrf>(\\S+)) +in +)?Routing +Process",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routing +Process +is +shutdown$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Domain +ID +type +(?P<domain_id>(\\S+)), +value",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Start +time: +(?P<start>([0-9\\:\\.]+)), +Time",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Supports +only +single +TOS(TOS0) routes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Supports +opaque +LSA$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Supports +Link-local +Signaling +\\(LLS\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Supports +area +transit +capability$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Supports +NSSA +\\(compatible +with +RFC +3101\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Supports +Database +Exchange +Summary +List",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Event-log +(?P<event_log>(enabled|disabled)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^It +is +an",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Redistributing +External +Routes +from,$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>(connected|static))(?: +with +metric",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<prot>(bgp|isis)) +(?P<pid>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +number +of +redistributed +prefixes",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Threshold +for +warning +message",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router +is +not +originating +router-LSAs",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Originating +router-LSAs +with +maximum",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Condition:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Advertise +stub +links +with +maximum +metric",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Advertise +summary\\-LSAs +with +metric",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^^Advertise +external\\-LSAs +with +metric",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Initial +SPF +schedule +delay +(?P<time>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Minimum +hold +time +between +two +consecutive",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +wait +time +between +two +consecutive",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Initial +LSA +throttle +delay +(?P<time>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Minimum +hold +time +for +LSA +throttle",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +wait +time +for +LSA +throttle",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Minimum +LSA +arrival",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Incremental-SPF +(?P<incr>(disabled|enabled))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)LSA +group +pacing +timer",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Interface +flood +pacing +timer",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Retransmission +pacing +timer",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)EXCHANGE/LOADING +adjacency +limit: +initial",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +external +LSA +(?P<ext>(\\d+))\\.",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +opaque +AS +LSA +(?P<opq>(\\d+))\\.",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +DCbitless +external +and +opaque",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +DoNotAge +external +and +opaque",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +areas +in +this +router +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Number +of +areas +transit +capable +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +number +of +non +self-generated +LSA",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current +number +of +non +self\\-generated +LSA +(?P<max_lsa_current>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Threshold +for +warning +message +(?P<max_lsa_threshold_value>\\d+)\\%$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Ignore\\-time +(?P<max_lsa_ignore_time>\\d+) +minutes,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Ignore\\-count +allowed +(?P<max_lsa_ignore_count>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +limit +of +redistributed +prefixes +(?P<max_lsa_limit>\\d+) +\\(warning\\-only\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^External +flood +list +length +(?P<num>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<gr_type>(IETF|Cisco)) +Non-Stop +Forwarding",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<gr_type>(IETF|Cisco)) +NSF +helper +support",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^restart-interval +limit *: +(?P<num>(\\d+)) +sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Reference +bandwidth +unit +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +(?P<area>(\\S+))(?: *\\((I|i)nactive\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^It +is +a +(?P<area_type>(\\S+)) +area",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^generates +stub +default +route +with +cost",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area ranges are$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<prefix>([0-9\\.\\/]+)) +(Passive|Active)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +interfaces +in +this +area +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +has +RRR +enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SPF +algorithm +executed +(?P<count>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SPF +algorithm +last +executed",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +has +no +authentication$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +LSA +(?P<lsa_count>(\\d+))\\.",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of opaque +link +LSA",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +DCbitless +LSA +(?P<count>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +indication +LSA +(?P<count>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +DoNotAge +LSA +(?P<count>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flood +list +length +(?P<len>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Non-Stop +Routing +(?P<nsr>(enabled))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BFD +is +enabled +in +strict +mode$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BFD +is +enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Condition:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+) +(?P<instance>\\S+) +(?P<area>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>(\\S+)) +is( +administratively)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Internet +Address +(?P<address>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Attached +via +(?P<attached>([a-zA-Z0-9\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Process +ID +(?P<pid>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured as demand circuit$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Run as demand circuit$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DoNotAge +LSA +not +allowed +\\(Number +of",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enabled +by +interface +config, +including",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Transmit +Delay is +(?P<delay>(\\d+)) +sec,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Designated +(R|r)outer +\\(ID\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Backup +(D|d)esignated +(R|r)outer +\\(ID\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timer +intervals +configured,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^oob-resync +timeout +(?P<oob>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello +due +in +(?P<hello_timer>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Supports +Link-local +Signaling +\\(LLS\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<gr_type>(Cisco|IETF)) +NSF +helper +support",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Index +(?P<index>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Next +(?P<next>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +flood +scan +length +is +(?P<num>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +flood +scan +time +is +(?P<time1>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +Count +is +(?P<nbr_count>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adjacent +with +neighbor +(?P<nbr>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adjacent +with +neighbor +(?P<nbr>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adjacent +with +neighbor +(?P<nbr>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Suppress +hello +for +(?P<sup>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Loopback +interface +is +treated +as +a +stub",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Can +be +protected +by per-+prefix +Loop-Free",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Can +be +used +for +per-prefix +Loop-Free",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Not +Protected +by +per-prefix +TI-LFA$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefix-suppression +is +(?P<ps>(enabled|disabled))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Strict +TTL +checking",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Simple +password +authentication +enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Cryptographic +authentication +enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Youngest +key +id +is +(?P<id>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rollover +in +progress, +(?P<num>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^key +id +1 +algorithm +MD5$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Segment +Routing +enabled +for +MPLS +forwarding$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TEAPP:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology +Id: *(?P<topology_id>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TEAPP: *(?P<teapp>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Affinity: *length +(?P<length>\\d+), +bits +(?P<bits>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Extended +affinity: *length +(?P<length>\\d+), +bits +(?P<bits>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SR +Policy +Manager:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TE +Opaque +LSA: +(?P<te_opaque_lsa>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mtid>(\\d+)) +(?P<topo_cost>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>(\\S+)) +is( +administratively)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Internet +Address +(?P<address>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Attached +via +(?P<attached>([a-zA-Z0-9\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Process +ID +(?P<pid>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured as demand circuit$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Run as demand circuit$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DoNotAge +LSA +not +allowed +\\(Number +of",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enabled +by +interface +config, +including",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Transmit +Delay is +(?P<delay>(\\d+)) +sec,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Designated +(R|r)outer +\\(ID\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Backup +(D|d)esignated +(R|r)outer +\\(ID\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timer +intervals +configured,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^oob-resync +timeout +(?P<oob>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello +due +in +(?P<hello_timer>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Supports +Link-local +Signaling +\\(LLS\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<gr_type>(Cisco|IETF)) +NSF +helper +support",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Index +(?P<index>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Next +(?P<next>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +flood +scan +length +is +(?P<num>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +flood +scan +time +is +(?P<time1>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +Count +is +(?P<nbr_count>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adjacent +with +neighbor +(?P<nbr>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adjacent +with +neighbor +(?P<nbr>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adjacent +with +neighbor +(?P<nbr>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Suppress +hello +for +(?P<sup>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Loopback +interface +is +treated +as +a +stub",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Can +be +protected +by per-+prefix +Loop-Free",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Can +be +used +for +per-prefix +Loop-Free",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Not +Protected +by +per-prefix +TI-LFA$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefix-suppression +is +(?P<ps>(enabled|disabled))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Strict +TTL +checking",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Simple +password +authentication +enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Cryptographic +authentication +enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Youngest +key +id +is +(?P<id>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rollover +in +progress, +(?P<num>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^key +id +1 +algorithm +MD5$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Segment +Routing +enabled +for +MPLS +forwarding$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TEAPP:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology +Id: *(?P<topology_id>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TEAPP: *(?P<teapp>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Affinity: *length +(?P<length>\\d+), +bits +(?P<bits>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Extended +affinity: *length +(?P<length>\\d+), +bits +(?P<bits>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SR +Policy +Manager:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TE +Opaque +LSA: +(?P<te_opaque_lsa>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mtid>(\\d+)) +(?P<topo_cost>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Virtual|Sham) +Link +(?P<interface>(\\S+)) +to",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +(?P<area>(\\S+)),? +source +address",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Run +as +demand +circuit$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DoNotAge +LSA +not +allowed",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Transit +area +(?P<area>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mtid>(\\d+)) +(?P<topo_cost>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Transmit +Delay +is +(?P<transmit_delay>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timer +intervals +configured,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Strict +TTL +checking",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello +due +in +(?P<hello_timer>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adjacency +State +(?P<adj_state>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Index +(?P<index>(\\S+)), +retransmission +queue",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^First +(?P<first>(\\S+)) +Next +(?P<next>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +retransmission +scan +length +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +retransmission +scan +time +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +(?P<neighbor>(\\S+)), +interface",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^In +the +area +(?P<area>(\\S+)) +via +interface",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +priority +is +(?P<priority>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DR +is +(?P<dr_ip_addr>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Options +is +(?P<options>(\\S+)) +in +Hello",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Options +is +(?P<options>(\\S+)) +in +DBD",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dead +timer +due +in +(?P<dead_timer>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +is +up +for +(?P<uptime>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Index +(?P<index>(\\S+)) +retransmission +queue",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^First +(?P<first>(\\S+)) +Next +(?P<next>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +retransmission +scan +length +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +retransmission +scan +time +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SR +adj +label +(?P<sr_adj_label>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +(?P<neighbor>(\\S+)), +interface",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^In +the +area +(?P<area>(\\S+)) +via +interface",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +priority +is +(?P<priority>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DR +is +(?P<dr_ip_addr>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Options +is +(?P<options>(\\S+)) +in +Hello",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Options +is +(?P<options>(\\S+)) +in +DBD",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dead +timer +due +in +(?P<dead_timer>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +is +up +for +(?P<uptime>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Index +(?P<index>(\\S+)) +retransmission +queue",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^First +(?P<first>(\\S+)) +Next +(?P<next>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +retransmission +scan +length +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +retransmission +scan +time +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SR +adj +label +(?P<sr_adj_label>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +Router +with +ID +\\((?P<router_id>(\\S+))\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<lsa_type>([a-zA-Z\\s]+)) +Link +States +\\(Area",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<link_id>(\\S+)) +(?P<adv_router>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +Router +with +ID +\\((?P<router_id>(\\S+))\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<lsa_type_name>(.*)) +Link +States",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routing +Bit +Set +on +this +LSA$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LS +age: +(?P<age>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Options:(?: +(?P<option>([a-zA-Z0-9]+)))?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LS +Type: +(?P<lsa_type>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +State +ID: +(?P<lsa_id>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Advertising +Router: +(?P<adv_router>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LS +Seq +Number: +(?P<ls_seq_num>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Checksum: +(?P<checksum>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Length *: +(?P<length>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Network +Mask: +\\/(?P<net_mask>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric +Type: +2 +\\(.*\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric +Type: +1 +\\(.*\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TOS:? +(?P<tos>(\\d+))(?:(\\s+|\\t+)Metric(?:s)?:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric: +(?P<metric>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Forward +Address: +(?P<addr>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^External +Route +Tag: +(?P<tag>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Attached +Router: +(?P<att_router>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +(l|L)inks *: +(?P<num>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +connected +to: +a +(?P<type>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link\\s+connected +to\\s*: +(?P<type>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(Link +ID\\) +Network\\/(s|S)ubnet +(n|N)umber:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(Link +ID\\) +(D|d)esignated +(R|r)outer",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(Link +ID\\) +(N|n)eighboring +(R|r)outer",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(Link +Data\\) +Network +Mask:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(Link +Data\\) +Router +Interface +address:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)MTID\\s*:*\\s*(?P<mtid>\\d+)\\s*(?:(Metrics*\\s*:*\\s*(?P<metric>\\d+)))?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +MTID +metrics: +(?P<num>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Opaque +Type: +(?P<type>(\\d+))(?: +\\((Traffic Engineering)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Opaque +ID: +(?P<id>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Fragment +number *: +(?P<num>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MPLS +TE +router +ID *: +(?P<mpls>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^AS +Boundary +Router$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +Border +Router$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +connected +to\\s*\\:*\\s+(?P<link>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +ID *: +(?P<id>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +Address *: +(?P<addr>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Admin +Metric *: +(?P<te_metric>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +(B|b)andwidth *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +(R|r)eservable +(B|b)andwidth",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Affinity +Bit *: +(?P<admin_group>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGP +Metric *: +(?P<igp_metric>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +Priority *: +(?P<num>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Priority +(?P<num1>(\\d+)) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unknown +Sub-TLV *: +Type += +(?P<type>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Extended +Administrative +Group *: +Length *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EAG\\[(?P<group_num>(\\d+))\\]: +(?P<val>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Neighbor\\s+Address\\s*:\\s*(?P<neighbor_address>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)TLV\\s+Type\\s*:\\s*(?P<tlv_type>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(R|r)outer\\s+(I|i)nformation",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(S|s)egment\\s+(R|r)outing\\s+(A|a)lgorithm",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(S|s)egment\\s+(R|r)outing\\s+(R|r)ange",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(S|s)egment\\s+(R|r)outing\\s+(N|n)ode\\s+MSD",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(S|s)egment\\s+(R|r)outing\\s+(L|l)ocal\\s+(B|b)lock",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(E|e)xtended\\s+(P|p)refix",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(E|e)xtended\\s+(L|l)ink",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Algo(?:(rithm))?\\s*:\\s*(?P<algorithm>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Range\\s+Size\\s*:\\s*(?P<range_size>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Flags\\s*\\:\\s*(?P<flags>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Weight\\s*:\\s*(?P<weight>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Label\\s*:\\s*(?P<label>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\(Link\\s+Data\\)\\s+Interface\\s+IP\\s+address\\s*:\\s*(?P<link_data>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Prefix\\s*:\\s*(?P<prefix>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)AF\\s*:\\s*(?P<af>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Route\\-type\\s*:\\s*(?P<route_type>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Sub\\-TLV\\s+Type\\s*:\\s*(?P<sub_tlv_type>.+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Remote\\s+Interface\\s+Address\\s*:\\s*(?P<remote_interface_address>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Local\\s+Interface\\s+ID\\s*:\\s*(?P<local_interface_id>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Remote\\s+Interface\\s+ID\\s*:\\s*(?P<remote_interface_id>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)SID\\s*:\\s*(?P<sid>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(G|g)raceful\\s+(R|r)estart\\s+(H|h)elper",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(S|s)tub\\s+(R|r)outer\\s+(S|s)upport",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)SPF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Strict\\s+SPF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Sub\\-type\\s*:\\s*Node\\s+Max\\s+Sid\\s+Depth\\,\\s+Value:\\s*(?P<value>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +TOS +metrics: +(?P<num>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>(Lo.*|.*Gig.*|.*(SL|VL).*|",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Process +ID +(?P<instance>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Holddown +timer +is (?P<val>([a-zA-Z\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +is (?P<state>(up|down))( +and +(?P<state_info>[\\w\\s]*))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP-IGP +Synchronization *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +Router +with +ID +\\((?P<router_id>(\\S+))\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +(?P<area>(\\d+)) +has +(?P<links>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +(?P<area>(\\S+)) +MPLS +TE +not +initialized$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Links +in +hash +bucket +(?P<hash>(\\d+))\\.$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +is +associated +with +fragment",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +connected +to +(?P<type>([a-zA-Z\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +ID *: +(?P<link_id>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +Address *: +(?P<addr>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Admin +Metric +te: +(?P<te>(\\d+)) +igp:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +(B|b)andwidth *: +(?P<mband>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +(R|r)eservable +(B|b)andwidth *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Affinity +Bit *: +(?P<admin_group>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +Priority +: +(?P<priority>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Priority +(?P<num1>(\\d+)) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +Router +with +ID +\\((?P<router_id>(\\S+))\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +(?P<area>(\\d+)) +has +(?P<links>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +(?P<area>(\\S+)) +MPLS +TE +not +initialized$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Links +in +hash +bucket +(?P<hash>(\\d+))\\.$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +is +associated +with +fragment",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +connected +to +(?P<type>([a-zA-Z\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +ID *: +(?P<link_id>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +Address *: +(?P<addr>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Admin +Metric +te: +(?P<te>(\\d+)) +igp:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +(B|b)andwidth *: +(?P<mband>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +(R|r)eservable +(B|b)andwidth *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Affinity +Bit *: +(?P<admin_group>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +Priority +: +(?P<priority>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Priority +(?P<num1>(\\d+)) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +Router +with +ID +\\((?P<router_id>(\\S+))\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Base +Topology +\\(MTID +(?P<mtid>(\\d+))\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Start +time: +(?P<start_time>(\\S+)), +Time +elapsed:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Originating +router-LSAs +with +maximum +metric(, +Time +remaining: +(?P<time_remaining>([\\d\\:]+)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router +is +not +originating +router-LSAs +with",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Condition: +(?P<condition>(.*)), +State:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Advertise +summary-LSAs +with +metric",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unset +reason: (?P<reason>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unset +time: +(?P<time>(\\S+)), +Time +elapsed:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +clearing +of +(?P<type>(OSPF|interface)) +traffic",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rcvd: +(?P<total>(\\d+)) total, +(?P<csum_errors>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<hello>(\\d+)) +hello, +(?P<db_desc>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<link_state_updates>(\\d+)) +link +state +updates,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sent: +(?P<total>(\\d+)) +total$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +Router +with +ID +\\((?P<router_id>(\\S+))\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +queue +statistics +for +process +ID +(?P<pid>(\\d+)):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<item>(Limit|Drops|Max delay \\[msec\\])) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<item>(Invalid|Hello|DB des|LS ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<item>(Max size|Current size)) +(?P<inputq>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +(?P<intf>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>([a-zA-Z\\s]+)) +(?P<packets>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +header +errors$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Length +(?P<len>(\\d+)), +Instance +ID",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Version +(?P<version>(\\d+)), +Bad +Source",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +Mismatch +(?P<area_mismatch>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Duplicate +ID +(?P<duplicate_id>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Nbr +Ignored +(?P<nbr_ignored>(\\d+)), +LLS\n                          ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Authentication +(?P<authentication>(\\d+)), +TTL",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Authentication +(?P<authentication>\\d+), +TTL",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BFD +(?P<bfd>(\\d+)), +Test +discard",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +LSA +errors$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Type +(?P<type>(\\d+)), +Length +(?P<len>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Summary +traffic +statistics +for +process +ID",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +Router +with +ID +\\((?P<router_id>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ospf_object>[\\S\\s]+) +(?P<ipfrr_enabled>(yes|no)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)OSPF +Router +with +ID +\\((?P<router_id>\\S+)\\) +\\(",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +with +ID \\((?P<area_id>\\d+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +Router +with +ID +\\((?P<router_id>[\\d+\\.]+)\\) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?:(?P<sid>\\d+) +)?(?:\\((?P<codes>[LNM,]+)\\) +)?(?P<prefix>[\\d\\.\\/]+)( +(?P<adv_rtr_id>[\\d\\.]+))?( +(?P<area_id>\\d+))?(?: +(?P<type>\\w+))?(?: +(?P<algo>\\d+))?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +Router +with +ID +\\((?P<router_id>[\\d+\\.]+)\\) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +Segment +Routing +Global +Blocks +in +Area (?P<area>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\*?(?P<router_id>[\\d\\.]+) +(?P<sr_capable>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +Router +with +ID +\\((?P<router_id>\\S+)\\) +\\(",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Global +segment\\-routing +state: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefer +non\\-SR +\\(LDP\\) +Labels$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Do +not +advertise +Explicit +Null$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Global +Block +\\(SRGB\\):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Range: +(?P<start>\\d+) +\\- +(?P<end>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: +(?P<state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +Block +\\(SRLB\\):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Registered +with +(?P<app_name>[\\S\\s]+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SR +algo +(?P<algo>\\d+) +(?P<notifications>[\\S\\s]+) +\\(",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Registered +with +(?P<app_name>[\\S\\s]+), +client\\-id: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Max +labels: +platform +(?P<platform>\\d+), available +(?P<available>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Max +labels +pushed +by +OSPF: +uloop +tunnels +(?P<uloop_tunnels>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^mfi +label +reservation +ack +not +pending$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bind +Retry +timer +not +running$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bind +Retry +timer +running, +left +(?P<bind_retry_timer_left>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adj +Label +Bind +Retry +timer +not +running$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adj +Label +Bind +Retry +timer +running, +left +(?P<adj_label_bind_retry_timer_left>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^sr\\-app +locks +requested: +srgb +(?P<srgb>\\d+), +srlb +(?P<srlb>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TE +Router +ID +(?P<te_router_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +Topology +name +Forwarding +Strict +SPF$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<area>(\\d+|(\\w+ +\\w+))) +(?P<topology_name>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Virtual|Sham) +Link +(?P<interface>(\\S+)) +to",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +(?P<area>(\\S+)),? +source +address",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Run +as +demand +circuit$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DoNotAge +LSA +not +allowed",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Transit +area +(?P<area>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mtid>(\\d+)) +(?P<topo_cost>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Transmit +Delay +is +(?P<transmit_delay>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timer +intervals +configured,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Strict +TTL +checking",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello +due +in +(?P<hello_timer>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adjacency +State +(?P<adj_state>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Index +(?P<index>(\\S+)), +retransmission +queue",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^First +(?P<first>(\\S+)) +Next +(?P<next>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +retransmission +scan +length +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +retransmission +scan +time +is",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show pim",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<intf>[\\w\\-\\/\\.]+) +(?P<status>(on|off))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address *: +(?P<address>[\\s\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DR *: +(?P<dr_address>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Scope +Range +List: +(?P<scope_range_list>[\\w\\:\\.//]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BSR +Address: +(?P<bsr_address>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Uptime: +(?P<up_time>[\\d\\:]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RPF: +(?P<rpf>[\\w\\:\\.]+),(?P<interface>[\\w\\d\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BS +Timer: +(?P<bs_timer>[\\d\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Candidate +BSR +address: +(?P<can_address>[\\w\\d\\:\\.]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Candidate RP: +(?P<candidate_rp_address>[\\w\\:\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*((?P<scope>[\\S\\s]+), )?Priority +(?P<priority>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Advertisement +interval +(?P<interval>\\d+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Next +advertisement +in +(?P<next_advertisement>[\\d\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<address>[\\w\\:\\.]+) +(?P<interface>[\\w\\d\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BSR +address: +(?P<address>[\\w\\:\\.]+) +\\((?P<address_host>[\\w\\d\\S]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Uptime: +(?P<up_time>[\\w\\d\\:]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Expires: +(?P<expires>[\\d\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Next +bootstrap +message +in",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Candidate +BSR +address: +(?P<can_address>[\\w\\d\\:\\.]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Candidate +RP:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Holdtime",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Advertisement +interval",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Next +advertisement +in",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Candidate +RP +priority +:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Group\\(s\\)\\:? +(?P<group>[0-9a-zA-Z\\:\\.\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Acl: +(?P<group>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RP\\:? +(?P<rp_address>[\\s\\w\\:\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Info +source: +(?P<info_source>[\\w\\:\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Uptime: +(?P<uptime>[\\w\\d\\S\\:]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<intf_name>[\\w\\d\\S]+) +is +(?P<enable>\\S+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Internet protocol processing: (?P<disabled>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Internet +address +is +(?P<address>[\\w\\d\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multicast +switching: +(?P<multi_switching>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multicast +packets +in/out:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multicast +TTL +threshold:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +version:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +DR:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +neighbor +count:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +[h|H]ello/[q|Q]uery +interval:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Hello +packets +in/out:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +J/P +interval:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +[s|S]tate-[r|R]efresh +processing:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +[s|S]tate-[r|R]efresh +origination:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +NBMA +mode:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +ATM +multipoint +signalling:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +domain +border:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +neighbors +rpf +proxy +capable:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +BFD:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Non-DR-Join:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multicast +Tagswitching:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +neighbor +filter: +(?P<nei_filter>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nei_address>[\\d\\.]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nei_address>[\\w\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<secondary_address>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<intf>[\\w\\.\\/\\-]+) +)?",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show platform",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^BOOT +variable +=( *(?P<var>\\S+);?)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Standby +BOOT +variable +=( *(?P<var>\\S+);)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Configuration +[R|r]egister +is +(?P<var1>(\\S+))(?: +\\(will +be +(?P<var2>(\\S+)) +at +next +reload\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Standby +Configuration +register +is +(?P<var>\\w+)(?: +\\(will +be +(?P<var2>\\S+) +at +next +reload\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CONFIG_FILE +variable += +(?P<var>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BOOTLDR +variable += +(?P<var>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Cc]isco +IOS +[Ss]oftware\\, +(?P<os>([\\S]+)) +Software\\, +(?P<platform>.+) Software +\\((?P<image_id>.+)\\).+[Vv]ersion +(?P<version>\\S+) +.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<os>[A-Z]+) +\\(.*\\) +(?P<platform>.+) +Software +\\((?P<image_id>.+)\\).+( +Experimental)? +[Vv]ersion +(?P<version>\\S+), +RELEASE SOFTWARE .*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ver_short>\\d+\\.\\d+).*",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Cc]isco +(?P<os>[A-Z]+) +[Ss]oftware(.+)?\\, +(?P<platform>.+) +Software +\\((?P<image_id>.+)\\).+( +Experimental)? +[Vv]ersion +(?P<version>[a-zA-Z0-9\\.\\:\\(\\)]+) *,?.*",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Copyright +(.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Technical +Support: +http\\:\\/\\/www\\.cisco\\.com\\/techsupport",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ROM\\: +(?P<rom>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bootstrap +program +is +(?P<os>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BOOTLDR\\: +(?P<bootldr>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<hostname>.+) +uptime +is +(?P<uptime>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Uu]ptime +for +this +control +processor +is +(?P<uptime_this_cp>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Ss]ystem +restarted +at +(?P<system_restarted_at>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Ss]ystem +image +file +is +\\\"(?P<system_image>.+)\\\"",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Ll]ast +reload +reason\\: +(?P<last_reload_reason>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Ll]ast +reset +from +(?P<last_reload_reason>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Ll]icense +[Tt]ype\\: +(?P<license_type>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*[Ll]icense +[Ll]evel\\: +(?P<license_level>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Nn]ext +(reload|reboot) +license +Level\\: +(?P<next_reload_license_level>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(C|c)isco +(?P<chassis>[a-zA-Z0-9\\-\\/\\+]+) +\\((?P<processor_type>[^)]*)\\) +(.*?)with +(?P<main_mem>[0-9]+)[kK](\\/[0-9]+[kK])?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(C|c)isco +(?P<chassis>[a-zA-Z0-9\\-\\/\\+]+) +.* +with +(?P<processor_type>.+) +with +(?P<main_mem>[0-9]+)[kK](\\/[0-9]+[kK])?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[pP]rocessor +board +ID +(?P<chassis_sn>[a-zA-Z0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<number_of_ports>\\d+) +(?P<interface>.+) +(interface(?:s)?|line|port(?:s)?)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mem_size>\\d+)K +bytes +of +(?P<memories>.+) +[Mm]emory\\.",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<disk_size>\\d+)K bytes of (?P<type_of_disk>.*) at (?P<disks>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Cc]isco +(?P<os>[a-zA-Z\\-]+) +[Ss]oftware\\,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Cc]onfiguration +register +is +(?P<curr_config_register>[a-zA-Z0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Cc]onfiguration +register +is +[a-zA-Z0-9]+ +\\(will be (?P<next_config_register>[a-zA-Z0-9]+) at next reload\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Ss]witch +0(?P<switch_number>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Ss]witch +[Uu]ptime +\\: +(?P<uptime>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Bb]ase +[Ee]thernet +MAC +[Aa]ddress +\\: +(?P<mac_address>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Mm]otherboard +[Aa]ssembly +[Nn]umber +\\: +(?P<mb_assembly_num>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Mm]otherboard +[Ss]erial +[Nn]umber +\\: +(?P<mb_sn>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Mm]odel +[Rr]evision +[Nn]umber +\\: +(?P<model_rev_num>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Mm]otherboard +[Rr]evision +[Nn]umber +\\: +(?P<mb_rev_num>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Mm]odel +[Nn]umber +\\: +(?P<model_num>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Ss]ystem +[Ss]erial +[Nn]umber +\\: +(?P<system_sn>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Compiled +(?P<compiled_date>[\\S\\s]+) +by +(?P<compiled_by>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^System +returned +to +ROM +by +(?P<returned_to_rom_by>[\\w\\s\\-]+)(?: +at +(?P<returned_to_rom_at>[\\w\\s\\:]+))?(?: +\\(SP +by +(?P<sp_by>[\\S\\s\\-]+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<cpu_name>\\S+) +(CPU|cpu|Cpu) +at +(?P<speed>\\S+)\\,(( +(?P<core>\\S+) +core\\, +(?P<l2_cache>\\S+) +L2 +[Cc]ache)|( +Supervisor +(?P<supervisor>\\S+)))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<processor_board_flash>\\S+) +bytes .+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Running +(?P<running_default_software>\\S+) +software$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Jawa +Revision +(?P<jawa_revision>\\S+)\\, +Snowtrooper +Revision +(?P<snowtrooper_rev>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<technology>\\w[\\w\\-]+)(?: {2,}(?P<license_level>\\w+) {2,}(?P<license_type>\\w+(?: +\\w+)?) {2,}(?P<next_boot>\\w+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<aname>Suite|Technology) +((Suite +Current)|(Technology\\-package))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Ss]uite +[Ll]icense +[Ii]nformation +for +[Mm]odule\\:\\",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^License UDI:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<device_num>[*\\d]+) +(?P<pid>[\\S]+) +(?P<sn>[A-Z\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Image text-base: +(?P<text_base>\\S+), data-base: +(?P<data_base>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\d+) +(?P<ethernet_type>Virtual Ethernet|Gigabit Ethernet|FastEthernet)/IEEE 802\\.3 +interface\\(s\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<group1>\\S+)\\s+Revision\\s+(?P<group1_int>\\d+),\\s+(?P<group2>\\S+)\\s+Revision\\s+(?P<group2_int>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Pp]ower\\s+[Ss]upply\\s+[Pp]art\\s+[Nn]umber\\s+\\:\\s+(?P<power_supply_part_nr>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Pp]ower\\s+[Ss]upply\\s+[Ss]erial\\s+[Nn]umber\\s+\\:\\s+(?P<power_supply_sn>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Dd]aughterboard\\s+[Aa]ssembly\\s+[Nn]umber\\s+\\:\\s+(?P<db_assembly_num>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Dd]aughterboard\\s+[Ss]erial\\s+[Nn]umber\\s+\\:\\s+(?P<db_sn>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Tt]op\\s+[Aa]ssembly\\s+[Pp]art\\s+[Nn]umber\\s+\\:\\s+(?P<top_assembly_part_num>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Tt]op\\s+[Aa]ssembly\\s+[Rr]evision\\s+[Nn]umber\\s+\\:\\s+(?P<top_assembly_rev_num>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Vv]ersion\\s+ID\\s+\\:\\s+(?P<version_id>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CLEI\\s+[Cc]ode\\s+[Nn]umber\\s+\\:\\s+(?P<clei_code_num>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Dd]aughterboard\\s+[Rr]evision\\s+[Nn]umber\\s+\\:\\s+(?P<db_rev_num>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Hh]ardware\\s+[Bb]oard\\s+[Rr]evision\\s+[Nn]umber\\s+\\:\\s+(?P<hb_rev_num>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<license_level>\\S+) +Type\\: +(?P<license_type>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<bytes_total>\\d+) +bytes +total +\\((?P<bytes_free>\\d+) +bytes +free\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*[Aa]vailable +[Ss]ystem +[Uu]ptime +\\= +(?P<available_system_uptime>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*[Ss]witchovers +system +experienced +\\= +(?P<switchovers_system_experienced>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*[Ss]tandby +failures +\\= +(?P<standby_failures>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*[Ll]ast +[Ss]witchover +[Rr]eason +\\= +(?P<last_switchover_reason>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*[Hh]ardware +[Mm]ode +\\= +(?P<hw_mode>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*[Cc]onfigured +[Rr]edundancy +[Mm]ode +\\= +(?P<conf_red_mode>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*[Oo]perating +[Rr]edundancy +[Mm]ode +\\= +(?P<oper_red_mode>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*[Mm]aintenance +[Mm]ode +\\= +(?P<maint_mode>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*[Cc]ommunications +\\= +(?P<communications>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*[Cc]ommunications +\\= +(?P<communications>\\S+)\\s+[Rr]eason\\: +(?P<communications_reason>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\S+ +[Ll]ocation +\\= +(?P<slot>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*[Cc]urrent +[Ss]oftware +[Ss]tate +\\= +(?P<curr_sw_state>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*[Uu]ptime +[Ii]n +[Cc]urrent +[Ss]tate +\\= +(?P<uptime_in_curr_state>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*[Ii]mage +[Vv]ersion +\\= +(?P<image_ver>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BOOT +\\= +(?P<boot>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*CONFIG_FILE +\\= +(?P<config_file>.?)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*BOOTLDR +\\= +(?P<bootldr>.?)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*[Cc]onfiguration +[Rr]egister = (?P<config_register>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^my +state += +(?P<my_state>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^peer +state += +(?P<peer_state>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Mode += +(?P<mode>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unit += +(?P<unit>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unit +ID += +(?P<unit_id>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Redundancy +Mode +\\(Operational\\) += +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Redundancy +Mode +\\(Configured\\) += +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Redundancy +State += +(?P<redundancy_state>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maintenance +Mode += +(?P<maintenance_mode>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Manual +Swact += +(?P<manual_swact>[\\w]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Communications += +(?P<communications>[\\w]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^client +count += +(?P<client_count>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^client_notification_TMR += +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RF +debug +mask += +(?P<rf_debug_mask>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NAME: +\\\"(?P<name>.*)\\\", +DESCR: +\\\"(?P<descr>.*)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Switch|[Mm]odule) +(?P<slot>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Power Supply Module",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(SPA|IM|NIM|PVDM) +subslot +(?P<slot>(\\d+))/(?P<subslot>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^subslot +(?P<slot>(\\d+))\\/(?P<subslot>(.*))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^StackPort(?P<slot>(\\d+))/(?P<subslot>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Fan +Tray$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Modem +(?P<modem>\\S+) +on +Cellular(?P<slot>\\d+)\\/(?P<subslot>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PID: +(?P<pid>[\\S\\s]+)? *, +VID:(?: +(?P<vid>(\\S+)))? *, +SN:(?: +(?P<sn>(\\S+)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Ss]witch\\/[Ss]tack +[Mm]ac +[Aa]ddress +\\: +(?P<switch_mac_address>[\\w\\.]+) *(?P<local>[\\w\\s\\-]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Mm]ac +persistency +wait +time\\: +(?P<mac_persistency_wait_time>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<switch>\\d+) +(?P<ports>\\d+) +(?P<model>[\\w\\-]+) +(?P<serial_no>\\w+) +(?P<mac_address>[\\w\\.\\:]+) +(?P<hw_ver>\\w+) +(?P<sw_ver>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\*?(?P<switch>\\d+) +(?P<role>\\w+) +(?P<priority>\\d+) +(?P<state>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Cc]hassis +type: +(?P<chassis>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<slot>\\w+)(\\/(?P<subslot>\\d+))? +(?P<name>\\S+) +(?P<state>\\w+(\\, \\w+)?) +(?P<insert_time>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<slot>\\w+) +(?P<state>\\w+(\\, \\w+)?) +(?P<insert_time>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<slot>\\w+) +(?P<cpld_version>\\d+|N\\/A) +(?P<fireware_ver>[\\w\\.\\(\\)\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Current +Boot +Variables:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Boot +Variables +on +next +reload:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BOOT +variable +=( *(?P<var>\\S+);?)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Standby +BOOT +variable +=( *(?P<var>\\S+);)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configuration +[r|R]egister +is +(?P<var>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Standby +Configuration +register",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Manual +Boot += +(?P<var>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enable +Break += +(?P<var>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Boot +Mode += +(?P<var>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^iPXE +Timeout +=? +(?P<var>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>BOOT|HELPER) +path\\-list +\\:(?: +(?P<value>[\\w\\:\\/\\-\\.]+)?)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\w\\s]+) +\\: +(?P<value>[\\w\\:\\/\\-\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)buffer +size\\: +(?P<value>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Download\\: +(?P<value>\\d+ +\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)via +DHCP\\: +(?P<value>\\w+) +\\(next +boot\\: +(?P<next_boot>\\w+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Ss]witch +(?P<switch_number>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Ss]witch\\/[Ss]tack +[Mm]ac +[Aa]ddress +\\: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Mm]ac +persistency +wait +time\\: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Switch#\\s+Role\\s+Mac\\sAddress\\s+Priority\\s+Version\\s+State$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\*?(?P<switch>\\d+) +(?P<role>\\w+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Switch#\\s+Port\\s1\\s+Port\\s2\\s+Port\\s1\\s+Port\\s2$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<switch>\\d+) +(?P<status1>\\w+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Switch +(?P<switch>\\d+) +FAN +(?P<fan>\\d+) +is +(?P<state>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Switch +(?P<switch>\\d+) +FAN +(?P<fan>\\d+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<switch>\\d+) +(?P<fan>\\d+) +\\d+ +(?P<state>.*)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FAN +PS\\-(?P<ps>\\d+) +is +(?P<state>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Switch +(?P<switch>\\d+): +SYSTEM +TEMPERATURE +is +(?P<state>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>\\w+) +Temperature +Value: +(?P<temperature>\\d+) +Degree +Celsius$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Temperature +State: +(?P<state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<color>\\w+) +Threshold *: +(?P<temperature>\\d+) +Degree +Celsius$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<sw>\\d+)(?P<ps>\\w+) *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<switch>\\d+) *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^KiB +Mem *: +(?P<total>\\d+) *total, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^KiB +Swap *: +(?P<total>\\d+) *total, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<slot>\\S+) +(?P<status>\\w+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<slot>\\S+) +(?P<status>\\w+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<slot>\\S+)? *(?P<cpu>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CPU +utilization +for +five +seconds: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<pid>\\d+) +(?P<runtime>\\d+) +(?P<invoked>\\d+) +(?P<usecs>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CPU +utilization +for +five +seconds: +(?P<cpu_util_five_secs>[\\d\\%]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<core>[\\w\\s]+): +CPU +utilization +for",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<pid>\\d+) +(?P<ppid>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +Critical +alarms: +(?P<critic_larams>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +Major +alarms: +(?P<maj_alarms>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +Minor +alarms: +(?P<min_alarms>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<slot>\\S+) +(?P<sensor_name>\\S+|\\w+\\: +\\S+(:? +\\S+)?) +(?P<state>Normal|Fan +Speed +\\S+) +(?P<reading>\\d+ +\\S+(:? +AC)?)(:? +\\S+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Package: +(?P<package_name>[\\w\\d\\s]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^File: +consolidated:(?P<file>[\\w\\d\\-\\.]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Built: +(?P<built_time>[\\w\\d\\:\\.\\_\\/\\-]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^File +SHA1 +checksum:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface: +(?P<intf_name>[\\w\\d\\/\\.\\-\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Index +(?P<index>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(PARQ +)?Software Control Info:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(cache\\) +queue +id: +(?P<cache_queue_id>[\\w\\d]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^parent_sid: +(?P<parent_sid>[\\w\\d]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^sw_flags: +(?P<sw_flags>[\\w\\d]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^orig_min +: +(?P<orig_min>\\d+) +,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^min_qos +: +(?P<min_qos>\\d+) +,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^orig_max +: +(?P<orig_max>\\d+) +,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^max_qos +: +(?P<max_qos>\\d+) +,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^share +: +(?P<share>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^plevel +: +(?P<plevel>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^defer_obj_refcnt: +(?P<defer_obj_refcnt>\\d+)(, +cp_ppe_addr: +(?P<cp_ppe_addr>\\w+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^tail +drops +\\(bytes\\): +(?P<tail_drops_bytes>\\d+) +,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^total +enqs +\\(bytes\\): +(?P<total_enqs_bytes>\\d+) +,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^queue_depth +\\((?P<type>bytes|pkts +)\\): +(?P<queue_depth>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(bytes\\): +(?P<lic_throughput_oversub_drops_bytes>\\d+) +,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +(?P<port>[\\d\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RX +(?P<direction>\\w+) +Priority$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RX +Pkts +(?P<rx_total_pkts>\\d+) +Bytes +(?P<rx_total_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RX +Drop +Pkts +(?P<rx_dropped_pkts>\\d+) +Bytes +(?P<rx_dropped_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RX +Err +Pkts +(?P<rx_errored_pkts>\\d+) +Bytes +(?P<rx_errored_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TX +(?P<direction>\\w+) +Priority$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TX +Pkts +(?P<tx_total_pkts>\\d+) +Bytes +(?P<tx_total_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TX +Drop +Pkts +(?P<tx_dropped_pkts>\\d+) +Bytes +(?P<tx_dropped_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<slot>\\d+)/(?P<subslot>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RX +IPC +Pkts +(?P<rx_ipc_pkts>\\d+) +Bytes +(?P<rx_ipc_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TX +IPC +Pkts +(?P<tx_ipc_pkts>\\d+) +Bytes +(?P<tx_ipc_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RX +IPC +Err +(?P<rx_ipc_err>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TX +IPC +Err +(?P<tx_ipc_err>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<tx_rx>\\w+) +Spi4 +Interrupt +Counters$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Out +Of +Frame +(?P<out_of_frame>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dip4 +Error +(?P<rx_dip4_error>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Disabled +(?P<rx_disbaled>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Loss +Of +Sync +(?P<rx_loss_of_sync>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sequence +Error +(?P<rx_sequence_error>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Burst +Error +(?P<rx_burst_error>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EOP +Abort +(?P<rx_eop_abort>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Packet +Gap +Error +(?P<rx_packet_gap_error>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Control +Word +Error +(?P<rx_control_word_error>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Frame +Error +(?P<tx_frame_error>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FIFO +Over +Flow +(?P<tx_fifo_over_flow>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dip2 +Error +(?P<tx_dip2_error>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<number>\\d+)(?P<drained>\\*)? +(?P<name>[\\w\\-\\s]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<unmapped_number>\\d+) +Unmapped$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<number>\\d+) +(?P<name>[\\w\\-\\s]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<unmapped_number>\\d+) +Unmapped$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^From +Slot +(?P<link>[\\w\\d\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Pkts +High: +(?P<high>\\d+) +Low: +(?P<low>\\d+)( +Bad: +(?P<bad>\\d+) +Dropped: +(?P<dropped>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bytes +High: +(?P<high>\\d+) +Low: +(?P<low>\\d+) +Bad: +(?P<bad>\\d+) +Dropped: +(?P<dropped>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Pkts +Looped: +(?P<looped>\\d+) +Error: +(?P<errored>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bytes +Looped +(?P<looped>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Qstat +count: +(?P<qstat_count>\\d+) +Flow +ctrl +count: +(?P<flow_ctrl_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<link>[\\w\\d\\-\\s/]+) +Link:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +TX +in +sync, +Local +RX +in +sync$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +TX +in +sync, +Remote +RX +in +sync$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^To +(?P<link_name_1>[\\w\\-\\d\\s/]+) +Packets: +(?P<to_packets>\\d+) +Bytes: +(?P<to_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^From +(?P<link_name_2>[\\w\\-\\d\\s/]+) +Packets: +(?P<from_packets>\\d+) +Bytes: +(?P<from_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Drops +Packets: +(?P<dropped_packets>\\d+) +Bytes: +(?P<dropped_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Errors +Packets: +(?P<errored_packets>\\d+) +Bytes: +(?P<errored_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Errors:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RX/TX +process: +(?P<rx_process>\\d+)/(?P<tx_process>\\d+), +RX/TX +schedule: +(?P<rx_schedule>\\d+)/(?P<tx_schedule>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RX/TX +statistics: +(?P<rx_statistics>\\d+)/(?P<tx_statistics>\\d+), +RX +parity: +(?P<rx_parity>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Serdes +Exception +Counts:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<link>[\\w\\d\\-\\s\\/]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^link +(?P<link_number>\\d+): +(?P<error_event>\\w+): +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Chassis +type\\: +(?P<chassis>[\\w\\-]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Power +Redundancy +Mode\\: +(?P<redundancy_mode>[\\w]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Power +Allocation +Status\\: +(?P<allocation_status>[\\w]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<slot>[\\w\\/]+) +(?P<type>[\\w-]+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<slot>[\\w\\/]+) +(?P<type>[\\w\\-]+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Total +load\\: +(?P<total_load>\\d+) +W\\, +total +capacity\\: +(?P<total_capacity>\\d+) +W\\.",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Power +capacity\\: +(?P<power_capacity>\\d+) +W$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Redundant +allocation\\: +(?P<redundant_alc>\\d+) +W$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Fan +allocation\\: +(?P<fan_alc>\\d+) +W$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*FRU +allocation\\: +(?P<fru_alc>\\d+) +W$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Excess +Power +in +Reserve\\: +(?P<excess_power>\\d+) +W$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Excess +\\/ +\\(Capacity - Redundant\\) +is +(?P<excess_capacity_percent>\\d+)\\%$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<channel>\\d+) +- +(?P<goodpkts>\\w+) +(?P<goodbytes>\\w+) +(?P<badpkts>\\w+) +(?P<badbytes>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<channel>\\d+)-?(?P<end_channel>\\d+)?: +(?P<comment>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<number>\\d+)(?P<drained>\\*)? +(?P<name>[\\w\\-\\s]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<unmapped_number>\\d+) +Unmapped$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<number>\\d+) +(?P<name>[\\w\\-\\s]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<unmapped_number>\\d+) +Unmapped$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Platform +Handle +(?P<platform_handle>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<transmit_receive>[\\w\\s]+) +Stats +Packets +Octets$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<stats>[\\w\\d]+) +(?P<packets>[\\w\\d]+) +(?P<octets>[\\w\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<global_drop_stats>\\w+) +(?P<packets>\\d+) +(?P<octets>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ *\\d+( +\\d+)* *$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ *0( +5 +0){5,6} *$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ *(?P<num>[\\d]+)(?P<line>.*#.*$)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ *CPU%.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Processor +Pool +Total: +(?P<total>\\d+) +Used: +(?P<used>\\d+) +Free: +(?P<free>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^reserve +P +Pool +Total: +(?P<total>\\d+) +Used: +(?P<used>\\d+) +Free: +(?P<free>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^lsmpi_io +Pool +Total: +(?P<total>\\d+) +Used: +(?P<used>\\d+) +Free: +(?P<free>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<pid>\\d+) +(?P<tty>\\d+) +(?P<allocated>\\d+) +(?P<freed>\\d+) +(?P<holding>\\d+) +(?P<getbufs>\\d+) +(?P<retbufs>\\d+) +(?P<process>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)The +current +tracekey +is\\s*: +(?P<tracekey>[#\\d\\w]*)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<callsite>(\\d+))\\s+(?P<thread>(\\d+))\\s+(?P<diffbyte>(\\d+))\\s+(?P<diffcall>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)backtrace: (?P<backtrace>[\\w#\\d\\s:+]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)callsite: +(?P<callsite>\\d+), +thread_id: +(?P<thread_id>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)allocs: +(?P<allocs>(\\d+)), +frees: +(?P<frees>(\\d+)), +call_diff: +(?P<call_diff>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Processor +Pool +Total: +(?P<total>\\d+) +Used: +(?P<used>\\d+) +Free: +(?P<free>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^reserve +P +Pool +Total: +(?P<total>\\d+) +Used: +(?P<used>\\d+) +Free: +(?P<free>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^lsmpi_io +Pool +Total: +(?P<total>\\d+) +Used: +(?P<used>\\d+) +Free: +(?P<free>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<pid>\\d+) +(?P<tty>\\d+) +(?P<allocated>\\d+) +(?P<freed>\\d+) +(?P<holding>\\d+) +(?P<getbufs>\\d+) +(?P<retbufs>\\d+) +(?P<process>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Platform: +(?P<platform>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Boot +(?P<boot>\\d+) +Version: +(?P<version>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Boot +(?P<boot>\\d+) +Hash: +(?P<hash>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Boot +Loader +Version: +(?P<boot_loader_version>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Boot +Loader +Hash: *(?P<hash>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<hash>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OS +Version: +(?P<os_version>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OS +Hashes:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<hash_key>\\S+): +(?P<hash_val>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<os_hash>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Signature version: +(?P<signature_version>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Signature:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<feature>\\w+) +Feature +Statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Global:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SDVT +Global +stats:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SN +Index +\\[(?P<index>[\\s\\S]+)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<sdvt_stats_type>SDVT +[\\s\\S]+ +stats):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^decaps: +(?P<decap_type>[\\s\\S]+): +(?P<value>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>Divert|Reinject) +packets\\/bytes: +(?P<packets>\\d+)\\/(?P<bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\s\\S]+): +(?P<value>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SN +Index +\\[(?P<index>[\\s\\S]+)\\], +IP: +(?P<ip>[\\s\\S]+), +oce_id: +(?P<oce_id>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^del +(?P<del>[\\s\\S]+), key +(?P<key>[\\s\\S]+), id +(?P<id>[\\s\\S]+), ver +(?P<ver>[\\s\\S]+), status +(?P<status>[\\s\\S]+), type +(?P<type>[\\s\\S]+), sng +(?P<sng>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^APPNAV STATS: +(?P<to_sn>[\\S]+) +(?P<tosn_packets>[\\d]+)\\/(?P<tosn_bytes>\\d+), +(?P<from_sn>[\\S]+) +(?P<frmsn_packets>[\\d]+)\\/(?P<frmsn_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)CAM +Utilization +for +ASIC  +\\[+(?P<asic>(\\d+))\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<table>.*(\\S+)) +(?P<subtype>\\S+) +(?P<dir>\\S+) +(?P<max>\\d+) +(?P<used>\\d+) +(?P<used_percent>\\S+\\%) +(?P<v4>\\d+) +(?P<v6>\\d+) +(?P<mpls>\\d+) +(?P<other>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CPP (?P<cpp_num>\\d)\\: +(\\d\\s\\S+) +(\\d\\s\\S+) +(\\d\\s\\S+) +(\\d+\\s\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<dir>\\w+)\\: +\\S+ \\((?P<type>\\S+)\\) +(?P<value5s>\\d+) +(?P<value1m>\\d+) +(?P<value5m>\\d+) +(?P<value60m>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\((?P<type>bps)\\) +(?P<value5s>\\d+) +(?P<value1m>\\d+) +(?P<value5m>\\d+) +(?P<value60m>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>QFP TCAM Usage Information)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<num>\\d+|Total TCAM)(?P<region>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\s\\S]+)\\:(?P<value>[\\s\\S]+\\S)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>RP|ESP)(?P<key>[0-9]) ?\\((?P<status>\\S+)\\, +(?P<role>\\S+)\\) +(?P<state>\\S)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SIP(?P<key>[0-9]) +(?P<state>\\S)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Control Processor +(?P<usage>(\\d*\\.?\\d+))\\S+ +(?P<max>\\d+)\\S+ +(?P<warning>\\d+)\\S+ +(?P<critical>\\d+)\\S+ +(?P<state>\\S)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^QFP +(?P<state>\\S)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<resource>[\\S\\s]+\\S) +(?P<usage>(\\d*\\.?\\d+))\\S+ +(?P<max>\\d+)\\S+ +(?P<warning>\\d+)\\S+ +(?P<critical>\\d+)\\S+ +(?P<state>\\S)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<resource>[\\s\\S]+\\S) +(?P<use_val>(\\d*\\.?\\d+))(?P<type>\\S+)\\((?P<val>\\d+)\\%\\) +(?P<max>\\d+)(?P<max_type>\\S+) +(?P<warning>\\d+)\\S+ +(?P<critical>\\d+)\\S+ +(?P<state>\\S)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>\\S+) *: +(?P<data>(Running|Not +Running))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<command>\\S+) +(?P<pid>\\d+) +(?P<s>\\S+) +(?P<vsz>\\d+) +(?P<rss>\\d+) +(?P<cpu>\\S+) +(?P<mem>\\S+) +(?P<elapsed>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Confd +Status: +(?P<status>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<process>\\S+) +(?P<status>(Running|Not +Running)) +(?P<state>(Active|Not +Active|Not +Applicable))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Module: +(?P<module>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)allocated: +(?P<allocated>\\d+), +requested: +(?P<requested>\\d+), +overhead: +(?P<overhead>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Allocations: +(?P<allocations>\\d+), +failed: +(?P<failed>\\d+), +frees: +(?P<frees>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<module>\\S+) +(?P<allocated>\\d+) +(?P<requested>\\d+) +(?P<allocs>\\d+) +(?P<frees>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^callsite: +(?P<callsite>\\d+), +thread_id: +(?P<thread_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^allocs: +(?P<allocs>\\d+), +frees: +(?P<frees>\\d+), +alloc_bytes: +(?P<alloc_bytes>\\d+), +free_bytes: +(?P<free_bytes>\\d+), +call_diff: +(?P<call_diff>\\d+), +byte_diff: +(?P<byte_diff>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^The +current +tracekey +is +: +(?P<tracekey>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<callsite>\\d+) +(?P<thread_id>\\d+) +(?P<diff_byte>\\d+) +(?P<diff_call>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Module: +(?P<module>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Type: +(?P<type>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Allocated: +(?P<allocated>\\d+), +Requested: +(?P<requested>\\d+), +Overhead: +(?P<overhead>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Allocations: +(?P<allocations>\\d+), +Null +Allocations: +(?P<null_allocations>\\d+), +Frees: +(?P<frees>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<type>\\S+) +(?P<allocated>\\d+) +(?P<requested>\\d+) +(?P<allocations>\\d+) +(?P<frees>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show policy_map",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<top_level>(Control Plane|Giga.*|[Pp]seudo.*|Fast.*|[Ss]erial.*|",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<top_level>([Pp]ort.*)): +Service Group +(?P<service_group>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Ss]ervice-policy +(?P<service_policy>(input|output)):+ *(?P<policy_name>([\\w\\-]+).*)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Service-policy *:+ *(?P<policy_name>([\\w\\-]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Cc]lass-map *:( +)?(?P<class_map>\\S+) +(?P<match_all>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^queue +stats +for +all +priority +classes:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<packets>(\\d+)) packets, (?P<bytes>(\\d+)) +bytes",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interval>(\\d+)) +minute +offered +rate +(?P<offered_rate>(\\d+)) bps, +drop +rate +(?P<drop_rate>(\\d+)) bps$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interval>(\\d+)) +minute(offered| )+rate +(?P<offered_rate>(\\d+)) bps$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interval>(\\d+)) +second +offered +rate +(?P<offered_rate>(\\d+)) bps, +drop +rate +(?P<drop_rate>(\\d+)) bps$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Mm]atch:( +)?(?P<match>([\\S\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^police:+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^police: +cir (?P<cir_bps>(\\d+)) bps, bc (?P<cir_bc_bytes>(\\d+)) bytes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^cir (?P<cir_bps>(\\d+)) bps, +bc +(?P<cir_bc_bytes>(\\d+)) bytes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<police_bps>(\\d+)) bps, +(?P<police_limit>(\\d+)) limit, +(?P<extended_limit>(\\d+))(.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^cir (?P<cir_bps>(\\d+)) bps, +be +(?P<cir_be_bytes>(\\d+)) bytes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^pir (?P<pir_bps>(\\d+)) bps, +be +(?P<pir_be_bytes>(\\d+)) bytes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^pir (?P<pir_bps>(\\d+)) bps, +bc +(?P<pir_bc_bytes>(\\d+)) bytes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^conformed (?P<packets>(\\d+)) packets, +(?P<bytes>(\\d+)) bytes; actions:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^conformed (?P<packets>(\\d+)) packets, +(?P<bytes>(\\d+)) bytes; action:(?P<action>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^exceeded (?P<packets>(\\d+)) packets, +(?P<bytes>(\\d+)) bytes; actions:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^exceeded (?P<packets>(\\d+)) packets, +(?P<bytes>(\\d+)) bytes; action:(?P<action>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^violated (?P<packets>(\\d+)) packets, +(?P<bytes>(\\d+)) bytes; action:(?P<action>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^violated (?P<packets>(\\d+)) packets, +(?P<bytes>(\\d+)) bytes; actions:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^conformed +(?P<c_bps>(\\d+)) bps, excee(ded|d) (?P<e_bps>(\\d+)) bps$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^conformed +(?P<c_bps>(\\d+)) bps,+ excee(d|ded) (?P<e_bps>(\\d+)) bps, violat(e|ed) (?P<v_bps>(\\d+)) bps$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?![Qr])(?P<action>[\\w\\-]+)( +(?P<value>[\\w]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^QoS +Set+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>(ip precedence|qos-group|dscp)) +(?P<value>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Marker +statistics: +(?P<marker_statistics>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Packets +marked +(?P<packets_marked>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Queueing$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^queue +size +(?P<queue_size>(\\d+)), +queue +limit +(?P<queue_limit>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^queue +limit +(?P<queue_limit>(\\d+)) packets",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^queue +limit +(?P<queue_limit_bytes>(\\d+)) bytes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(+queue +depth/+total +drops/+no-buffer +drops+\\) +(?P<queue_depth>(\\d+))/",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^depth/+total +drops/+no-buffer +drops+\\) +(?P<queue_depth>(\\d+))/+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(+pkts +output/+bytes +output+\\) +(?P<pkts_output>(\\d+))/+(?P<bytes_output>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(+pkts +matched/+bytes +matched+\\) +(?P<pkts_matched>(\\d+))/+(?P<bytes_matched>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(+pkts +queued/+bytes +queued+\\) +(?P<pkts_queued>(\\d+))/+(?P<bytes_queued>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^shape +\\(+(?P<shape_type>(\\w+))+\\) +cir +(?P<shape_cir_bps>(\\d+)), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^target +shape +rate +(?P<target_shape_rate>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +Queue: +(?P<output_queue>([\\w\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bandwidth +(?P<bandwidth>(\\d+)) .*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bandwidth (?P<bandwidth_kbps>(\\d+)) \\(?kbps\\)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bandwidth (?P<bandwidth_percent>(\\d+))\\% +\\((?P<bandwidth_kbps>(\\d+)) +kbps\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>(Exp-weight-constant|exponential.*)):+ *(?P<value>([\\w\\(\\)\\s\\/]+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(M|m)ean +queue +depth:+ *(?P<mean_queue_depth>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(class|dscp) +Transmitted +Random +drop +Tail +drop +Minimum +Maximum +Mark$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Class +Random +Tail +Minimum +Maximum +Mark +Output$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<class>(\\w+)) +(?P<value1>([\\d\\/]+)) +(?P<value2>([\\d\\/]+)) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^policy +(?P<policy>([\\w\\-]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^class +(?P<class>([\\w\\-]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bandwidth +(?P<bandwidth>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bandwidth(:| )?(?P<bandwidth>([\\s\\w\\-\\,]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bandwidth +remaining +ratio +(?P<bandwidth_remaining_ratio>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^random-detect$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^random-detect +precedence +(?P<precedence>(\\d+)) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^packet +output +(?P<packet_output>(\\d+)), +packet +drop +(?P<packet_drop>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^tail/random drop +(?P<tail_random_drops>(\\d+)), +no buffer drop +(?P<no_buffer_drops>(\\d+)), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^queue +limit +(?P<queue_limit_us>(\\d+)) +us/ +(?P<queue_limit_bytes>(\\d+)) bytes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Priority: +(?P<percent>(\\d+))% +\\((?P<kbps>(\\d+)) kbps\\), +burst bytes +(?P<burst_bytes>(\\d)+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Priority +Level: +(?P<priority_level>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bandwidth +remaining +(?P<bandwidth_remaining_percent>(\\d+))%$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Priority: +(?P<type>(\\w+)), +b/w exceed drops: +(?P<exceed_drops>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>cos)\\s+(?P<value>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Policy(\\-map| Map) +(?P<policy_map>([\\S\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Class +(?P<class_map>([\\S\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^police +(?P<cir_bps>(\\d+)) +(?P<cir_bc_bytes>(\\d+)) +(?P<cir_be_bytes>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^police +cir +percent +(?P<cir_percent>(\\d+)) +bc +(?P<bc_ms>(\\d+)) +ms +pir +percent +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^police +cir +(?P<cir_bps>(\\d+)) +bc +(?P<cir_bc_bytes>(\\d+)) +pir +(?P<pir>(\\d+)) +be +(?P<pir_be_bytes>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^police +rate +(?P<rate_pps>\\d+) +pps$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^police +rate +percent +(?P<rate_percent>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^police +cir +(?P<cir_bps>(\\d+)) +bc +(?P<cir_bc_bytes>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^police +cir +(?P<cir_bps>(\\d+)) +bc +(?P<cir_bc_bytes>(\\d+)) +be +(?P<cir_be_bytes>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^conform-action +(?P<conform_action>([\\w\\-\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^exceed-action +(?P<exceed_action>([\\w\\-\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^conform-color +(?P<conform_color>([\\w\\-\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^violate-action +(?P<violate_action>([\\w\\-\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^service-policy +(?P<service_policy>([\\w\\-\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Average +Rate +Traffic +Shaping$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Adaptive +Rate +Traffic +Shaping$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^cir +upper-bound +(?P<cir_upper_bound_bps>(\\d+)) \\(bps\\) +cir +lower-bound +(?P<cir_lower_bound_bps>(\\d+)) \\(bps\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^cir +(?P<cir>(\\d+)) *\\(?(?P<cir_unit>[\\w%]+)\\)?( +bc +(?P<bc>(\\d+)) +\\((?P<bc_unit>\\w+)\\))?( +be +(?P<be>(\\d+)) +\\((?P<be_unit>\\w+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^priority +level +(?P<pri_level>(\\d+)) +(?P<kb_per_sec>(\\d+)) \\(kb\\/s\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bandwidth +(?P<bandwidth>(\\d+))(?: \\(kb[p/]s\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[bB]andwidth(:? percent)? +(?P<bandwidth>(\\d+))(?: \\(%\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Weighted +Fair +Queueing$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^exponential +weight +(?P<exponential_weight>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^explicit +congestion +notification$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<class_val>(\\w+(\\s+\\(\\d+\\))?)) +(?P<min_threshold>([\\w\\-]+)) +(?P<max_threshold>([\\w\\-]+)) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^cir +(?P<cir_percent>(\\d+))% +bc (?P<bc_msec>(\\d+)) \\(msec\\) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^priority( +(?P<priority_kbps>\\d+) +\\(kbps\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^priority +level +(?P<priority_levels>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[sS]et +(?P<set>([\\w\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Shape +average +(?P<shape_average_min>(\\d+))m$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bandwidth +(?P<bandwidth>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^^bandwidth remaining(?: percent)? +(?P<bandwidth_remaining_percent>(\\d+))(:? \\(%\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bandwidth remaining ratio +(?P<bandwidth_remaining_ratio>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^police +cir +(?P<cir_bps>(\\d+)) +conform-burst +(?P<conform_burst>(\\d+)) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^police +percent +(?P<cir_percent>(\\d+)) +(?P<bc_ms>(\\d+)) ms +(?P<be_ms>(\\d+)) ms +conform-action +(?P<conform_action>(\\w+)) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<wred_type>[\\w-]+) +wred, +exponential +weight +(?P<exponential_weight>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^queue-limit +(?P<queue_limit_ms>(\\d+)) ms$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^queue-limit +(?P<queue_limit_packets>(\\d+)) packets$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show power",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<name>[\\w\\-]+) *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>[\\w\\-\\/\\.]+)\\s*",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<module>\\d+)\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*[Aa]vailable\\:(?P<available>[\\d\\.]+)\\(\\w+\\)\\s+",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show prefix_list",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(ipv6|ip) +prefix\\-list +(?P<name>\\S+)\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^count: +(?P<count>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^seq +(?P<seq>\\d+) +(?P<action>\\w+) +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show processes",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)System +memory: +(?P<total>(\\d+\\w?)) +total,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Lowest: (?P<lowest>(\\d+\\w?))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<pid>(\\d+))(\\s+)(?P<text>(\\d+))(\\s+)(?P<data>(\\d+))",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show protocols",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)(?P<address>[\\d\\.]+)\\s+(?P<mask>[\\d\\.]+)\\s+area\\s+(?P<area>[\\d\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 +Routing +Protocol +is +\\\"(?P<protocol>[\\w\\s]+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interfaces$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[\\w\\.\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Redistributing +protocol +(?P<redistribute>\\w+) +with( +transparent)? +metric( +(?P<metric>\\d+))?$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show rip",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*(?P<route>[\\d\\.\\/]+)( +(?P<summary_type>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<route>[\\d\\.\\/]+) +directly +connected, +(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\[(?P<metric>\\d+)\\] +via +(?P<next_hop>[\\d\\.]+),( +from +(?P<from>[\\d\\.]+),)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\[(?P<metric>\\d+)\\] +via +(?P<next_hop>[\\d\\.\\/]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RIP +(VRF|process)+ +(?P<vrf>[\\S\\s]+), +port +(?P<port>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Administrative +distance +is +(?P<distance>\\d+). +Maximum +paths +is +(?P<maximum_path>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Default +routes +are +((?P<default_routes_generated>\\w+) )?generated$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>^(?!None)[\\w\\/\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Redistributing +protocol +(?P<redistribute>\\w+) +(?P<protocol_number>\\d+) +route\\-map +(?P<route_policy>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RIP +VRF +\"(?P<vrf>[\\S\\s]+)\", +local +RIB$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<route>[\\w\\:\\/]+), +metric +(?P<metric>\\d+)(, +(?P<installed>(installed)+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>\\S+), +expires +in +(?P<expire_time>[\\d]+) +secs$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show route_map",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*route-map *(?P<name>\\S+)\\, *(?P<route_disposition>[\\w\\W]+)\\, *sequence *(?P<statements>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<clause_type>[a-zA-Z]+) +clauses:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*description +(?P<description>[a-zA-Z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*as-path *\\(as-path *filter\\): *(?P<match_as_path_list>[a-z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*as-number *\\(as-path-list *filter\\)\\: *(?P<match_as_number_list>[\\w\\W\\,\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ip *address *prefix-lists: *(?P<match_prefix_list>[a-zA-Z0-9\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ip *next-hop *(?P<match_type>[a-zA-Z0-9\\S\\(\\)]+): *(?P<match_nexthop_in>[a-zA-Z0-9\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ipv6 *address *prefix-lists: *(?P<match_prefix_list_v6>[a-zA-Z0-9\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ipv6 *next-hop *prefix-lists: *(?P<match_nexthop_in_v6>[a-zA-Z0-9\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*interface *(?P<match_interface>[a-zA-Z0-9\\/\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*metric *(?P<match_med_eq>[0-9\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*community *\\(community-list *filter\\): *(?P<match_community_list>[a-z0-9\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-type *(?P<match_level_eq>[a-z0-9\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*extcommunity *\\(extcommunity-list *filter\\): *(?P<match_ext_community_list>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ip *next-hop *(?P<set_next_hop>[0-9\\.\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ip *next-hop self$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ipv6 *next-hop *(?P<set_next_hop_v6>[a-zA-Z0-9\\:\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*tag *(?P<set_tag>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*weight *(?P<set_weight>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*metric *(?P<set_med>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*distance: *(?P<set_distance>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*metric-type *(?P<set_ospf_metric_type>[0-9a-z\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*level *(?P<set_level>[a-z0-9\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*local-preference *(?P<match_local_pref_eq>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*origin *(?P<set_route_origin>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*comm-list *(?P<set_community_delete>[a-z]+) *delete$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*community *(?P<set_community>[0-9\\:]+)(?: *(?P<set_community_no_export>(no-export)))?(?: *(?P<set_community_no_advertise>(no-advertise)))?(?: *(?P<set_community_additive>(additive)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*as-path *prepend *(?P<set_as_path_prepend>[0-9\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*extcomm-list *(?P<set_ext_community_delete>[a-z]+) *delete$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*extended community(?P<set_ext_community_rt>( RT\\:[0-9]+\\:[0-9]+)*)(\\s)?((?P<set_ext_community_rt_additive>(additive))?)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*extended *community *VD:(?P<set_ext_community_vpn>[0-9\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*extended *community *SoO:(?P<set_ext_community_soo>[0-9\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Policy\\s+routing\\s+matches:\\s+(?P<packets>\\d+)\\spackets,\\s+(?P<bytes>\\d+)\\s+bytes",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show routing",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Routing Table: +(?P<vrf>[\\w?-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<subnetted_ip>[\\d\\/\\.]+) +is +(variably )?subnetted, +(?P<number_of_subnets>[\\d]+) +subnets(, +(?P<number_of_masks>[\\d]+) +masks)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[(?P<route_preference>[\\d\\/]+)\\] +via +(?P<next_hop>[\\d\\.]+)?,?( +(?P<date>[0-9][\\w\\:]+),?)?( +(?P<interface>[\\S]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^is +directly +connected,( +\\[(?P<route_preference>[\\d\\/]+)\\] +via +(?P<next_hop>[\\d\\.]+)?,)?( +(?P<date>[0-9][\\w\\:]+),)?( +(?P<interface>[\\S]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^via( +(?P<next_hop>[\\w]+[.:][\\w\\:\\.\\%]+),?)?( +(?P<interface>[\\w\\.\\/\\-\\_]+))?,?( +receive)?( +directly connected)?( +indirectly connected)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 +Routing +Table +\\- +(?P<vrf>[\\w]+) +\\- +(?P<entries>[\\d]+) +entries$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<code>[\\w]+) +(?P<route>[\\w\\/\\:]+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*via( +(?P<next_hop>[0-9][\\w\\:\\.\\%]+),?)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*via +(?P<next_hop>[\\w\\:\\.\\%]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last +updated +(?P<last_updated>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routing +Table: +(?P<routing_table>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routing +entry +for +(?P<entry>(?P<ip>[\\w\\:\\.]+)\\/(?P<mask>\\d+))(?:, +(?P<net>[\\w\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Known +via +\\\"(?P<known_via>[\\w\\s]+)\\\", +distance +(?P<distance>\\d+), +metric +(?P<metric>\\d+),? *(?:\\S+ (?P<type>[\\w\\- ]+))?,? *.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Redistributing +via +(?P<redist_via>\\w+) *(?P<redist_via_tag>\\d+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +update +from +(?P<from>[\\w\\.]+) +(?:on +(?P<interface>[\\w\\.\\/\\-]+), )?(?P<age>[ \\w\\.\\:]+) +ago$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?:\\* +)?(?P<nexthop>[\\w\\.]+)(?:, +from +(?P<from>[\\w\\.]+)?, +(?P<age>[\\w\\.\\:]+) +ago(?:, +via +(?P<interface>\\S+))?(?:, +(?P<rib_labels>prefer-non-rib-labels))?(:?, +(?P<merge_labels>merge-labels))?)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\* +directly +connected, via +(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +metric +is +(?P<metric>\\d+), +traffic +share +count +is +(?P<share_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +count +is +(?P<route_count>[\\d\\/]+), +share +count +(?P<share_count>[\\d\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<fwd_ip>[\\w\\:]+)(, +(?P<fwd_intf>[\\w\\.\\/\\-]+)( indirectly connected)?)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^receive +via +(?P<fwd_intf>[\\w\\.\\/\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +updated +(?P<age>[\\w\\:\\.]+) +ago$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^From +(?P<from>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MPLS +label: +(?P<mpls_label>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MPLS +Flags: +(?P<mpls_flags>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SR +Incoming +Label: +(?P<sr_incoming_label>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Repair +Path: +(?P<path>[\\d\\.]+), +via +(?P<via>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tag (?P<tag_name>\\S+), +type +(?P<tag_type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^AS +Hops (?P<num_hops>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +tag (?P<route_tag>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Advertised +by +(?P<advertised_by>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<prefix>[\\w\\:\\.]+[\\/]+[\\d]+)(?:, +epoch +(?P<epoch>(\\d+)))?(?:, +(?P<sharing>(per-destination sharing)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^sr +local +label +info: +(?P<sr_local_label_info>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^nexthop +(?P<nexthop>\\S+) +(?P<interface>\\S+)( +label +(?P<outgoing_label>[\\w\\-\\ ]+)(\\((?P<outgoing_label_info>\\w+)\\))?(-\\(local:(?P<local_label>\\w+)\\))?)?( +(?P<sid>\\d+))?(-\\(local:(?P<local_sid>\\d+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^nexthop +(?P<nexthop>\\S+) +(?P<interface>\\S+) +label +\\[(?P<outgoing_label>[\\S]+)\\|(?P<outgoing_label_backup>[\\S]+)\\](?:\\((?P<outgoing_label_info>\\w+)\\))?\\-\\(local\\:(?P<local_label>(\\d+))\\)( +(?P<sid>\\d+))?(-\\(local:(?P<local_sid>\\d+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nexthop>\\w+) +(to|for) +(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nexthop>[a-z\\ ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<prefix>[\\w\\:\\.]+[\\/]+[\\d]+) +)?(?P<nexthop>[\\w\\.]+)( +(?P<interface>[^a-z][\\S]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^repair: +(?P<repair>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<prefix>\\S+)\\,\\s*epoch\\s*(?P<epoch>\\d+)\\,\\s*flags\\s*\\[(?P<flags>[\\w\\s\\,]+)\\]",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +routing +table +name +is +(?P<vrf>\\S+) +\\((?P<vrf_id>\\w+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +routing +table +maximum-paths +is +(?P<max_path>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<prefix>[\\w:.\\/d]+), +epoch +(?P<epoch>\\d+),(?: +RIB(?P<rib>\\S+),)? +refcnt +(?P<refcnt>\\d+), +(?P<sharing>\\S+) sharing$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<prefix>[\\w:./d]+), +epoch +(?P<epoch>\\d+), +flags +\\[(?P<flags>[a-zA-Z, ]+)\\],(?:(?: +intf-rcv,)? +RIB+(?P<rib>\\S+),)? +refcnt +(?P<refcnt>\\d+), +(?P<sharing>\\S+) sharing$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^sources: +(?P<sources>[a-zA-Z, ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<local_label>dflt|sr) +local +label +info: +(?P<info>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^path +list +(?P<path_list_id>[A-Z0-9]+), +(?P<locks>\\d+) +locks, +(?P<sharing>per-destination), +flags +(?P<flags>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)path +(?P<path_id>[A-Z0-9]+), share +(?P<share>\\S+), +type +(?P<type>[\\w\\s]+), +for +(?P<for>[\\w\\d\\-\\s]+)(?:, flags +(?P<flags>\\S+))?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^nexthop +(?P<nexthop>\\S+) +(?P<interface>\\S+) +label +\\[(?P<outgoing_label>[\\S]+)\\|(?P<outgoing_label_backup>[\\S]+)\\](?:\\((?P<outgoing_label_info>\\w+)\\))?\\-\\(local\\:(?P<local_label>(\\d+))\\)(?:, +(?P<ip_adj>IP adj) +out +of +(?P<interface2>\\S+), +addr +(?P<addr>\\S+) +(?P<addr_info>\\S+))?(.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^nexthop +(?P<nexthop>\\S+) +(?P<interface>\\S+)( +label +(?P<outgoing_label>[\\w\\-\\ ]+)(\\((?P<outgoing_label_info>\\w+)\\))?(-\\(local:(?P<local_label>\\w+)\\))?)?,.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FRR +Primary +\\((?P<info>\\S+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TAG +midchain +out +of +(?P<tunnel>[a-zA-Z\\d]+) +(?P<info>[A-Z\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TAG +adj +out +of +(?P<interface>\\S+), +addr +(?P<addr>\\S+)(?: +(?P<addr_info>[A-Z\\d]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^<primary: +TAG +adj +out +of +(?P<interface>\\S+), addr +(?P<addr>[\\d.]+)(?: +(?P<addr_info>[A-Z\\d]+))?>$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?:<repair: +)?TAG +adj +out +of +(?P<interface>[a-zA-Z\\d\\/]+), +addr +(?P<addr>[\\d.]+) +(?P<addr_info>[A-Z\\d]+)>$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^<repair: +TAG +midchain +out +of +(?P<interface>[a-zA-Z\\d\\/-]+) +(?P<addr_info>[A-Z\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^label +(?P<label>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)<repair: +label +(?P<label>.*)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPRM: +(?P<iprm>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Broker: +(?P<status>\\w+), +distributed +at +(?P<priority>\\d+).* +priority$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LFD: +(?P<address>\\S+) +(?P<labels>\\d+) +local +labels$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>dflt|sr) +(?P<chain_type>label +switch|disposition) +chain +(?P<id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\w\\/-]+)\\((?P<ifnum>\\d+)\\)(?:\\: +(?P<addr>[\\d.]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<counts>\\d+) +RR +source +\\[(?P<rr_source>[\\s\\S]+)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^non-eos +chain +loadinfo +(?P<non_eos_chain_loadinfo>\\S+), +(?P<per_session>per-session), +flags +(?P<flags>\\S+), +(?P<locks>\\d+) +locks$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show rpf",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^RPF +information +for +(?P<mroute>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RPF +information +for +(?P<host>[\\S]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RPF +interface: *(?P<intf>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RPF +neighbor: *(?P<neighbor>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RPF +neighbor: +(?P<host>[\\S]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RPF +route\\/mask:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RPF +type: *(?P<type>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RPF +recursion +count:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric +preference: *(?P<preference>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric: *(?P<metric>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Doing +distance\\-preferred +lookups +across +tables$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Using +Group +Based +VRF +Select, +RPF +VRF: +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RPF +topology: +(?P<lookup_topology>[\\w\\s]+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show run",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^police +cir +(?P<cir_bps>(\\d+))( +pir +(?P<pir_bps>(\\d+)))?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^policy-map +(?P<policy_map>([\\w\\-\\_]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^class +(?P<class_name>([\\w\\-\\_]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^shape +average +(?P<target_shape_rate>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^set +ip +precedence +(?P<ip_precedence>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^set +qos-group +(?P<qos_group>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bandwidth percent +(?P<bandwidth_percent>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^priority +level +(?P<priority_level>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^service-policy( +(?P<direction>(\\w+)))? +(?P<service_policy>([\\w\\-\\_]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^interface +(?P<interface>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^description +(?P<description>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(ip )?vrf +forwarding +(?P<vrf>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ip +address +(?P<ip>[\\S]+) +(?P<netmask>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ipv6 address +(?P<ipv6>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<shutdown>shutdown)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^encapsulation +dot1Q +(?P<dot1q>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^carrier-delay +(?P<carrier_delay>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<negotiation>no +)?negotiation +auto$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^cdp +(?P<cdp>enable)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<keepalive>no +)?keepalive$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^switchport +access +vlan +(?P<vlan>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^switchport +mode +(?P<switchport_mode>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^switchport +(?P<nonegotiate>nonegotiate)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ip +arp +inspection +limit +rate +(?P<rate>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^load-interval +(?P<load_interval>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^authentication +control-direction +(?P<direction>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^authentication +event +fail +action +(?P<action>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^authentication +host-mode +(?P<host_mode>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^authentication +order +(?P<order>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^authentication +priority +(?P<priority>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^authentication +port-control +(?P<port_control>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<periodic>authentication periodic)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<reauth>authentication +timer +reauthenticate +server)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^authentication +timer +inactivity +(?P<inactivity>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^authentication +violation +(?P<violation>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^authentication +fallback +(?P<fallback>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mab>mab)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^snmp +trap +mac-notification +change +added$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^snmp +trap +mac-notification +change +removed$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^no +snmp +trap +link-status$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^dot1x +pae +authenticator$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^dot1x +timeout +quiet-period +(?P<quiet_period>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^dot1x +timeout +server-timeout +(?P<server_timeout>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^dot1x +timeout +tx-period +(?P<tx_period>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^spanning-tree +portfast$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^spanning-tree +bpduguard +(?P<bpduguard>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ip +dhcp +snooping +limit +rate +(?P<rate>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ipv6 enable$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip>ip|ipv6) +ospf +(?P<ospf>\\d+) +area +(?P<area>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ospfv3 +(?P<rate>[\\d]+) +ipv6 +area +(?P<area>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^channel-group +(?P<group>[\\d]+) +mode +(?P<mode>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ipv6 enable$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip>ip|ipv6) +ospf +(?P<ospf>\\d+) +area +(?P<area>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ospfv3 +(?P<ospfv3>[\\d]+) +(?P<ip>ip|ipv6) +area +(?P<area>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^channel-group +(?P<group>[\\d]+) +mode +(?P<mode>[\\w]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show sdwan_appqoe",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Status$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\s\\S]+\\w) +: +(?P<value>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NAT Statistics$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\s\\S]+\\w) +: +(?P<value>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RM +Resources$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RM +Global +Resources +:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Registered +Service +Resources +:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TCP +Resources:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SSL +Resources:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\s\\S]+\\S) +: +(?P<value>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show sdwan_policy",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<name>[\\w\\-\\s]+) + (?P<interface_name>[\\d\\w/\\.\\-]+) + (?P<interface_direction>[\\w]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show sdwan_zbfw",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<sess_id>\\d+)\\s+(?P<state>\\w+)\\s+(?P<src_ip>\\S+)\\s+(?P<dst_ip>\\S+)\\s+(?P<src_port>\\d+)\\s+(?P<dst_port>\\d+)\\s+(?P<proto>\\S+)\\s+(?P<src_vrf>\\d+)\\s+(?P<dst_vrf>\\d+)\\s+(?P<src_vpn_id>\\d+)\\s+(?P<dst_vpn_id>\\d+)\\s+(?P<zp_name>\\S+)\\s+(?P<classmap_name>\\S+)\\s+(?P<nat_flags>\\S+)\\s+(?P<internal_flags>\\d+)\\s+(?P<tot_init_bytes>\\d+)\\s+(?P<tot_resp_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<sess_id>\\d+)\\s+(?P<state>\\w+)\\s+(?P<src_ip>\\S+)\\s+(?P<dst_ip>\\S+)\\s+(?P<src_port>\\d+)\\s+(?P<dst_port>\\d+)\\s+(?P<proto>\\S+)\\s+(?P<src_vrf>\\d+)\\s+(?P<dst_vrf>\\d+)\\s+(?P<src_vpn_id>\\d+)\\s+(?P<dst_vpn_id>\\d+)\\s+(?P<zp_name>\\S+)\\s+(?P<classmap_name>\\S+)\\s+(?P<nat_flags>\\S+)\\s+(?P<internal_flags>\\d+)\\s+(?P<tot_init_bytes>\\d+)\\s+(?P<tot_resp_bytes>\\d+)\\s+(?P<app_type>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show segment_routing",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^PREFIX_SID_CONN_MAP +(?P<algorithm>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PREFIX_SID_PROTOCOL_ADV_MAP +(?P<algorithm>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<prefix>(\\S+))\\/(?P<masklen>(\\d+)) +(?P<sid>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<prefix>(\\S+))\\/(?P<masklen>(\\d+)) +(?P<sid>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<label_min>(\\d+)) +(?P<label_max>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<label_min>\\d+) +(?P<label_max>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Segment +Routing +MPLS +State +: +(?P<state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SR +LB +\\((?P<label_min>\\d+)\\, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SR +GB +\\((?P<label_min>\\d+), +(?P<label_max>\\d+)\\) +Lock +Users +:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Node +(?P<node>\\d+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TE +router +ID: +(?P<te_router_id>\\S+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF router ID: +(?P<ospf_router_id>\\S+) +area ID: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefix +(?P<prefix>\\S+), +label +(?P<label>\\d+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link\\[(?P<link>\\d+)\\]: +local +address +(?P<local_address>\\S+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +node:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +node:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric: +(?P<metric>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<type>\\w+) +(?P<num>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bandwidth: +Total +(?P<total>\\d+), +Reservable +(?P<reservable>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Admin-groups: +(?P<admin_groups>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adj +SID: +(?P<adj_sid>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<num>\\d+) +\\((?P<state>\\S+)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Name: +(?P<name>\\S+) +\\(Color: +(?P<color>\\d+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Admin: +(?P<admin>\\S+), +Operational: +(?P<oper>\\S+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Preference +(?P<preference>\\d+)+\\s*\\w*:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dynamic( +(?P<pce>\\(pce.*\\)))? +\\((?P<status>\\w+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Weight: +(?P<weight>[\\d]+), +Metric +Type: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric +Type: +(?P<metric_type>[\\S]+), Path +Accumulated ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<sid>[\\d]+)(?: +\\[(?P<sid_type>[\\S]+), +(?P<local_address>[\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Explicit: +(?P<category>\\S+) +(?P<name>\\S+) +\\((?P<status>\\w+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Binding +SID: +(?P<binding_sid>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Allocation +mode: +(?P<allocation_mode>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: +(?P<state>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Forwarding-ID: +(?P<id>[\\d]+)(?P<extra>[\\S\\s]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Packets: +(?P<packets>[\\d]+) +Bytes: +(?P<bytes>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<timestamp>[\\d\\-]+ [\\d:.]+) +(?P<client>(?:[\\S]+ )+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Affinity:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<affinity_type>exclude-any|include-all|include-any):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<affinity>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PREFIX_SID_EXPORT_MAP +(?P<algorithm>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PREFIX_SID_REMOTE_EXPORT_MAP +(?P<algorithm>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<prefix>(\\S+))\\/(?P<masklen>(\\d+)) +(?P<sid>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<prefix>(\\S+))\\/(?P<masklen>(\\d+)) +(?P<sid>(\\d+))",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show service",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*(?P<group_number>\\d+) +(?P<state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Service +Group +global +statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Number +of +groups: +(?P<num_of_groups>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Number +of +members: +(?P<num_of_members>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Number +of +members: +(?P<num_of_members>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Members +joined: +(?P<members_joined>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Members +left: +(?P<members_left>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Service +Node +Group +name *: +(?P<name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Service +Context *: +(?P<context>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Member +Service +Node +count *: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\s\\S]+\\S) +: +(?P<value>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\s\\S]+\\w)+: +(?P<value>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show session",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^((?P<busy>\\*) +)?(?P<tty>\\d+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show snmp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<snmp>([a-zA-Z0-9]+))(?:\\.(?P<num>(\\d+)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<snmp>([a-zA-Z0-9\\-\\.]+))$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show spanning_tree",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Switch +is +in +(?P<mode>[\\w\\-]+) +mode( *\\(IEEE +Standard\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root +bridge +for: +(?P<root_bridge_for>[\\w\\-\\,\\s]+).?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\w+(?: \\S+){,5}?) +is ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\w+(?: \\S+){,5}?) +is +(?P<value>disable|disabled|enabled)(?: +but (?P<simulation_value>active|inactive) +in +rapid-pvst +mode)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<id>(?!Total)\\w+) +(?P<blocking>\\d+) +(?P<listening>\\d+) +(?P<learning>\\d+) +(?P<forwarding>\\d+) +(?P<stp_active>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<num>\\d+) +(msts?|vlans?) +(?P<blockings>\\d+) +(?P<listenings>\\d+) +(?P<learnings>\\d+) +(?P<forwardings>\\d+) +(?P<stp_actives>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?:Configured +)?Pathcost +method +used +is +(?P<method>\\w+)(?: +\\(Operational +value +is +(?P<operational_value>\\w+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Total +(?P<blockings>\\d+) +(?P<listenings>\\d+) +(?P<learnings>\\d+) +(?P<forwardings>\\d+) +(?P<stp_actives>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<root_bridge_for>(?:(?:[\\w-]+, +)+)?[\\w-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(MST|VLAN)?(?P<inst>\\w+) +is +executing +the +(?P<mode>[\\w\\-]+) +compatible +Spanning +Tree +protocol$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge +Identifier +has +priority +(?P<bridge_priority>\\d+), +sysid +(?P<bridge_sysid>\\d+), +address +(?P<bridge_address>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured +hello +time +(?P<hello_time>\\d+), +max +age +(?P<max_age>\\d+), +forward +delay +(?P<forwarding_delay>\\d+)(, +(transmit|tranmsit) +hold\\-count +(?P<hold_count>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^We +are +the +root +of +the +spanning +tree$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology +change +flag +(?P<topology_change_flag>[\\w\\s]+), +detected +flag +(?P<topology_detected_flag>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +topology +changes +(?P<topology_changes>\\d+) +last +change +occurred +(?P<time_since_topology_change>[\\w\\.\\:]+)( +ago)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^from +(?P<topology_from_port>[\\w\\.\\/\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Times: +hold +(?P<hold_time>\\d+), +topology +change +(?P<topology_change_times>\\d+), +notification +(?P<notification_times>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^hello +(?P<hello_time>\\d+), max +age +(?P<max_age>\\d+), +forward +delay +(?P<forwarding_delay>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timers: +hello +(?P<hello_timer>\\d+), +topology +change +(?P<topology_change_timer>\\d+), +notification +(?P<notification_timer>\\d+)(, +aging +(?P<aging_timer>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +(?P<port_num>\\d+) *\\((?P<name>[\\w\\/\\-\\.]+)\\) +of +(?P<inst>\\w+) +is +(?P<status>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +path +cost +(?P<cost>\\d+), +Port +priority +(?P<port_priority>\\d+), +Port +Identifier +(?P<port_identifier>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Designated +root +has +priority +(?P<designated_root_priority>\\d+), +address +(?P<designated_root_address>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Designated +bridge +has +priority +(?P<designated_bridge_priority>\\d+), +address +(?P<designated_bridge_address>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Designated +port +id +is +(?P<designated_port_id>[\\w\\.]+), +designated +path +cost +(?P<designated_path_cost>\\d+)( +[\\w\\s\\,]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timers: +message +age +(?P<message_age>\\d+), +forward +delay +(?P<forward_delay>\\d+), +hold +(?P<hold>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +transitions +to +forwarding +state: +(?P<number_of_forward_transitions>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +type +is +(?P<link_type>[\\w\\-]+) +by +default(, *(Boundary +(?P<boundary>\\w+)|Peer +is +(?P<peer>\\w+)))?(?:, +(?P<internal>Internal( +\\S+)?))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Loop +guard +is +(?P<loop_guard>\\w+) +by +default +on +the +port$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BPDU: +sent +(?P<bpdu_sent>\\d+), +received +(?P<bpdu_received>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\#+ +MST(?P<inst>\\d+) +vlans +mapped: +(?P<vlan>[\\d\\-\\,\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge +address +(?P<bridge_address>[\\w\\.]+) +priority +(?P<bridge_priority>\\d+) +\\((\\d+) +sysid +(?P<sysid>\\d+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root +this +switch +for +(the +)?(?P<root>[\\w\\.\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root +address +(?P<root_address>[\\w\\.]+) +priority +(?P<root_priority>\\d+) +\\((\\d+) +sysid +(?P<sysid>\\d+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Operational +hello +time +(?P<hello_time>\\d+), +forward +delay +(?P<forward_delay>\\d+), +max +age +(?P<max_age>\\d+), +txholdcount +(?P<tx_hold_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured +hello +time +(?P<hello_time>\\d+), +forward +delay +(?P<forward_delay>\\d+), +max +age +(?P<max_age>\\d+), +max +hops +(?P<max_hops>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>[\\w\\-\\.\\/]+) +of +MST(\\d+) +is +(?P<status>[\\w\\s]+)( +\\((?P<broken_reason>.*)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +info +port +id +(?P<port_id>[\\d\\.]+) +priority +(?P<port_priority>\\d+) +cost +(?P<cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Designated +root +address +(?P<designated_root_address>[\\w\\.]+) +priority +(?P<designated_root_priority>\\d+) +cost +(?P<designated_root_cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Design\\. +regional +root +address +(?P<designated_regional_root_address>[\\w\\.]+) +priority +(?P<designated_regional_root_priority>\\d+) +cost +(?P<designated_regional_root_cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Designated +bridge +address +(?P<designated_bridge_address>[\\w\\.]+) +priority +(?P<designated_bridge_priority>\\d+) +port +id +(?P<designated_bridge_port_id>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timers: +message +expires +in +(?P<message_expires>\\d+) +sec, +forward +delay +(?P<forward_delay>\\d+), forward +transitions +(?P<forward_transitions>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bpdus +(\\(\\w+\\) *)?sent +(?P<bpdu_sent>\\d+), +received +(?P<bpdu_received>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timer +interval: +(?P<interval>\\d+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>[\\w\\-\\s\\(\\)\\\"\\:\"]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\w\\-\\/\\.]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(MST|VLAN)(?P<inst>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Spanning +tree +enabled p+rotocol +(?P<mode>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root +ID +Priority +(?P<priority>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge +ID +Priority +(?P<priority>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address +(?P<address>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Cost +(?P<cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +(?P<port>\\d+) +\\((?P<interface>[\\w\\-\\/\\.]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Hello +Time +(?P<hello_time>\\d+) +sec +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Aging +Time +(?P<aging_time>\\d+) +sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\w\\-\\/\\.]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Name +\\[(?P<name>.*)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Revision +(?P<revision>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<inst>\\d+) +(?P<vlan_mapped>[\\d\\,\\s\\-]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show sslproxy",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Configuration$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Status$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\s\\S]+\\w) +: +(?P<value>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SSL +Proxy +Statistics$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Connection +Statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Non-proxied +Connection +Reasons:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dropped +Connection +Reasons:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Alert +Generated:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Alert +Received:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Connection +Closure +Statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<c2s_s2c_stats>[C2S|S2C]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Proxy +Server:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Proxy +Client:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ISM:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Resource +Manager:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OCSP +Statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<oscp_stats>[APP Statistics|Client Statistics]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SSL +Statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flow +Requested +SSL/TLS +version:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flow +Selected +SSL/TLS +version:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Client +Hello +Extensions:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SSL +Handshake +Statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Policy +Statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Packet +Counters:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Clear +Packets:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dropped +Packets:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<policy_stats>[Drop|Decrypt|No Decrypt]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<proxy_type>Proxy +(Server|Client))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OCSP +Stapling:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\s\\S]+\\S)(\\s+:|:) +(?P<value>[\\d]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show standby",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)\\s*HSRP +common +process",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*MsgQ +size +(?P<msgQ_size>[0-9]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*HSRP +IPv4 +process",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*HSRP +IPv6 +process",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*HSRP +Timer +wheel",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*HSRP +HA +(?P<hsrp_ha_state>[a-zA-Z\\s]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<hsrp>[0-9]+) +(?P<ip>[0-9a-zA-Z\\.\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<hsrp_number>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<interface>[a-zA-Z0-9\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<intf>[a-zA-Z0-9\\/\\.]+) +\\- +Group",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*[sS]tate +is +(?P<hsrp_router_state>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<num_state_changes>[0-9]+) +state",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<v6_type>\\S+)? *Virtual +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*[sS]econdary +virtual +IP +address +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Track +object +(?P<tracked_object>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Active +virtual +MAC +address +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Local +virtual +MAC +address +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Hello ?time +(?P<hellotime>[0-9]+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Next +hello +sent +in",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*[aA]uthentication +(?P<authentication_type>",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*MAC refresh (?P<mac_refresh>\\d+) secs ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Preemption +(?P<preempt>[a-zA-Z]+)(?:, +delay",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Active +router +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Active +router +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Standby +router +is +(?P<standby_router>",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Priority +(?P<priority>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Priority +(?P<priority>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Group +name +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Group +name +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*[fF]ollowing +\\\"(?P<follow>\\S+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)HSRP ICMP redirects disabled",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<interface>\\S+) +(?P<minimum_delay>\\d+) +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show static_routing",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*Static +local +RIB +for +(?P<vrf>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<code>[A-Z]+) +(?P<route>[\\w\\/\\.]+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 +Static +routes +Table -+ (?P<vrf>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*((?P<star>[*]+)  +)?(?P<route>[\\w\\/\\:]+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Resolves +to +(?P<no_paths>[\\d]+)? +paths",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*via +(?P<resolved_interface>[\\w\\/\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Rejected +by +(?P<rejected_by>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Tracked +object +(?P<tracked_no>\\d+) +is +(?P<interface_status>[\\w]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show system",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\*?(?P<time>[\\d\\:\\.]+) +(?P<timezone>\\w+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show tcpproxy",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Configuration$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Status$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\s\\S]+\\w) +: +(?P<value>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TCP +Proxy +Statistics$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\s\\S]+\\S)(\\s+:|:) +(?P<value>[\\d]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show telemetry",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<id>\\d+) +(?P<type>\\S+) +(?P<state>\\S+) +(?P<filter_type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Subscription +ID: +(?P<id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: +(?P<state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Stream: +(?P<stream>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Filter +type: +(?P<filter>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^XPath: +(?P<xpath>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Update +Trigger: +(?P<trigger>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Period: +(?P<period>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Synch +on +start: +(?P<sync>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dampening +period: +(?P<period>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Encoding: +(?P<encoding>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +VRF: +(?P<source>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +Address: +(?P<address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Notes: +(?P<notes>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address>\\S+) +(?P<port>\\d+) +(?P<protocol>\\S+)( +(?P<protocol_profile>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Subscription +ID: +(?P<id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address: +(?P<address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port: +(?P<port>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Protocol: +(?P<protocol>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Profile: +(?P<profile>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Connection: +(?P<connection>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: +(?P<state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Explanation: +(?P<explanation>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show tenant",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^tenant-summary +max-tenants +(?P<max_tenants>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^tenant-summary +num-active-tenants +(?P<active_tenants_num>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<tenant_name>[\\w/\\-\\.]+) +(?P<tenant_id>[0-9]+) +(?P<tenant_vpnid>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\w/\\-\\.]+) +(?P<value>[0-9\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<peer>[\\d\\.]+) +(?P<type>[0-9\\w/\\.]+) +(?P<domain_id>[\\d]+) +(?P<overlay_id>[\\d]+) +(?P<site_id>[\\d]+) +(?P<state>[\\w]+) +(?P<uptime>[\\d\\:]+) +(?P<ris>[\\d/\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<vpn>[\\d]+) +(?P<prefix>[0-9\\w/\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<vpn>[\\d]+) +(?P<prefix>[0-9\\w/\\.]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show utd",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)utd-oper-data utd-engine-status +(?P<key>[\\S]+) +(?P<value>[\\s\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<id>[\\d]+)[\\s]+(?P<running>[\\w]+)[\\s]+(?P<status>[s\\S]+\\S)(?P<reason>($|[\\s\\S]+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<key>[Engine version|Profile|Number of engines|Overall system status]+\\w)(\\s+:|:)+\\s+(?P<value>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^System +memory +:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<engine>[\\s\\S]+): +(?P<running_status>[\\w]+) +(?P<health>[\\w]+) +(?P<reason>[\\s\\S]+\\S)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Signature +update +status:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\s\\S]+\\w)(\\s+:|:)+\\s+(?P<value>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show vlan",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<vlan_id>[0-9]+)\\s+(?P<name>(?=\\S).*(?<=\\S))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<space>\\s{48})(?P<interfaces>[\\w\\s\\/\\,]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<vlan_id>[0-9]+) +(?P<type>[a-zA-Z]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<remote_span_vlans>[^--][0-9\\-\\,]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<primary>[0-9a-zA-Z]+)? +(?P<secondary>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<vlan_id>\\d+)\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VLAN\\s +SVI_MTU\\s +interface\\s +MinMTU(port)\\s +MaxMTU(port)\\s +MTU_Mismatch$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<vlan_id>[0-9]+) +(?P<vlan_mtu>[0-9\\-]+) +(?P<vlan_min_mtu>[0-9]+) +(?P<vlan_max_mtu>[0-9]+) +(?P<mtu_mismatch>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Vlan +access-map +\\\"(?P<access_map_id>[a-zA-Z0-9]+)\\\" +(?P<access_map_sequence>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<access_map_match_protocol>[a-zA-Z0-9]+) +address: +(?P<access_map_match_protocol_value>[a-zA-Z0-9\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<access_map_action_value>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Remote +SPAN +VLANs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<remote_span_vlan_ids>[0-9\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VLAN +Map +(?P<vlan_access_map_tag>[a-zA-Z0-9]+) +is +filtering +VLANs:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<access_map_vlan_ids>[0-9\\,\\-]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show vrf",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<vrf>[\\w\\d\\-\\.]+)\\s+(?P<rd>\\<not +set\\>|[\\.\\d\\:]+)\\s+(?P<protocols>[(?:ipv\\d)\\,]+)(?:\\s+(?P<intf>[\\S\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>[\\w\\.\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRF +(?P<vrf>[\\S]+)( +\\(VRF +Id +\\= +(?P<vrf_id>\\d+)\\))?; +default +RD +(?P<rd>[\\S\\s]+); +default +VPNID +(?P<vpn_id>[\\w\\s\\:\\<\\>]+)(?: +VRF +Table +ID +\\= +(?P<alt_vrf_id>\\d))?(?:(?P<being_deleted>; being deleted))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<cli_format>(New|Old)) +CLI +format, +supports +(?P<support_af>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flags: +(?P<flags>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interfaces:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>[\\w\\s\\/\\.\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address +family +(?P<af>[\\w\\s]+) +\\(Table +ID +\\= +(?P<table_id>\\w+)( *[\\w\\(\\)]+)?\\)(:|;)?(?: being deleted:)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRF +Table +ID += +(?P<table_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Export VPN route-target communities$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Import VPN route-target communities$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)RT: *(?P<rt>[\\w\\:\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No import route-map$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Import +route-map +for +(?P<af>[\\w\\s]+): +(?P<import_map>[\\w\\-]+) +\\(prefix +limit: (?P<limit>\\d+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No( *global)? export route-map$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Global +export +route-map +for +(?P<af>[\\w\\s]+): +(?P<import_map>[\\w\\-]+) +\\(prefix +limit: +(?P<limit>\\d+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route( *limit +(?P<limit>\\d+),)? +warning +limit +((?P<warning>\\d+)|(?P<percent>\\d+)\\% *\\((?P<warning_limit>[\\d\\%]+)\\)), +current +count +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRF +label +distribution +protocol: +(?P<vrf_label>[\\w\\s\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRF +label +allocation +mode: +(?P<mode>[\\w\\s\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Description: +(?P<desc>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>[\\w\\s\\/\\.\\-]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show vrrp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)State is (?P<state>(Master|UP|Init))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Virtual +IP +address is (?P<vir_ip>[\\d,\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Preemption +is (?P<state>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Preemption (?P<state>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^min +delay +is (?P<delay>[\\w,\\.]+) +sec",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Priority +is (?P<priority>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Priority (?P<priority>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRRS +Group +name (?P<vrrs_grp_name>[\\w,\\_]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Authentication +text \\\"(?P<type>[\\w,\\\"]+)\\\"",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<vrrp_grp_name>[\\w,\\W]+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show vtp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^The +VTP +password +is +not +configured.$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VTP +Password: +(?P<val>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VTP +Version +capable +: +(?P<val>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VTP +[Vv]ersion(?: +running)? *: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VTP +Domain +Name +: +(?P<val>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VTP +Pruning +Mode +: +(?P<val>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VTP +Traps +Generation +: +(?P<val>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Device +ID +: +(?P<val>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configuration +last +modified +by +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +updater +ID +is +(?P<id>[\\w\\.\\:]+) +on +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Feature +VLAN:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VTP +Operating +Mode +: (?P<val>\\S+\\s?\\S*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +VLANs +supported +locally +: +(?P<val>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +existing +VLANs +: (?P<val>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +existing +extended +VLANs +: (?P<val>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configuration +Revision +: (?P<val>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Primary +ID +: (?P<val>([0-9a-f]{4}.?){3})$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Primary +Description +: (?P<val>\\S*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MD5 +digest +: (?P<val>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<val>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Feature +MST:.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Feature +UNKNOWN:.*$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "show xconnect",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<xc>(UP|DN|AD|IA|SB|HS|RV|NH|\\-\\-))\\s+(?P<st>(pri|sec))\\s+(?P<segment1>.*)\\s+(?P<s1>(UP|DN|AD|IA|SB|HS|RV|NH|\\-\\-))\\s+(?P<segment2>.*)\\s+(?P<s2>(UP|DN|AD|IA|SB|HS|RV|NH|\\-\\-))",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxe",
        "command": "traceroute",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^traceroute( +vrf +(?P<vrf>\\S+))? +[\\S ]+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tracing +the +route +to +(?P<traceroute>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tracing +MPLS +Label +Switched +Path +to +(?P<traceroute>\\S+), +timeout +is +(?P<timeout>(\\d+)) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tracing +the +route +to +(?P<name_of_address>\\S+) \\(+(?P<traceroute>\\S+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<hop>(\\d+)) +)?(?P<address>([a-zA-Z0-9\\.\\:]+)) +\\((?P<vrf_in_name>(\\S+))\\/(?P<vrf_in_id>(\\d+)), +(?P<vrf_out_name>(\\S+))\\/(?P<vrf_out_id>(\\d+))\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<code>(!|Q|.|L|D|M|P|R|I|X)) +(?P<hop>(\\d+)) +(?P<address>([a-zA-Z0-9\\.\\:]+))(?: +MRU +(?P<mru>(\\d+)))?(?: +\\[Labels: +(?P<label_name>(\\S+)) +Exp: +(?P<exp>(\\d+))\\])? +(?P<probe_msec>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<hop>(\\d+)) +)?(?P<address>([a-zA-Z0-9\\.\\:]+)) +MRU +(?P<mru>(\\d+)) +\\[Labels: +(?P<label_name>(\\S+)) +Exp: +(?P<exp>(\\d+))\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<hop>(\\d+)) +)?(?P<address>([a-zA-Z0-9\\.\\:]+))(?: +\\[(?P<label_name>(MPLS)): +Labels? (?P<label>(\\S+)) +Exp +(?P<exp>(\\d+))\\])? +(?P<probe_msec>(\\d+.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<hop>(\\d+)) +)?(?P<name>[\\S]+) +\\(+(?P<address>([\\d\\.]+))\\) +(?P<probe_msec>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<hop>(\\d+)) +)?(?P<address>\\*( +\\*)*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<hop>(\\d+)) +)?(?P<address>\\S+) +\\[AS +(?P<asn>\\d+)\\] +(?P<probe_msec>(\\d+.*))$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show acl",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<ip>(ipv4|ipv6)) +access\\-list +(?P<name>[\\w\\-\\.#]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<seq>\\d+) +(?P<actions_forwarding>permit|deny) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip>(ethernet-services)) +access\\-list +(?P<name>[\\w\\-\\.#]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<seq>\\d+) +(?P<actions_forwarding>permit|deny)? +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show arp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<ip_address>[\\w\\.]+) +(?P<age>[\\w\\:\\-]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<rack_slot_module>[\\w\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ARP +statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Recv: +(?P<in_requests_pkts>\\w+) +requests, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sent: +(?P<out_requests_pkts>\\w+) +requests,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<subscriber_intf_requests>\\w+) +requests +recv,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Resolve +requests +rcvd:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Resolve +requests +dropped:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Errors:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ARP +cache:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +ARP +entries +in +cache:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dynamic: +(?P<dynamic>\\w+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Alias: +(?P<alias>\\w+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +Packet +drop +count +for +node",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +ARP-IDB:(?P<total_arp_idb>\\w+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show bgp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)Egress +Engineering +Peer +Set: +(?P<prefix>[\\d\\/\\.]+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<key_1>[\\w\\s]+): +(?P<value_1>[\\S\\s]+), +(?P<key_2>[\\w\\s]+): ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<key>[\\w\\s]+): (?P<value>[\\S\\s]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<instance_id>\\d+) +(?P<placed_grp>[\\w\\_|\\-]+) +(?P<instance>[\\w\\-]+) +(?P<bgp_id>[\\d\\.]+) +(?P<num_vrfs>\\d+)? +(?P<address_family>[\\w\\s\\,\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(ID +Placed-Grp +Name +AS +VRFs +Address +Families)|(\\-)+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address_family>[(IPv|VPNv)\\d Unicast\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +BGP +instances\\: +(?P<number_of_bgp_instances>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<program>[a-zA_Z0-9\\_\\-]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*router +bgp +(?P<bgp_id>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^af\\-group +(?P<pp>[\\w\\-\\.\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^default\\-originate *(policy)? *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^maximum\\-prefix +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^next\\-hop\\-self +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^policy +(?P<map>[\\w]+) +in +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^policy +(?P<map>[\\w]+) +out +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^route\\-reflector\\-client +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^send\\-community\\-ebgp +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^send\\-extended\\-community\\-ebgp +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^site\\-of\\-origin +(?P<soo>[\\w\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^soft\\-reconfiguration +(?P<soft>[\\w\\s]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^allowas\\-in +(?P<al>\\d+)? *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^as\\-override *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*router +bgp +(?P<bgp_id>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^remote\\-as +(?P<as>\\d+)? +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^description +(?P<descr>[\\w\\,\\.\\:\\-\\s]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ebgp\\-multihop +(?P<num>\\d+)? *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^local\\-as +(?P<as>\\d+) +(?P<v1>no\\-prepend)? +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^password +encrypted +(?P<psw>\\w+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^shutdown +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^timers +(?P<keep>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^update\\-source +(?P<intf>[\\w\\.\\/]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^suppress\\-4byteas +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^session\\-open\\-mode +(?P<mode>[\\w\\-]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bfd fast-detect +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ignore\\-connected *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +instance +(?P<num>\\S+): +\\",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VRF: +(?P<vrf>[a-zA-Z0-9\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *Route *Distinguisher:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)BGP *is *operating *in *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Autonomous *System *number *format: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Autonomous *System: *(?P<as_number>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router *ID: *(?P<router_id>[\\w\\.\\:]+) *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Default *Cluster *ID: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active *Cluster *IDs: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Always compare MED is enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Comparing router ID for eBGP paths$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Treating missing MED as worst$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Fast +external +fallover +enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Platform *RLIMIT *max: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +limit +for +BMP +buffer +size: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Default *value *for *BMP *buffer *size: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current *limit *for *BMP *buffer *size: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current *utilization *of *BMP *buffer *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor *logging *is *(?P<nbr_logging>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enforce +first +AS +(?P<as_enabled>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Default *local *preference: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Default *keepalive: *(?P<keepalive>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Non\\-stop *routing *is +(?P<status>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Update *delay: *(?P<update_delay>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Generic *scan *interval: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP *Speaker *process: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Restart *count: *(?P<restart_count>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<vrf_info>[\\w\\-]+) +VRFs: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Updates:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Notifications:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Pool +(?P<pool>\\w+): +(?P<alloc>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<att>[\\w\\s]+): +(?P<number>[0-9]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address *family: *(?P<af>[a-zA-Z0-9\\s\\-\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRF +(?P<current_vrf>(\\S+)) +Address +family:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dampening +is +(?P<dampening>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Client +reflection +is +enabled +in +global +config$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Client +reflection +is +not +enabled +in +global +config$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dynamic *MED *is *(?P<dynamic_med>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dynamic *MED *interval *: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dynamic *MED *Timer *: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dynamic *MED *Periodic *Timer *: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Scan *interval: *(?P<scan_interval>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total *prefixes *scanned: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefixes *scanned *per *segment: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number *of *scan *segments: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Nexthop *resolution *minimum *prefix\\-length: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Main *Table *Version: *(?P<main_tab_ver>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Table *version *synced *to *RIB: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Table *version *acked *by *RIB: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RIB *has *not *converged: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RIB *table *prefix\\-limit *reached +\\? *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Permanent +Network +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: *(?P<state>[a-zA-Z\\s]+).$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP *Table *Version: *(?P<tab_ver>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Attribute *download: *(?P<attr>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Label *retention *timer *value *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Soft *Reconfig *Entries: *(?P<ent>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Table *bit\\-field *size *: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<thread>\\w+\\s\\w+) *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<remote>[\\w\\s\\-]+): *(?P<v1>\\d+) *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +instance +(?P<instance_number>[0-9]+): +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +neighbor +is +(?P<neighbor>[a-zA-Z0-9\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +neighbor +is +(?P<neighbor>[a-zA-Z0-9\\.\\:]+), +vrf +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +AS +(?P<remote_as>[0-9]+), +local +AS",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote *router *ID *(?P<router_id>[a-zA-Z0-9\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +state += +(?P<session_state>[a-zA-Z0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +state += +(?P<session_state>[a-zA-Z0-9]+)(?:(?P<reason>.*))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NSR *State: *(?P<nsr_state>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last *read *(?P<last_read>[0-9\\:]+), *Last *read *before *reset *(?P<last_read_before_reset>[0-9\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hold +time +is +(?P<holdtime>[0-9]+), +keepalive",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured +hold +time:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last *write *(?P<last_write>[0-9\\:]+), *attempted *(?P<attempted>[0-9]+), *written *(?P<written>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Second *last *write *(?P<second_last_write>[0-9\\:]+), *attempted *(?P<second_attempted>[0-9]+), *written *(?P<second_written>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last *write *before *reset *(?P<last_write_before_reset>[0-9\\:]+), *attempted *(?P<last_write_attempted>[0-9]+), *written *(?P<last_write_written>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Second *last *write *before *reset *(?P<second_last_write_before_reset>[0-9\\:]+), *attempted *(?P<second_last_write_before_attempted>[0-9]+), written *(?P<second_last_write_before_written>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last *write *pulse *rcvd *(?P<last_write_pulse_rcvd>[a-zA-Z0-9\\:\\.\\s]+) *last *full *not *set *pulse *count *(?P<last_full_not_set_pulse_count>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +write +pulse +rcvd +before +reset +(?P<last_write_pulse_rcvd_before_reset>[0-9\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Socket *(?P<socket_status>[a-z\\s\\,])$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last *write *thread *event *before *reset *(?P<last_write_thread_event_before_reset>[0-9\\:]+), *second *last *(?P<last_write_thread_event_second_last>[0-9\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last *KA *expiry *before *reset *(?P<last_ka_expiry_before_reset>[0-9\\:]+), *second *last *(?P<last_ka_expiry_before_second_last>[0-9\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last *KA *error *before *reset *(?P<last_ka_error_before_reset>[0-9\\:]+), *KA *not *sent *(?P<last_ka_error_ka_not_sent>[0-9\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last *KA *start *before *reset *(?P<last_ka_start_before_reset>[0-9\\:]+), *second *last *(?P<last_ka_start_before_second_last>[0-9\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Precedence: *(?P<precedence>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Non-stop +routing +is +enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TCP *Initial *Sync :(?: *(?P<tcp_initial_sync>[a-zA-Z0-9\\-\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TCP *Initial *Sync *phase *Two :(?: *(?P<tcp_initial_sync_phase_two>[a-zA-Z0-9\\-\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TCP *Initial *Sync *Done :(?: *(?P<tcp_initial_sync_done>[a-zA-Z0-9\\-\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enforcing *first *AS is *(?P<enforcing_first_as>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multi-protocol *capability *(?P<multiprotocol_capability>[a-zA-Z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +capabilities: +Adv +Rcvd$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^InQ *depth: *(?P<message_stats_input_queue>[0-9]+), *OutQ *depth: *(?P<message_stats_output_queue>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>[a-zA-Z\\s]+) *: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>[a-zA-Z\\s]+) *: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Minimum *time *between *advertisement *runs *is *(?P<minimum_time_between_adv_runs>[0-9]+) *secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Inbound *message *logging *enabled, *(?P<inbound_message>[0-9]+) *messages *buffered$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Outbound *message *logging *enabled, *(?P<outbound_message>[0-9]+) *messages *buffered$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^For +Address +Family *: +(?P<address_family>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +neighbor +version",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Update +group: +(?P<update_group>[0-9\\.]+) +Filter-group: +(?P<filter_group>[0-9\\.]+) +(?P<refresh_request_status>[a-zA-Z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route *refresh *request: *received *(?P<route_refresh_request_received>[0-9]+), *sent *(?P<route_refresh_request_sent>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Policy *for *incoming *advertisements *is *(?P<route_map_name_in>[\\w\\-\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Policy *for *outgoing *advertisements *is *(?P<route_map_name_out>[\\w\\-\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<accepted_prefixes>[0-9]+) *accepted *prefixes, *(?P<best_paths>[0-9]+) *are *bestpaths$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Exact *no\\. *of *prefixes *denied *: *(?P<exact_no_prefixes_denied>[0-9]+)\\.$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Cumulative *no\\. *of *prefixes *denied: *(?P<cummulative_no_prefixes_denied>[0-9]+)\\.$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No *policy: *(?P<cummulative_no_no_policy>[0-9]+), *Failed *RT *match: *(?P<cummulative_no_failed_rt_match>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^By *ORF *policy: *(?P<cummulative_no_by_orf_policy>[0-9]+), *By *policy: *(?P<cummulative_no_by_policy>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefix +advertised +(?P<prefix_advertised>[0-9]+), +suppressed +(?P<prefix_suppressed>[0-9]+), +withdrawn +(?P<prefix_withdrawn>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +prefixes +allowed",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Threshold +for +(?P<warn>warning)? *message +(?P<threshold_warning_message>[0-9\\%]+), +restart +interval +(?P<threshold_restart_interval>[0-9]+) +min$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^An *EoR *(?P<eor_status>[a-z\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last *ack *version *(?P<last_ack_version>[0-9]+), *Last *synced *ack *version *(?P<last_synced_ack_version>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Outstanding +version +objects: +current +(?P<outstanding_version_objects_current>[0-9]+), +max +(?P<outstanding_version_objects_max>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Additional-paths +operation: +(?P<additional_paths_operation>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Advertise +routes +with +local-label +via +(?P<additional_routes_local_label>[a-zA-Z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Send +Multicast +Attributes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Connections *(?P<bgp_state>\\w+) *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local *host: *(?P<local_host>[\\w\\.\\:]+), *Local *port: *(?P<local_port>[0-9]+), *IF *Handle: *(?P<if_handle>[a-z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Foreign *host: *(?P<foreign_host>[\\w\\.\\:]+), *Foreign *port: *(?P<foreign_port>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last *reset *(?P<last_reset>[0-9\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Capability +4-byte-as +suppress +is +configured$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Description: +(?P<description>[\\w\\s\\,\\.\\:\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Private +AS +number +removed +from +updates +to +this +neighbor$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Administratively +shut +down$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^External +BGP +neighbor +may +be +up +to +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TCP +open +mode: +(?P<mode>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^My +AS +number +is +allowed +(?P<num>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route\\-Reflector +Client$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<send_com>\\w+) +community +attribute +sent +to +this +neighbor$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Inbound +soft +reconfiguration +allowed$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^AS +override +is +set$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Default +information +originate: +(?P<route_map>[\\w\\s\\-]:)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^site\\-of\\-origin +(?P<soo>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP *instance *(?P<instance_number>[0-9]+): *(?P<instance>[a-zA-Z0-9\\-\\_\\",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP *VRF *(?P<vrf>[a-zA-Z0-9]+), *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP Route Distinguisher: *(?P<route_distinguisher>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VRF *ID: *(?P<vrf_id>[a-z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address *Family: *(?P<address_family>[a-zA-Z0-9\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP *router *identifier *(?P<router_identifier>[0-9\\.]+), *local *AS *number *(?P<local_as>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP *generic *scan *interval *(?P<generic_scan_interval>[0-9]+) +secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<non_stop_routing>(Non-stop routing is enabled))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP *table *state: *(?P<table_state>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Table *ID: *(?P<table_id>[a-z0-9]+) *RD *version: *(?P<rd_version>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP *main *routing *table *version *(?P<bgp_table_version>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP *NSR *Initial *initsync *version *(?P<nsr_initial_initsync_version>[0-9]+) *\\((?P<nsr_initial_init_ver_status>[a-zA-Z]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP *NSR/ISSU *Sync-Group *versions *(?P<nsr_issu_sync_group_versions>[0-9\\/\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP *scan *interval *(?P<scan_interval>[0-9\\S]+) *secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +Distinguisher: *(?P<route_distinguisher>\\S+) *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<status_codes>(i|s|x|S|d|h|\\*|\\>|\\s)+)? *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<path>[\\d\\s]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Processed *(?P<processed_prefixes>[0-9]+) *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<next_hop>[\\w\\.\\:]+) +((?P<metric>[0-9]+))? +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRF: *(?P<vrf>[a-zA-Z0-9\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address *Family: *(?P<address_family>[a-zA-Z0-9\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route *Distinguisher: *(?P<route_distinguisher>\\S+) *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<path>[\\d\\{\\}\\s]+)(?P<origin_code>e|i)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *instance *(?P<instance_number>[0-9]+):",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VRF: *(?P<vrf>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Address *Family:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *VRF *(?P<bgp_vrf>[A-Z0-9]+), *state:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *Route *Distinguisher:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VRF *ID: *(?P<vrf_id>[a-z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *router *identifier\n                        ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *generic *scan *interval",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Non-stop *routing *is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *table *state:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Table *ID: *(?P<table_id>[a-z0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *main *routing *table *version",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *NSR *Initial *initsync *version",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *NSR/ISSU *Sync-Group *versions",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<process>[a-zA-Z]+) *(?P<rcvtblver>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<neighbor>[a-zA-Z0-9\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<spk>[0-9]+) +(?P<remote_as>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<neighbor>[a-zA-Z0-9\\.\\:]+) +(?P<spk>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +instance +(?P<instance_number>[0-9]+): +(?P<instance>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VRF: +(?P<vrf>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Address +Family: +(?P<address_family>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +VRF +(?P<bgp_vrf>(\\S+)), +state: +(?P<vrf_state>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VRF +ID: +(?P<vrf_id>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +router +identifier +(?P<router_identifier>(\\S+)), +local +AS +number +(?P<local_as>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +generic +scan +interval +(?P<interval>(\\d+)) +secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Non-stop +routing is enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +state: +(?P<table_state>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Table +ID: +(?P<table_id>[a-z0-9]+) +RD +version: +(?P<rd_version>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +main +routing +table +version +(?P<bgp_table_version>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +NSR +Initial +initsync +version +(?P<nsr_initial_initsync_version>[0-9]+) +\\((?P<nsr_initial_init_ver_status>[a-zA-Z]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +NSR/ISSU +Sync-Group +versions +(?P<nsr_issu_sync_group_versions>[0-9\\/\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +scan +interval +(?P<scan_interval>[0-9]+) +secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +Distinguisher: +(?P<route_distinguisher>\\S+)(?: +\\(default +for +vrf +(?P<default_vrf>\\S+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(i|s|x|S|d|h|\\*|\\>|\\s)+) *(?P<prefix>(?P<ip>[a-z0-9\\.\\:\\[\\]]+)\\/(?P<mask>\\d+))(?: +(?P<next_hop>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<metric>[0-9]+) +(?P<weight>[0-9]+) +(?P<path>[0-9\\{\\}\\s]+) +(?P<origin_codes>(i|e|\\?))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<next_hop>(\\S+))(?: +(?P<metric>(\\d+)))?(?: +(?P<locprf>(\\d+)))? +(?P<weight>(\\d+)) +(?P<origin_codes>(\\?|i|e))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<status_codes>(i|s|x|S|d|h|\\*|\\>|\\s)+) *(?P<prefix>(?P<ip>[0-9\\.\\:\\[\\]]+)/(?P<mask>\\d+))? +(?P<next_hop>\\S+) +(?P<number>[\\d\\s\\{\\}]+)(?: *(?P<origin_codes>(i|e|\\?)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<path>[\\d\\s]+) *(?P<origin_codes>(i|e|\\?))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Processed +(?P<processed_prefix>[0-9]+) +prefixes, +(?P<processed_paths>[0-9]+) +paths$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<neighbor>\\S+) +(?P<vrf>\\S+) +(?P<spk>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<neighbor>[\\w\\d:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<vrf>\\S+) +(?P<spk>\\d+) +(?P<as_number>\\d+) +(?P<in_q>\\d+) +(?P<out_q>\\d+) +(?P<nbr_state>\\w+) +(?P<nsr_state>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +instance +\\d+: +\\",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<vrf>(\\S+)) +(?P<id>([x0-9\\-]+)) +(?P<rd>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<item>([a-zA-Z0-9\\,\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +routing +table +information +for +VRF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +version +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<next_hop>[a-zA-Z0-9\\.\\:\\/\\[\\]\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +Distinguisher *: +(?P<route_distinguisher>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *router *identifier *(?P<router_identifier>[0-9\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *generic *scan *interval *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Non-stop *routing *is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *table *state: *(?P<table_state>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Table *ID: *(?P<table_id>[a-z0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *main *routing *table *version",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *NSR *Initial *initsync *version *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *NSR/ISSU *Sync-Group *versions *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP *scan *interval *(?P<scan_interval>[0-9\\s]+) *secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<next_hop>[\\w\\.\\:]+) *(?P<number>[\\d\\s\\{\\}]+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Processed +(?P<processed_prefix>[0-9]+) +prefixes, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +Distinguisher: +(?P<rd>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<prefix>\\[[^/]+\\])/(?P<prefix_length>(\\d+)) +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Path info:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^neighbor: +(?P<neighbor>(\\S+)) +neighbor +router",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<flags>(valid.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Received +Path +ID +(?P<rx_path_id>(\\d+)), +Local",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Attributes +after +(?P<type>(outbound|inbound))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^next +hop:(?: +(?P<nexthop>(\\S+)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<community_attributes>(EXTCOMM|ORG AS EXTCOMM))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^origin:(?: +(?P<origin>.*))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^aspath:(?: +(?P<aspath>.*))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^community:(?: +(?P<community>.*))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^extended +community:(?: +(?P<extended_community>.*))?$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show cdp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<device_id>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show controllers",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Node +ID: +(?P<node_id>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^mac\\=(?P<mac>[A-Fa-f0-9:]+) +vlan=(?P<vlan>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +: +(?P<port>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Controller +State +: +(?P<controller_state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Inherited +Secondary +State +: +(?P<inherited_secondary_state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured +Secondary +State +: +(?P<configured_secondary_state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Derived +State +: +(?P<derived_state>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Loopback +mode +: +(?P<loopback_mode>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BER +Thresholds +: SF += +(?P<sf>\\S+) +SD += +(?P<sd>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Performance +Monitoring +: +(?P<performance_monitoring>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LOS += +(?P<los>\\d+) +LOF += +(?P<lof>\\d+) +LOM += +(?P<lom>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OOF += +(?P<oof>\\d+) +OOM += +(?P<oom>\\d+) +AIS += +(?P<ais>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IAE += +(?P<iae>\\d+) +BIAE += +(?P<biae>\\d+) +SF_BER += +(?P<sf_ber>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SD_BER += +(?P<sd_ber>\\d+) +BDI += +(?P<bdi>\\d+) +TIM += +(?P<tim>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FECMISMATCH += +(?P<fecmis_match>\\d+) +FEC-UNC += +(?P<fec_unc>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Detected +Alarms +: +(?P<detected_alarms>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PREFEC +BER +: +(?P<prefec_ber>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^POSTFEC +BER +: +(?P<postfec_ber>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OTU +TTI +(?P<otu_tti>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FEC +mode +: +(?P<fec_mode>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Controller +State: +(?P<controller_state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Transport +Admin +State: +(?P<transport_admin_state>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Laser +State: +(?P<laser_state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LED +State: +(?P<led_state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Optics +Type: +(?P<optics_type>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DWDM +[Cc]arrier +Info: +(?P<dwdm_carrier_info>[\\w\\s]+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Wavelength *= *(?P<wavelength>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Detected +Alarms: +(?P<detected_alarms>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?!-)(?P<alarm>[\\w-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LOS\\/LOL\\/Fault +Status:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Detected +LOS\\/LOL\\/FAULT: +(?P<detected_los_lol_fault>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^HIGH-RX-PWR *= *(?P<high_rx_pwr>\\d+) +LOW-RX-PWR *= *(?P<low_rx_pwr>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^HIGH-TX-PWR *= *(?P<high_tx_pwr>\\d+) +LOW-TX-PWR *= *(?P<low_tx_pwr>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^HIGH-LBC *= *(?P<high_lbc>\\d+) +HIGH-DGD *= *(?P<high_dgd>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OOR-CD *= *(?P<oor_cd>\\d+) +OSNR *= *(?P<osnr>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^WVL-OOL *= *(?P<wvl_ool>\\d+) +MEA *= *(?P<mea>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IMPROPER-REM *= *(?P<improper_rem>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TX-POWER-PROV-MISMATCH *= *(?P<tc_power_prov_mismatch>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Laser +Bias +Current *= *(?P<laser_bias_current>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Actual *)?TX +Power *= *(?P<actual_tx_power>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RX +Power *= *(?P<rx_power>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Performance +Monitoring: +(?P<performance_monitoring>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<parameter>[\\w\\s(.]+\\)) +(?P<high_alarm>[\\w\\/.-]+) +(?P<low_alarm>[\\w\\/.-]+) +(?P<high_warning>[\\w\\/.-]+) +(?P<low_warning>[\\w\\/.-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<lane>\\d+) +(?P<laser_bias>[\\w.-]+ +\\w+) +(?P<tx_power>[\\w.-]+ +\\w+) +(?P<rx_power>[\\w.-]+ +\\w+) +(?P<output_frequency>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Temperature *= *(?P<temperature>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Voltage *= *(?P<voltage>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LBC +High +Threshold *= *(?P<lbc_high_threshold>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured +Tx +Power *= *(?P<configured_tx_power>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured +OSNR +lower +Threshold *= *(?P<configured_osnr_lower_threshold>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured +DGD +Higher +Threshold *= *(?P<configured_dgd_higher_threshold>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Chromatic +Dispersion +(?P<chromatic_dispersion>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured CD-MIN +(?P<configured_cd_min>[\\s\\S]+) +CD-MAX +(?P<configured_cd_max>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Optical +Signal +to +Noise +Ratio *= *(?P<optical_snr>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Polarization +Dependent +Loss *= *(?P<polarization_dependent_loss>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Polarization +parameters +(?P<polarization_parameters>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Differential +Group +Delay *= *(?P<differential_group_delay>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Form +Factor +: +(?P<form_factor>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Optics +type +: +(?P<optics_type>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Name +: +(?P<name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OUI +Number +: +(?P<oui_number>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Part +Number +: +(?P<part_number>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rev +Number +: +(?P<rev_number>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Serial +Number +: +(?P<serial_number>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PID +: +(?P<pid>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VID +: +(?P<vid>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Date +Code.*: +(?P<date_code>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Node +ID: +(?P<node_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<port>\\d+) +\\| +(?P<priority>\\S+) +\\| +(?P<high_calendar>\\d+) +\\| +(?P<low_calendar>\\d+) +\\| +(?P<egq_if>\\d+) +\\| +(?P<e2e_if>\\d+) +\\| +(?P<egq_port_rate>\\d+) +\\| +(?P<egq_if_rate>\\d+) +\\| +(?P<e2e_port_rate>\\d+) +\\| +(?P<e2e_if_rate>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Node +ID: +(?P<node_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+) +(?P<interface_handle_hex>[0-9a-f]+) +(?P<npu_number>\\d+) +(?P<npu_core>\\d+) +(?P<pp_port>\\d+) +(?P<sys_port>\\d+) +(?P<voq_base>\\d+) +(?P<flow_base>\\d+) +(?P<voq_port_type>\\S+) +(?P<port_speed>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Node +ID: +(?P<node_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mapping>[\\S ]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<port_number>\\d+) +\\| +(?P<priorities>\\d+) +\\| +(?P<base_q_pair>\\d+) +\\| +(?P<ps_number>\\d+) +\\| +(?P<core>\\d+) +\\| +(?P<tm_port>\\d+) +\\|$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show dampening",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^[a-z-A-Z\\s]+state:\\s+(?P<und_stat>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<prot>\\S+)? +(?P<prot_cap>\\S+)? +(?P<prot_pen>\\d+) +(?P<prot_sup>YES|NO)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<stat>Dampening not enabled)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show ethernet",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Domain +(?P<domain>\\S+) +\\(level +(?P<level>\\d+)\\), +Service +(?P<service>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mep_type>\\w+) +MEP +on +(?P<interface>\\S+) +MEP-ID +(?P<mep_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<st>(>|R|L|C|X|\\*|I|V|T|M|U)) +(?P<id>\\d+) +(?P<mac_address>\\S+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface_name>[A-Z][a-z])([A-Za-z]+)(?P<interface_number>[0-9\\/]+) +is +(?P<status>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Dot1Q +Tunneling +Ethertype +is +(?P<dot1q_tunneling_ethertype>[a-z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interface\\s +St\\s +MTU\\s +Ly\\s +Outer\\s +Inner\\s +Xtra\\s +-,+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<sub_interface>[A-Za-z0-9\\/\\.]+) +(?P<status>[A-Za-z]+) +(?P<mtu>[0-9]+) +(?P<layer>[A-Z0-9]+) +(\\.)(?P<outer_encapsulation_type>[A-Za-z0-9]+)(\\:)(?P<outer_encapsulation_value>[0-9]+) +((\\.)(?P<inner_encapsulation_type>[A-Za-z0-9]+)(\\:)(?P<inner_encapsulation_value>[0-9]+))?",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show evpn",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<evi>\\d+) +(?P<bridge_domain>\\S+) +(?P<type>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<route_target_in_use>[\\d+:\\d+]+) +(?P<type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(-+ *)+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\S ]+) *: +(?P<value>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<evi>(\\d+)) +(?P<esi>([a-z0-9\\.]+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<vpn_id>(\\d+)) +(?P<encap>([a-zA-Z]+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multi-paths +resolved: +(?P<mp_resolved>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multi-paths +Internal +label: +(?P<internal>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>(MAC|EAD\\/ES|EAD\\/EVI|Summary))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nexthop>(\\S+))(?: +\\((?P<df_role>(\\S+))\\))?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Summary pathlist:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<value>(\\S+))(?: +(?P<df_role>\\(\\S+\\)))? +(?P<nexthop>(\\S+)) +(?P<label>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<vpn_id>\\d+)( +(?P<encap>\\S+))? +(?P<mac_address>[\\w\\.]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mac_address>\\S+) +(?P<next_hop>\\S+) +(?P<label>\\d+) +(?P<vpn_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +Address +: +(?P<ip_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Ethernet +Tag +: +(?P<ethernet_tag>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multi-paths +Resolved +: +(?P<multipaths_resolved>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multi-paths +Internal +label +: +(?P<multipaths_internal_label>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multi-paths +Local +Label +: +(?P<multipaths_local_label>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +Static +: +(?P<local_static>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +Static +: +(?P<remote_static>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +Ethernet +Segment +: +(?P<local_ethernet_segment>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Ether\\S+Segment *: +(?P<ethernet_segment>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +Ethernet +Segment +: +(?P<remote_ethernet_segment>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +Sequence +Number +: +(?P<local_sequence_number>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +Sequence +Number +: +(?P<remote_sequence_number>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +Encapsulation +: +(?P<local_encapsulation>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +Encapsulation +: +(?P<remote_encapsulation>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ESI +Port +Key +: +(?P<esi_port_key>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +: +(?P<source>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flush +Requested +: +(?P<flush_requested>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flush +Received +: +(?P<flush_received>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SOO +Nexthop +: +(?P<soo_nexthop>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BP +XCID +: +(?P<bp_xcid>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +State +: +(?P<mac_state>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +Producers +: +(?P<mac_producers>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +Router +MAC +: +(?P<local_router_mac>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^L3 +Label +: +(?P<l3_label>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Object: +(?P<object_name>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Base info: +version=(?P<version>\\S+), +flags=(?P<flags>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EVPN +MAC +event +history +\\[Num +events: +(?P<num_events>\\d+)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<time>\\w+ +\\d+ +\\S+) +(?P<event>[\\S ]+) +(?P<flag_1>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flush +Count *: +(?P<flush_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BP +IFH: +(?P<bp_ifh>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flush +Seq +ID +: +(?P<flush_seq_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Static *: +(?P<static>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<segment_id>[\\w\\.\\/]+) +(?P<interface>\\S+) +(?P<next_hop>[\\d\\.\\<]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<next_hop>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ES +to +BGP +Gates +: +(?P<es_to_bgp_gates>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ES +to +L2FIB +Gates +: +(?P<es_to_l2fib_gates>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface name +: +(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +MAC *: +(?P<interface_mac>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IfHandle +: +(?P<if_handle>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State + : +(?P<state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Redundancy +: +(?P<redundancy>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +MAC +: +(?P<source_mac>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Operational +: +(?P<operational>[\\S+ ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured +: +(?P<configured>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Primary +Services +: +(?P<primary_services>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Secondary +Services *: +(?P<secondary_services>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge +ports +: +(?P<bridge_ports>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Elected +: +(?P<elected>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Not +Elected +: +(?P<not_elected>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^I-Sid +E +: +(?P<i_sid_e>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^I-Sid +NE +: +(?P<i_sid_ne>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +Flushing +mode +: +(?P<mac_flushing_mode>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peering +timer +: +(?P<peering_timer>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Recovery +timer +: +(?P<recovery_timer>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flushagain +timer +: +(?P<flush_again_timer>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ESI +type *: +(?P<esi_type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Value *: +(?P<value>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ES +Import +RT *: +(?P<es_import_rt>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Service +Carving *: +(?P<service_carving>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peering +Details *: +(?P<peering_details>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Forwarders *: +(?P<forwarders>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Permanent *: +(?P<permanent>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Carving +timer *: +(?P<carving_timer>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +SHG +label *: +(?P<local_shg_label>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +SHG +labels? *: +(?P<remote_shg_label>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<shg_label>\\d+) *: +nexthop +(?P<next_hop>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Object: +(?P<object_name>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Base info: +version=(?P<version>\\S+), +flags=(?P<flags>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EVPN +ES +event +history +\\[Num +events: +(?P<num_events>\\d+)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<time>\\w+ +\\d+ +\\S+) +(?P<event>[\\S ]+) +(?P<flag_1>[\\d\\w]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EVPN +ES +Statistics$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<label>[\\S ]+)\\| +(?P<adv_cnt>\\d+)( +(?P<adv_last_time>\\d+\\/\\d+ +\\S+))?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Num +RDs: *: +(?P<num_rds>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<label_1>[\\S ]+): +(?P<val_1>\\S+)( +\\((?P<per_es_1>\\w+)\\))? +(?P<label_2>[\\S ]+): +(?P<val_2>\\S+)( +\\((?P<per_es_2>\\w+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<label_1>[\\S ]+): +(?P<val_1>\\S+)( +\\((?P<per_es_1>\\w+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RD: +(?P<rd>\\S+), +Num +RTs: +(?P<num_rts>\\d+) +RT +List:( +(?P<rt_list>\\d+:\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<rt_list>((\\d+:\\d+), ?)+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Chkpt +ObjId *: +(?P<chkpt_objid>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MSTi +Mask *: +(?P<msti_mask>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nexthop>\\d+\\.\\d+\\.\\d+\\.\\d+) +(?P<nexthopinfo>\\[\\S+\\])$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IF +Type *: +(?P<if_type>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peering +Details *:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EVPN-VPWS +Service +Carving +Results:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Primary +: +(?P<primary>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Backup +: +(?P<backup>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Non-DF +: +(?P<non_df>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Checkpoint +Info:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<evi>\\d+)( +(?P<encap>\\S+))? +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<tep_id>\\S+) +(?P<df_role>\\(\\w\\)) +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show hsrp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)\\s*(?P<state_name>[a-zA-Z]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<num_intf>[0-9]+) +HSRP +IPv4 +interfaces",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<num_intf>[0-9]+) +HSRP +IPv6 +interfaces",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<num_addresses>[0-9]+) +Virtual +IPv4",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<num_addresses>[0-9]+) +Virtual +IPv6",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<num_tracked_objects>[0-9]+) +Tracked",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<num_bfd_sessions>[0-9]+) +BFD +sessions",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<interface>[a-zA-Z0-9\\/\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*[lL]abel +(?P<session_name>\\S+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*[sS]lave +to +(?P<follow>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Local +state +is +(?P<hsrp_router_state>",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Preemption +delay +for +at +least",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Hellotime +(?P<hello_msec>[0-9]+) +msec",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Configured +hellotime",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Minimum +delay +(?P<minimum_delay>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*BFD enabled \\((?P<bfd_interface_name>\\S+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Hot +standby +IP +address +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Active +router +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Standby +router +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Standby +virtual +mac +address +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Authentication +text, +string",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<num_state_changes>[0-9]+) +state",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Standby ICMP redirects disabled",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Last +coup +sent:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Last +coup +received:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Last +resign +sent:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Last +resign +received:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Tracking +states +for",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<tracked_status>\\S+) +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show igmp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<interface>\\S+) +is +(?P<interface_status>[\\w\\s]+), +line +protocol +is +(?P<line_protocol>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Internet +[A|a]ddress +is +(?P<ip_address>[\\d\\.\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +is +(?P<igmp_state>[a-zA-Z]+) +on +interface$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current +IGMP +version +is +(?P<igmp_version>[\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +query +interval +is +(?P<igmp_query_interval>[\\d]+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +querier +timeout +is +(?P<igmp_querier_timeout>[\\d]+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +max +query +response +time +is +(?P<igmp_max_query_response_time>[\\d]+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +member +query +response +interval +is +(?P<last_member_query_response_interval>[\\d]+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +activity: +(?P<joins>[\\d]+) +joins, +(?P<leaves>[\\d]+) +leaves$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +querying +router +is +(?P<igmp_querying_router>[\\d\\.]+)+([\\s*]+\\(+(?P<igmp_querying_router_info>[\\S\\s*]+)+\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time +elapsed +since +last +query +sent +(?P<time_elapsed_since_last_query_sent>[\\d\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time +elapsed +since +IGMP +router +enabled +(?P<time_elapsed_since_router_enabled>[\\d\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time +elapsed +since +last +report +received +(?P<time_elapsed_since_last_report_received>[\\d\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Robustness +Value +(?P<robustness_value>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No. +of +Group +x +Interfaces +(?P<no_of_group_x_interface>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +number +of +Groups +for +this +VRF +(?P<maximum_number_of_groups_for_vrf>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Supported +Interfaces +: +(?P<supported_interfaces>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unsupported +Interfaces +: +(?P<unsupported_interfaces>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enabled +Interfaces +: +(?P<enabled_interfaces>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Disabled +Interfaces +: +(?P<disabled_interfaces>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTE +tuple +count +: +(?P<mte_tuple_count>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<interface>(\\S+)) +(?P<number_groups>(\\d+)) +(?P<max_groups>(\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface:+[\\s]+(?P<interface>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group:+[\\s*]+(?P<group>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Uptime:+[\\s*]+(?P<up_time>[\\d\\:\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router mode:+[\\s*]+(?P<router_mode>[\\S]+)+([\\s*]+\\(Expires: +(?P<router_mode_expires>[\\S]+)+\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Host mode:+[\\s*]+(?P<host_mode>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last reporter:+[\\s*]+(?P<last_reporter>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Suppress:+[\\s*]+(?P<suppress>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<source>[\\d\\.\\:]+) +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show interface",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*Port +VRF +Status +IP Address +Speed +MTU$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<port>[a-zA-Z0-9\\/\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Ethernet +VLAN +Type +Mode +Status",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[a-zA-Z0-9\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Port-channel +VLAN +Type +Mode +Status",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[a-zA-Z0-9\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interface +Status +Description$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[a-zA-Z0-9\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[a-zA-Z0-9\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[a-zA-Z0-9\\/\\.\\-]+) +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[a-zA-Z0-9\\/\\.\\-]+) +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interface +state +transitions:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Hardware is (?P<types>[a-zA-Z\\,\\s]+)(?:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Hardware is (?P<types>[\\w\\W]+) +address",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Description: +(?P<description>[\\w\\W]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Internet +address +is +(?P<ip>[a-z0-9\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MTU +(?P<mtu>[0-9]+) +bytes, +BW",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*reliability +(?P<reliability>[a-zA-Z0-9\\/]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Encapsulation +(?P<encapsulation>[a-zA-Z0-9\\.\\s]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Encapsulation +(?P<encapsulation>[a-zA-Z0-9\\.\\s]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Encapsulation +(?P<encapsulation>[a-zA-Z0-9\\.\\s]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Encapsulation +(?P<encapsulation>[a-zA-Z0-9\\.\\s]+),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Encapsulation +(?P<encapsulation>[a-zA-Z0-9\\.\\s]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*loopback +(?P<loopback_status>[a-zA-Z\\s]+),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last +input +(?P<last_input>[\\w\\W]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ARP +type +(?P<arp_type>\\S+), +ARP +timeout",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last +link +flapped +(?P<last_link_flapped>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last +clearing +of +\"show interface\"",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<load_interval>[0-9]+) +(?P<timecheck>minute|second|)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<duplex_mode>[\\w\\W]+), +(?P<port_speed>\\S+)(Mb/s|Kb/s|Gb/s),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<duplex_mode>[\\w\\W]+), +(?P<port_speed>\\S+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*output +flow +control +is +(?P<flow_control_send>(off)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*output +flow +control +is +(?P<flow_control_send>(on)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*output +flow +control +is +(?P<flow_control_send>(on)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*output +flow +control +is +(?P<flow_control_send>(off)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Carrier +delay +\\(up\\) +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<load_interval>[0-9]+) +(?P<timecheck>minute|second|)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<in_pkts>[0-9]+) +packets +input,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<in_unknown_protos>[0-9]+) +drops +for +unrecognized",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Received +(?P<in_broadcast_pkts>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<in_runts>[0-9]+) +runts, +(?P<in_giants>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<in_frame_errors>[0-9]+) +input +errors,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<out_pkts>[0-9]+) +packets +output,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Output +(?P<out_broadcast_pkts>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<out_errors>[0-9]+) +output +errors,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<out_buffer_failures>[0-9]+) +output",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<carrier_transitions>[0-9]+) +carrier +transitions$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[a-zA-Z0-9\\/\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[a-zA-Z0-9\\/\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>\\S+) +is (?P<int_status>\\S+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Vrf +is +(?P<vrf>\\S+) \\(vrfid +(?P<vrf_id>[a-z0-9]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interface is unnumbered. +Using +address",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Internet +address +is +(?P<ip>[0-9\\.]+)\\/",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<secondary>(Secondary)) +address",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MTU is +(?P<mtu>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Helper +address +is +(?P<helper_address>[a-z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multicast +reserved +groups +joined: +(?P<multicast_groups_address>[a-z0-9\\.\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<multicast_groups_address>[a-z0-9\\.\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Directed +broadcast +forwarding +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Outgoing +access +list +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Inbound +access +list +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Inbound +common +access +list +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Proxy +ARP +is +(?P<proxy_arp>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ICMP +redirects +(are|is) +(?P<icmp_redirects>[a-zA-Z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ICMP +unreachables +(are|is)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ICMP +mask +replies +(are|is) +(?P<icmp_replies>[a-zA-Z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Table +Id +is +(?P<table_id>[a-z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^show +[\\S\\s]+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>\\S+) +is +(?P<int_status>[a-zA-Z]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<enabled>(IPv6 is enabled)), +link-local",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<enabled>(IPv6 is enabled)), +link-local",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<enabled>(IPv6 is disabled)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<ipv6>(.+)(ff:fe)(.+)), +subnet +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<ipv6>[a-zA-Z0-9\\:]+), +subnet +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<ipv6>[a-zA-Z0-9\\:]+), +subnet +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<ipv6>[a-zA-Z0-9\\:]+), +subnet +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Joined +group +address\\(es\\): +(?P<ipv6_group_address>[a-z0-9\\:\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<ipv6_group_address>[a-z0-9\\:\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MTU +is +(?P<ipv6_mtu>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ICMP +redirects +are +(?P<icmp_redirects>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ICMP +unreachables +are",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ND +DAD +is +(?P<nd_dad>[a-z]+), +number +of +DAD",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ND +reachable +time +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ND +cache +entry +limit +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ND +advertised +retransmit +interval +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ND +router +advertisements +are +sent",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ND +router +advertisements +live +for",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Hosts +use +(?P<stateless_autoconfig>(stateless))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Outgoing +access +list +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Inbound +access +list +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Inbound +common +access +list +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Table +Id +is +(?P<table_id>[a-z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Complete +protocol +adjacency:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Complete +glean +adjacency:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Incomplete +protocol +adjacency:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Incomplete +glean +adjacency:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Dropped +protocol +request:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Dropped +glean +request:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\w\\/\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>\\S+)\\s*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<protocol>\\S+)\\s+(?P<pkts_in>\\d+)\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+) +is +(?P<enabled>[\\w\\s]+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +state +transitions: +(?P<interface_state_transitions>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hardware +is +(?P<type>[\\w\\-\\/\\s\\+\\(\\)]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Layer +2 +Transport +Mode$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Description: *(?P<description>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Internet +[A|a]ddress +is +(?P<ipv4>(?P<ip>[\\d\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU +(?P<mtu>[\\d]+) +bytes, +BW +(?P<bandwidth>[\\d]+) +Kbit",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^reliability +(?P<reliability>[\\w\\/]+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Encapsulation +(?P<encapsulation>[\\w\\.\\s]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Outer +Match: +(?P<outer_match>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Ethertype +(?P<ethertype>\\w+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<duplex_mode>[\\w\\s\\-]+([d|D]uplex|unknown)), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^output +flow +control +is +(?P<send>\\w+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Carrier +delay +\\(up\\) +is +(?P<carrier_delay_up>\\d+) +msec",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^loopback +(?P<loopback>[\\w\\s]+),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +link +flapped +(?P<last_link_flapped>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ARP +type +(?P<arp_type>\\w+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +input +(?P<last_input>[\\w\\.\\:]+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No\\. +of +members +in +this +bundle: +(?P<member_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\w\\/\\.]+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +clearing +of +\"show +interface\" +counters +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input\\/output +data +rate +is +disabled\\.$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<load_interval>[\\d\\#]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<load_interval>[\\d\\#]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_pkts>[\\d]+) +packets +input, +(?P<in_octets>[\\d]+) +bytes",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<in_unknown_protos>[\\d]+) +drops +for ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<in_drops>[\\d]+) +input +drops, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Received +(?P<in_broadcast_pkts>\\d+) +broadcast +packets, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_runts>[\\d]+) +runts, +(?P<in_giants>[\\d]+) +giants, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_errors>[\\d]+) +input +errors, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_pkts>[\\d]+) +packets +output, +(?P<out_octets>[\\d]+) +bytes",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +(?P<out_broadcast_pkts>\\d+) +broadcast +packets, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_errors>[\\d]+) +output +errors, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<out_drops>[\\d]+) +output +drops, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_buffer_failure>[\\d]+) +output +buffer +failures, ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<carrier_transitions>[\\d]+) +carrier +transitions$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<interface>(\\S+)[^-]) +(?P<status>(\\S+)) +(?P<protocol>(\\S+))(?: +(?P<description>(\\S+)))?$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show ipv6",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<ip>\\S+)\\s+(?P<age>\\S+)\\s+(?P<link_layer_address>\\S+)\\s+(?P<neighbor_state>\\S+)\\s+(?P<interface>\\S+)\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[(?P<ip>([\\w\\s]+))\\]\\s+(?P<age>\\S+)\\s+(?P<link_layer_address>\\S+)\\s+(?P<neighbor_state>\\S+)\\s+",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show isis",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)IS-IS +(?P<instance>\\S+) +(?P<topology>\\S+\\s+\\S+) +FRR +summary",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Prefixes +reachable +in +L(?P<level>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<name>[\\S\\s]+) +(?P<critical_priority>\\d+) +(?P<high_priority>\\d+) +(?P<medium_priority>\\d+) +(?P<low_priority>\\d+) +(?P<total>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Protection +coverage +(?P<critical_priority>[\\d\\.\\%]+) +(?P<high_priority>[\\d\\.\\%]+) +(?P<medium_priority>[\\d\\.\\%]+) +(?P<low_priority>[\\d\\.\\%]+) +(?P<total>[\\d\\.\\%]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS-IS +(?P<isis_name>\\w+) +(?P<level_name>\\S+) adjacencies:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<system_id>\\S+) +(?P<interface>\\S+) +(?P<snpa>\\S+) +(?P<state>(Up|Down|None)) +(?P<hold>\\S+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +adjacency +count: +(?P<adjacency_count>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<system_id>\\S+) +(?P<interface>\\S+) +(?P<snpa>\\S+) +(?P<state>(Up|Down|None)) +(?P<hold>\\S+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS-IS\\s+(?P<isis_name>\\S+)\\s*neighbors:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<system_id>\\S+) +(?P<interface>\\S+) +(?P<snpa>\\S+) +(?P<state>(Up|Down|None|Init)+) +(?P<holdtime>\\S+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total\\sneighbor\\scount:\\s+(?P<neighbor_count>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS-IS\\s+(?P<instance>\\S+)\\s+IS\\s+Label\\s+Table$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<label>\\d+)\\s+(?P<prefix_interface>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show l2vpn",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Main +Interface +ID +Instance +State$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge +group: +(?P<bridge_group>\\S+), +bridge\\-domain: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Aging: +(?P<mac_aging_time>\\d+) s, +MAC +limit: +(?P<mac_limit>\\d+), +Action: +(?P<mac_limit_action>[\\S ]+), +Notification: +(?P<mac_limit_notification>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Filter +MAC +addresses: +(?P<filter_mac_address>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ACs: +(?P<ac>\\d+) +\\((?P<ac_up>\\d+) +up\\), +VFIs: +(?P<vfi>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+), +state: +(?P<state>\\w+), +Static +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+), +state: +(?P<state>\\w+), +BVI +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VFI +(?P<vfi>\\S+)( +\\((?P<state>\\w+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Neighbor +(?P<neighbor>\\S+) +pw-id +(?P<pw_id>\\d+), +state: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<bridge_group>\\S+)\\/(?P<bridge_domain_name>\\S+) +(?P<id>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<evpn>\\S+), +state: +(?P<state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +groups: +(?P<number_of_groups>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +ACs: +(?P<ac>\\d+) +Up: +(?P<up>\\d+), +Down: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +PWs: +(?P<pw>\\d+) +Up: +(?P<up>\\d+), +Down: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge +group: +(?P<bridge_group>\\S+), +bridge\\-domain: +(?P<bridge_domain>\\S+), +id: +(?P<id>\\d+), +state: +(?P<state>\\w+), +ShgId: +(?P<shg_id>\\d+)(, +MSTi: +(?P<mst_i>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mode>\\S+) +Mode$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +learning: +(?P<mac_learning>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +withdraw: +(?P<mac_withdraw>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flooding:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Broadcast +& +Multicast: +(?P<enabled>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unknown +unicast: +(?P<enabled>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +aging +time: +(?P<mac_aging_time>\\d+) +s, +Type: +(?P<mac_aging_type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +limit: +(?P<mac_limit>\\d+), +Action: +(?P<action>\\S+), +Notification: +(?P<notification>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +limit +reached: +(?P<mac_limit_reached>\\S+)(, +threshold: +(?P<threshold>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Security: +(?P<security>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DHCPv4 +(s|S)nooping: +(?P<dhcp_v4_snooping>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DHCPv4 +(s|S)nooping profile: +(?P<dhcp_v4_snooping_profile>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)IGMP +(s|S)nooping: +(?P<igmp_snooping>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +(s|S)nooping profile: +(?P<igmp_snooping_profile>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +(s|S)nooping profile: +(?P<mld_snooping_profile>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU: +(?P<mtu>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Filter +MAC +addresses:( +(?P<filter_mac_addresses>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ACs: +(?P<ac>\\d+) +\\((?P<ac_up>\\d+) +up\\), +VFIs: +(?P<vfi>\\d+), +PWs: +(?P<pw>\\d+) +\\((?P<pw_up>\\d+) +up\\)(, +PBBs: +(?P<pbb>\\d+) +\\((?P<pbb_up>\\d+) +up\\))?(, +VNIs: +(?P<vni>\\d+) +\\((?P<vni_up>\\d+) +up\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^List +of +ACs:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^AC: +(?P<interface>\\S+), +state +is +(?P<state>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Type +(?P<type>\\S+)(; +Num +Ranges: +(?P<num_ranges>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU +(?P<mtu>\\d+); +XC +ID +(?P<xc_id>\\S+); +interworking +(?P<interworking>\\S+)(; +MSTi +(?P<mst_i>\\d+))?( +\\((?P<mst_i_state>\\w+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Type +(?P<pw_type>\\S+) +MTU +(?P<mtu>\\d+); +XC +ID +(?P<xc_id>\\d+); +interworking +(?P<interworking>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<static_mac_address>[a-zA-Z\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Statistics:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)packet(s)?( +totals)?: +receive(d)? +(?P<receive>\\d+)( +\\(( *multicast +(?P<multicast>\\d+),?)?( *broadcast +(?P<broadcast>\\d+),?)?( *unknown +unicast +(?P<unknown_unicast>\\d+),?)? *unicast +(?P<unicast>\\d+)\\))?, *sen(d|t) +(?P<send>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)byte(s)?( +totals)?: +receive(d)? +(?P<receive>\\d+)( +\\(( *multicast +(?P<multicast>\\d+),?)?( *broadcast +(?P<broadcast>\\d+),?)?( *unknown +unicast +(?P<unknown_unicast>\\d+),?)? *unicast +(?P<unicast>\\d+)\\))?, *sen(d|t) +(?P<send>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^List +of +Access +PWs:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^List +of +VFIs:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VFI +(?P<vfi>\\S+)( +\\((?P<state>\\w+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PW: +neighbor +(?P<neighbor>\\S+), +PW +ID +(?P<pw_id>\\d+), +state +is +(?P<state>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PW +class +(?P<pw_class>\\w+), +XC +ID +(?P<xc_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PW +class +(?P<pw_class>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Encapsulation +(?P<encapsulation>\\S+)(, +protocol +(?P<protocol>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>PW|Encap) +type +(?P<pw_type>\\S+), +control +word +(?P<control_word>\\S+)(, +interworking +(?P<interworking>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)PW +backup +disable +delay +(?P<delay>\\d+) +sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Sequencing +(?P<sequencing>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>MPLS|EVPN) +Local +Remote$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?!(show +l2vpn))(?P<mpls>[\\S ]+)\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^-+ +-+ +-+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Create +time: +(?P<create_time>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Last +time +status +changed: +(?P<last_time_status_changed>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +withdraw +message(s)?: +sen(d|t) +(?P<send>\\d+),? +receive(d)? +(?P<receive>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Static +MAC +addresses:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)VFI +Statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)drops: +(?P<drops>\\S+) VLAN +(?P<vlan>\\d+), +illegal +length +(?P<illegal_length>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\([\\S ]+\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Wed|Thu|Fri|Sat|Sun|Mon|Tue]+ +[Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec]+ +\\d{1,2} +\\d{1,2}:\\d{1,2}:\\d{1,2}[\\.]\\d{1,3} +[A-Z]{3}",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Legend: +(?P<legend>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Coupled +state: +(?P<coupled_state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VINE +state: +(?P<vine_state>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +withdraw +for +Access +PW: +(?P<mac_withdraw_for_access_pw>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +withdraw +sent +on: +(?P<mac_withdraw_sent_on>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +withdraw +relaying \\(access +to +access\\): +(?P<mac_withdraw_relaying>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +port +down +flush: +(?P<mac_port_down_flush>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +Secure: +(?P<mac_secure>\\w+), +Logging: +(?P<mac_secure_logging>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Split +Horizon +Group: +(?P<split_horizon_group>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dynamic +ARP +Inspection: +(?P<dynamic_arp_inspection>\\w+), +Logging: +(?P<dynamic_arp_logging>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +Source +Guard: +(?P<ip_source_guard>\\w+), +Logging: +(?P<ip_source_logging>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Storm +Control: +(?P<storm_control>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge +MTU: +(?P<bridge_mtu>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MIB +cvplsConfigIndex: (?P<mid_cvpls_config_index>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^P2MP +PW: +(?P<p2mp_pw>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No +status +change +since +creation$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^List +of +EVPNs:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<evpn>\\S+), +state: +(?P<state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^evi: +(?P<evi>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^XC +ID (?P<xc_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +move: +(?P<mac_move>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BVI +MAC +address:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<bvi_mac_address>\\w+\\.\\w+\\.\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rewrite +Tags: +\\[(?P<rewrite_tags>\\S+)?\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VLAN +ranges: +\\[(?P<vlan_ranges>[\\S ]+)?\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Storm +control +drop +counters:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^packets: +broadcast +(?P<broadcast>\\d+), +multicast +(?P<multicast>\\d+), +unknown +unicast +(?P<unknown_unicast>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bytes: +broadcast +(?P<broadcast>\\d+), +multicast +(?P<multicast>\\d+), +unknown +unicast +(?P<unknown_unicast>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dynamic +ARP +inspection +drop +counters:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^packets: +(?P<packets>\\d+), +bytes: +(?P<bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +source +guard +drop +counters:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^List +of +Access +VFIs:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Error: +(?P<error>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>EVPN): neighbor +(?P<neighbor>\\S+), +PW +ID: +(?P<pw_id>evi +\\d+), +ac-id +(?P<ac_id>\\d+), +state +is +(?P<state>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +address +(?P<source_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LSP *: +(?P<lsp>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Forward-class: +(?P<forward_class>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multicast +Source: +(?P<multicast_source>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PD +System +Data: +(?P<key_1>\\S+): +(?P<val_1>\\S+) +(?P<key_2>\\S+): +(?P<val_2>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Virtual +MAC +addresses:$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show lag",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<system_priority>[\\w]+) +(?P<system_id_mac>[\\w\\.\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bundle-Ether *(?P<bundle_id>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Status: +(?P<oper_status>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +links.*: *(?P<active>[\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +bandwidth.*: *(?P<effective>[\\d]+) *(\\/ *|\\()(?P<available>[\\d]+)\\)?.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC address.*: *(?P<mac_address>[\\w.-]+) +\\((?P<mac_address_source>.*)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Inter-chassis +link: *(?P<inter_chassis_link>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Minimum +active +links.*: *(?P<min_active_link>[\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +active +links: *(?P<max_active_link>[\\d]+).*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Wait( +|-)while +timer: *(?P<wait_while_timer_ms>[\\d]+).*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Load( +|-)balancing: *(?P<load_balance>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +order +signaling: *(?P<link_order_signaling>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hash +type: *(?P<hash_type>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Locality +threshold: *(?P<locality_threshold>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LACP: *(?P<lacp>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flap +suppression +timer: *(?P<flap_suppression_timer>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Cisco +extensions: *(?P<cisco_extensions>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Non-revertive: *(?P<non_revertive>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^mLACP: *(?P<mlacp>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Interchassis|ICCP) +group: *(?P<iccp_group>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Role: *(?P<role>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Foreign +links.*: *(?P<foreign_links_active>[\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Switchover +type: *(?P<switchover_type>[\\w\\s\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Recovery delay: *(?P<recovery_delay>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximize +threshold: *(?P<maximize_threshold>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>[\\w]+) +BFD: *(?P<ip_bfd>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: *(?P<state>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Fast +detect: *(?P<fast_detect>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Start +timer: *(?P<start_timer>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor-unconfigured +timer: *(?P<neighbor_unconfigured_timer>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Preferred +min +interval: *(?P<preferred_min_interval_ms>[\\d]+).*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Preferred +multiple: *(?P<preferred_multiple>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Destination +address: *(?P<destination_address>[\\w\\s\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\S]+) +(?P<device>[\\S]+) +(?P<state>[\\w]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<link_state>[\\S\\s]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: *(?P<state>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Fast +detect: *(?P<fast_detect>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Start +timer: *(?P<start_timer>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor-unconfigured +timer: *(?P<neighbor_unconfigured_timer>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Preferred +min +interval: *(?P<preferred_min_interval_ms>[\\d]+).*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Preferred +multiple: *(?P<preferred_multiple>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Destination +address: *(?P<destination_address>[\\w\\s\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bundle-Ether(?P<bundle_id>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\S]+) +(?P<rate>[\\d]+)s +(?P<state>[\\w-]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\S]+) +(?P<receive>[\\w]+) +(?P<period>[\\w]+) +(?P<selection>[\\w]+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show lldp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Status: +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LLDP( +advertisements +are +sent +every +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +Interface: +(?P<local_interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Chassis +id: +(?P<chassis_id>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +id: +(?P<port_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +Description(\\:|\\s\\-) +(?P<port_description>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)System +Name: +(?P<system_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^System +Description:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<system_description>Cisco +[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<copyright>Copyright +\\(c\\) +[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<compiled_by>Compiled +[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<technical_support>(Technical|TAC) (S|s)upport: +[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Time +remaining: +(?P<time_remaining>\\d+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Hold +Time: +(?P<hold_time>\\d+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)System +Capabilities: +(?P<system>[\\w+,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Enabled +Capabilities: +(?P<enabled>[\\w+,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)IPv4 +address: +(?P<management_address>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Total +entries +displayed: +(?P<total_entries>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Peer +MAC +Address: +(?P<mac>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +frames +(in: +(?P<frame_in>\\d+))?(out: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Total +entries +aged: +(?P<entries_aged_out>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Total +TLVs +(discarded: +(?P<tlv_discard>\\d+))?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\w\\/\\-\\.]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Tx: (?P<tx>\\w+))?(Rx: (?P<rx>\\w+))?(Tx +state: +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show logging",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)Syslog +logging: +(?P<enable_disable>\\S+) +\\(+(?P<messages_dropped>\\d+) +messages +dropped, +((?P<messages_rate_limited>\\d+) +messages +rate-limited, +)?(?P<flushes>\\d+) +flushes, +(?P<overruns>\\d+) +overruns(, +xml +(?P<xml>\\S+), filtering +(?P<filtering>\\S+))?\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<tag>Console) +logging: +(?P<status>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<tag>Monitor) +logging: +level +(?P<level>\\S+), +(?P<messages_logged>\\d+) +messages +logged(, +xml +(?P<xml>\\S+),)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)filtering +(?P<filtering>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<tag>Buffer) +logging: +level +(?P<level>\\S+), +(?P<messages_logged>\\d+) +messages +logged(, +xml +(?P<xml>\\S+),)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Exception +Logging: size +\\((?P<size_bytes>\\d+) +bytes+\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Count +and +timestamp +logging +messages: +(?P<count_and_time_stamp_logging_messages>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<tag>File +logging): +(?P<status>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<tag>Persistent +logging): +(?P<status>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<tag>Trap +logging): +level +(?P<level>\\S+),( +(?P<messages_logged>\\d+) +messages +logged)?( +(?P<message_lines_logged>\\d+) +message +lines +logged)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Logging +to (?P<logging_to>[\\d\\.]+) +\\((?P<protocol>\\S+) +port +(?P<port>\\d+), +audit +(?P<audit>\\S+),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)link +(?P<link>\\S+)\\),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<message_lines_logged>\\d+) +message +lines +logged,$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<message_lines_rate_limited>\\d+) +message +lines +rate-limited,$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<message_lines_dropped_by_md>\\d+) +message +lines +dropped-by-MD,$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)xml +(?P<xml>\\S+), +sequence +number +(?P<sequence_number>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Logging Source-Interface: +VRF +Name:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<interface>\\S+)+(?P<vrf>\\S+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Log +Buffer +\\((?P<vrf>\\d+) +bytes+\\):$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show mld",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Robustness +Value +(?P<robustness_value>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No\\. +of +Group +x +Interfaces +(?P<num_groups_x_intf>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +number +of +Group +x +Interfaces +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Supported +Interfaces +: +(?P<supported_intf>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unsupported +Interfaces +: +(?P<unsupported_intf>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enabled +Interfaces +: +(?P<enabled_intf>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Disabled +Interfaces +: +(?P<disabled_intf>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTE +tuple +count +: +(?P<mte_tuple_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +Number +Max +# +On +Parent +Last +Last +IGMP +R$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s|\\sGroups +Groups +query +Report +Uptime$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\w\\-\\.\\/]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>[\\w\\-\\.\\/]+) +is +(?P<intf_status>[\\w\\s]+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Internet +address +is +(?P<ip>[\\w\\/\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +is +(?P<status>\\w+) +on +interface$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current +MLD +version +is +(?P<ver>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +query +interval +is +(?P<query_interval>\\d+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +querier +timeout +is +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +max +query +response +time +is +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +member +query +response +interval +is ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +activity: +(?P<joins>\\d+) +joins, +(?P<leaves>\\d+) +leaves$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +querying +router +is +(?P<querier>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time +elapsed +since +last +query +sent +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time +elapsed +since +IGMP +router +enabled +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time +elapsed +since +last +report +received +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface: +(?P<intf>[\\w\\.\\-\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group: +(?P<group>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Host +mode: +(?P<host_mode>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Uptime: +(?P<up_time>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router +mode: +(?P<router_mode>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +reporter: +(?P<last_reporter>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Suppress: +(?P<suppress>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +Address +Uptime +Expires +Fwd +Flags$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<source>(?!No)[\\w\\.\\:]+) +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show mpls",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)Range +for +dynamic +labels: +Min/Max: +(?P<min_range>\\d+)/(?P<max_range>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer +LDP +(Ident|Identifier): *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TCP +connection: *(?P<tcp_connection>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Graceful +Restart: +(?P<graceful_restart>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Session Holdtime: +(?P<session_holdtime>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Password: +(?P<password>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: *(?P<state>\\w+); +Msgs +sent\\/rcvd:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Up +time: *(?P<up_time>[\\w\\:]+)(; ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<address_family>(IPv4|IPv6)): +\\((?P<number>\\d)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<interface>[A-Za-z-]+[\\d/.]+)((,|;)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Targeted +Hello +\\(?(?P<ldp_ip>[\\d/.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^holdtime: *(?P<holdtime>(\\d+|\\w+)) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<address_bound_peer_ldp>[\\d\\.\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer +holdtime: *(?P<peer_holdtime>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Clients: +(?P<clients>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Inbound +label +filtering: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(LDP +Session +Protection:? )?(E|e)nabled, +state: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(D|d)uration: +(?P<duration>(\\d+|\\w+)) *(seconds)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(LDP\\s+)?NSR: +(?P<nsr>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Capabilities+(\\sSent)?:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(Capabilities\\s+)?Received:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<key>\\S+) +\\((?P<value>MP: +\\S+ +\\(\\S+\\))\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<key>\\S+) +\\((?P<value>Typed +Wildcard +FEC)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Up +time: *(?P<up_time>[\\w\\:]+)(; +UID: *(?P<uid>\\d+); +Peer +Id +(?P<peer_id>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<peer>[\\d\\.:]+)\\s+(?P<gr>[\\w]+)\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<peer>[\\d\\.:]+) +(?P<gr>[\\w]+) +(?P<up_time>[\\d\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<peer>[\\d\\.:]+) +(?P<gr>(\\w+)) +(?P<nsr>(\\w+)) +(?P<up_time>[\\d\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<table>\\d+\\s+)?(?P<label>\\d+\\s+)?(?P<owner>[\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\((?P<label_type>[\\S\\s]+),\\s+vers:(?P<vers>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\((?P<sr_label_type>[\\S\\s]+),\\s+vers:(?P<vers>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\((?P<label_type>[\\S\\s]+),\\s+vers:(?P<vers>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+) +(?P<ldp>No|Yes) +(?P<tunnel>No|Yes) +(?P<static>No|Yes) +(?P<enabled>No|Yes)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<local_label>\\d+) +)?(?P<outgoing_label>\\S+) +(?P<prefix_or_id>.+?) +(?P<outgoing_interface>\\S+) +(?P<next_hop>\\S+) +(?P<bytes_switched>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<local_label>\\d+) +(?P<outgoing_label>\\S+) +(?P<prefix_or_id>.+?) +\\\\$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<outgoing_interface>\\S+) +((?P<next_hop>\\S+) +)?(?P<bytes_switched>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<outgoing_interface>\\S+) +(?P<next_hop>\\S+) +\\\\$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<bytes_switched>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show mrib",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*\\((?P<source_address>(\\S+))\\,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RPF +nbr: +(?P<rpf_nbr>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Flags: (?P<flags>[a-zA-Z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Up: +(?P<uptime>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MT +Slot: +(?P<mt_slot>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MVPN +TID: +(?P<mvpn_tid>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MVPN +Remote +TID:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MVPN +Payload: +(?P<mvpn_payload>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MDT +IFH: +(?P<mdt_ifh>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Incoming Interface List$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Outgoing Interface List$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MRIB +Route +Summary +for +VRF +(?P<vrf>(\\S+))\\s*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*No\\. +of +group +ranges +=\\s+(?P<no_group_ranges>[0-9]+)\\s*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*No\\. +of +\\(\\*,G\\) +routes +=\\s+(?P<no_g_routes>[0-9]+)\\s*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*No\\. +of +\\(S,G\\) +routes +=\\s+(?P<no_s_g_routes>[0-9]+)\\s*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*No\\. +of +Route +x +Interfaces +\\(RxI\\) +=\\s+(?P<no_route_x_interfaces>[0-9]+)\\s*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Total +No\\. +of +Interfaces +in +all +routes +=\\s+(?P<total_no_interfaces>[0-9]+)\\s*$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show ntp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<mode_code>[x\\*\\#\\+\\- ])?(?P<configured>[\\~])? *(?P<remote>[\\w\\.\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mode_code>[x\\*\\#\\+\\- ])?(?P<configured>[\\~])? *(?P<remote>[\\w\\.\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<refid>[\\w\\.]+) +(?P<stratum>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Clock +is +(?P<clock_state>\\w+), +stratum",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Clock +is +(?P<clock_state>\\w+), +stratum",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^nominal +freq +is +(?P<nom_freq>[\\d\\.]+) +Hz,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ntp +uptime +is +(?P<uptime>[\\d\\s\\w\\/\\(\\)]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^reference +time +is +(?P<reftime>[\\w\\s\\.\\:\\(\\)]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^clock +offset +is +(?P<offset>[\\d\\.\\-]+) +msec,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^root +dispersion +is +(?P<rootdispersion>[\\d\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^loopfilter +state +is +(?P<leap_status>[\\",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^system +poll +interval +is +(?P<poll>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^system +poll +interval +is +(?P<poll>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>\\w+)( +vrf +(?P<vrf>\\S+))? +(?P<address>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^source +(?P<intf>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show pim",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*(?P<var>(\\*))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PIM +interfaces +in +VRF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +PIM +Multicast +Interface +State$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>(\\S+)) *(?P<oper_status>(on|off)) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Primary +Address *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address *: +(?P<address>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flags *: +(?P<flags>[a-zA-Z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BFD *: (?P<enable>(Off|On))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DR *: (?P<dr>[\\s\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Propagation +delay *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Override +Interval *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello +Timer *: +(?P<hello_expiration>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +Filter *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ISIS +Mcast +Topology",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MoFRR +Flow-based",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MoFRR +RIB +(?P<status>[a-zA-Z0-9\\s\\_\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RUMP +MuRIB +(?P<status>[a-zA-Z0-9\\s\\_\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +RPFs +registered +with",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Default +RPF +Table:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RIB +Convergence +Timeout +Value:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RIB +Convergence +Time Left:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multipath +RPF +Selection +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Table: +(?P<table>[a-zA-Z0-9\\s\\_\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +RPF +Registrations += (?P<var>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RIB +Table",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show platform",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)\\s*Cisco +IOS +XR +Software, +Version",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*.* +uptime +is +(?P<uptime>[a-zA-Z0-9\\s\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*System +image +file +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*cisco +(?P<device_family>[a-zA-Z0-9\\-\\s]+) +\\(\\) +processor$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^cisco +(?P<device_family>[a-zA-Z0-9\\/\\-\\s]+)(?:( +Series))? +\\((?P<processor>[a-zA-Z0-9\\s]+)\\) +processor +with +(?P<processor_memory_bytes>[0-9A-Z]+) +bytes +of +memory.$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Configuration +register +on +node",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*.*Chassis.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(SDR_id|SDR ID) *: +(?P<sdr_id>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(SDR_name|SDR name) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*dSDRsc +node *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*dSDRsc +partner +node *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(primary +node1|SDR +lead +\\(Primary\\)) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(primary +node2|SDR +lead +\\(Backup\\)) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*mac +addr *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<type>[a-zA-Z0-9\\-]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<node>[a-zA-Z0-9\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<node>[\\S\\/]+) +(?P<type>[(RP|LC)\\s*\\((ACTIVE|STANDBY)\\)]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*SDRs:*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Active +Packages:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*SDRs:*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Inactive +Packages:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*SDRs:*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Committed +Packages:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Active +Packages:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NAME: +\\\"(?P<module_name>[\\S\\s]*)\\\", +DESCR: +\\\"(?P<descr>[\\S\\s]*)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PID: *(?P<pid>[\\S\\s]*), +VID: *(?P<vid>[\\S\\s]*), SN: *(?P<sn>[\\S\\s]*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Rack +(?P<rack_num>\\d+) +- +(?P<device_group>[a-zA-Z0-9\\s]+) +(?P<num_line_cards>\\d+) +((Line +Card +Slot +Chassis +with *)|Slots +Line +Card +Chassis(?:( +for))? *)(?P<chassis_feature>[\\S ]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)RACK NUM\\: *(?P<rack_num>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(S\\/N|((Chassis|PCB) +)?Serial +Number)(\\s+)?(\\:)? +(?P<serial_number>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(PID|Product ID)(\\s+)?\\: +(?P<pid>[a-zA-Z0-9\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?:VID|Version +Identifier)(\\s+)?\\: +(?P<vid>[a-zA-Z0-9\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Desc\\:|UDI Description\\s+:) *(?P<desc>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)CLEI( +Code\\s+)?: +(?P<clei>[a-zA-Z0-9\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Top +Assy. +Number\\: *(?P<top_assy_num>[a-zA-Z0-9\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PCA\\: +(?P<pca>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ECI\\: +(?P<eci>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAIN\\: +board +type +(?P<board_type>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\S+ +rev +\\S+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*dev +(?P<dev>[\\S ]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?:[0-9]+ +)?Rack +(?P<rack_num>[0-9]+)-(Chassis )?IDPROM +Info$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Top +Assembly +Block\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Part +(n|N)umber(\\s+)?\\: +(?P<part_number>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Top +Assy\\. +Part +Number +: +(?P<part_number>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Top +Assy\\. +Revision\\s+: *(?P<revision>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Part +(r|R)evision(\\s+)?\\: +(?P<part_revision>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^H\\/W +[v|V]ersion(\\s+)?\\: +(?P<hw_version>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[M|m]fg +[D|d]eviation(\\s+)?\\: +(?P<mfg_deviation>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[M|m]fg +Bits(\\s+)?\\: +(?P<mfg_bits>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Controller\\s+Family\\s+:\\s+(?P<controller_family>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Controller\\s+Type\\s+:\\s+(?P<controller_type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Active.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<node>[a-zA-Z0-9\\/\\(\\)]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<node>[a-zA-Z0-9\\/\\(\\)]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Redundancy +information +for +node",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Node +([a-zA-Z0-9\\/]+) +is +in",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Node *Redundancy *Partner",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Process *Redundancy *Partner",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Standby *node *in *([a-zA-Z0-9\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Node +([a-zA-Z0-9\\/]+) +has +(?P<valid_partner>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<group>[a-zA-Z0-9\\-]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*NSR +(?P<primary_rmf_state>[a-zA-Z\\s]+) +since",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<node_name>[a-zA-Z0-9\\-]+) +reloaded",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Active +node +booted",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Standby +node +boot",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Standby *node *last *went *not *ready",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Standby *node *last *went *ready",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Last +switch-over",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Active +node +reload *(?:Cause)?:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Directory +of",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<total_bytes>[0-9]+ +(kbytes|bytes))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<index>[0-9]+) +(?P<permission>[a-z\\-]+)(\\.)?(",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show processes",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^----\\s+(?P<location>\\S+)\\s+----$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show protocol",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Routing +Protocol +(?P<pro>OSPF|OSPFv3) +(?P<pid>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router +Id: +(?P<router_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Distance: +(?P<distance>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Distance: +IntraArea +(?P<intra>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Non-Stop +Forwarding:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>(connected|static))(?: +with +metric",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?!Area)(?P<prot>\\w+) +(?P<pid>\\d+)(?: +with",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +(?P<area>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MPLS\\/TE +(?P<te>(enabled|disabled))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>(Lo|Gi|Te|Bu)[\\w\\/\\.\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routing +Protocol +\\\"BGP +(?P<bgp_pid>\\d+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Non-stop +routing +is +(?P<nsr>(enabled|disabled))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Graceful restart is not +enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current +BGP +NSR +state +\\-",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address +Family +(?P<af>[\\w\\s\\-]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Distance: +external +(?P<external>\\d+) +internal",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nbr>[\\d\\:\\.]+) +(?P<last_update>[\\w\\:]+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show rib",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<vrf>\\S+)\\/(?P<table>\\w+) +(?P<safi>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Summary\\sof.+in +(?P<rib>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number of unicast tables:\\s+(?P<uni_tbl>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total number of unicast prefixes:\\s+(?P<uni_pfx>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number of multicast tables:\\s+(?P<multi_tbl>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total number of multicast prefixes:\\s+(?P<multi_pfx>\\d+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show rip",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^RIP +config:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active\\??:\\s+(?P<active>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Added +to +socket\\??:\\s+(?P<added_to_socket>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Out-of-memory +state:\\s+(?P<memory_state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Version:\\s+(?P<version>[\\d.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Default +metric:\\s+(?P<default_metric>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +paths:\\s+(?P<max_paths>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auto +summarize\\??:\\s+(?P<auto_summarize>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Broadcast +for +V2\\??:\\s+(?P<broadcast>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Packet +source +validation\\??:\\s+(?P<packet_validation>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NSF:\\s+(?P<nsf>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timers: +Update:\\s+(?P<update_timer>\\d+) +seconds +\\((?P<next_update>\\d+)[\\s\\w]+\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Invalid:\\s+(?P<invalid_timer>\\d+)[\\s\\w]+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Holddown:\\s+(?P<holddown_timer>\\d+)[\\s\\w]+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flush:\\s+(?P<flush_timer>\\d+)[\\s\\w]+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RIP +statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +messages +sent:\\s+(?P<number_of_messages>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Message +send +failures:\\s+(?P<number_of_failures>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Regular +updates +sent:\\s+(?P<number_of_updates>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Queries +responsed +to:\\s+(?P<number_of_queries>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RIB +updates:\\s+(?P<number_of_rib_updates>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +packets +received:\\s+(?P<packets_received>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Discarded +packets:\\s+(?P<discarded_packets>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Discarded +routes:\\s+(?P<discarded_routes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Packet +received +at +standby:\\s+(?P<packets_received>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +routes +allocated:\\s+(?P<number_of_routes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +paths +allocated:\\s+(?P<number_of_paths>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +malloc +failures:\\s+(?P<route_malloc_failures>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Path +malloc +failures:\\s+(?P<path_malloc_failures>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<route>[\\w\\.\\/:]+)(\\s+(?P<summary_type>[\\(\\)\\w-]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[(?P<metric>\\d+)\\]\\s+directly +connected, +(?P<interface>[\\w\\d/\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[(?P<metric>\\d+)\\]\\s+distance: +(?P<distance>\\d+)\\s+redistributed$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[(?P<metric>\\d+)\\] +via +[\\d\\.]+, +next +hop +(?P<next_hop>[\\d\\.]+), +Uptime: +(?P<up_time>\\w+), +(?P<interface>[\\w\\d/\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\w+[\\d\\/]+\\.?\\d+)(?: +\\([\\S\\s]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rip +enabled\\?:\\s+(?P<passive>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Out-of-memory +state:\\s+(?P<state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Broadcast +for +V2:\\s+(?P<broadcast>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Accept +Metric +0:\\s+(?P<accept_metric>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Send +versions:\\s+(?P<version>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Receive +versions:\\s+(?P<version>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +state:\\s+(?P<state>[\\w ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +address:\\s+(?P<ip_address>[\\d\\/\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric +Cost:\\s+(?P<cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Split +horizon:\\s+(?P<split_horizon>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Poison +Reverse:\\s+(?P<poison_reverse>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Socket +set +options:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Joined +multicast +group:\\s+(?P<joined>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LPTS +filter +set:\\s+(?P<filter_set>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Authentication +mode:\\s+(?P<mode>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Authentication +keychain:\\s+(?P<keychain>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +packets +received:\\s+(?P<packets_received>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RIP +peers +attached +to +this +interface:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<peer_address>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^uptime \\(sec\\): +(?P<uptime>\\d+)\\s+version: +(?P<version>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)packets +discarded: +(?P<packets_discarded>\\d+)\\s+routes +discarded: +(?P<routes_discarded>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show routing",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*VRF: +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<code1>[\\w](\\*)*)\\s*(?P<code2>\\S+)? +(?P<network>\\S+) +\\[(?P<route_preference>\\d+)\\/(?P<metric>\\d+)\\] +via +(?P<next_hop>\\S+)( +\\(nexthop +in +vrf +\\w+\\))?,( +(?P<date>[\\w:]+),?)?( +(?P<interface>[\\w\\/\\.\\-]+))?( +(?P<code3>[\\w\\*\\(\\>\\)\\!]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[(?P<route_preference>\\d+)\\/(?P<metric>\\d+)\\] +via +(?P<next_hop>\\S+),( +(?P<date>[\\w:]+))?,? +(?P<interface>[\\w\\/\\.\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<code1>[\\w])\\s*(?P<code2>\\S+)?(\\s+(?P<network>\\S+)\\s+))?(is\\s+directly\\s+connected,\\s+(?P<date>[\\w:]+))?,?\\s+(?P<interface>[\\w\\/\\.\\-]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routing +entry +for +(?P<network>(?P<ip>[\\w\\:\\.]+)\\/(?P<mask>\\d+))(?:, +(?P<net>[\\w\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Known +via +\\\"(?P<known_via>[\\w ]+)\\\", +distance +(?P<distance>\\d+), +metric +(?P<metric>\\d+)( \\(connected\\))?(, +type +(?P<type>[\\S\\s]+))?(, +candidate +default +path)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(\\* +)?directly +connected, via +(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +metric +is +(?P<metric>\\d+)(, +traffic +share +count +is +(?P<share_count>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<redist_advertiser>\\S+) +\\(protoid=(?P<protoid>\\d+), +clientid=(?P<clientid>\\d+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Installed +(?P<date>[\\S\\s]+) +for +(?P<for>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nexthop>\\S+),\\s+from\\s+(?P<from>\\S+)(, +via\\s+(?P<interface>\\S+))?(, +BGP external)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((\\S+#)?(show +route))|(Routing +Descriptor +Blocks)|(No +advertising +protos\\.)|(Redist +Advertisers:)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tag\\s+(?P<tag>\\d+)\\,\\s+type\\s+(?P<type>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Nexthop\\s+in\\s+[V|v]rf\\:\\s+\\\"(?P<interface>\\w+)\\\"\\, +[T|t]able\\:\\s+\\\"(?P<table>\\w+)\\\"\\, +(?P<address_family>[\\w\\s]+)\\,\\s+[T|t]able +[I|i]d\\:\\s+(?P<table_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Gateway +of +last +resort +is +(?P<gateway>(not +set)|\\S+)( +to +network +(?P<to_network>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VRF: +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<code1>[\\w](\\*)*)(\\s*)?(?P<code2>\\w+)? +(?P<network>\\S+))?( +is +directly +connected\\,)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\[(?P<route_preference>\\d+)\\/(?P<metric>\\d+)\\] +via +(?P<next_hop>\\S+)( +\\(nexthop +in +vrf +\\w+\\))?,( +(?P<date>[\\w:]+))?,?( +(?P<interface>[\\w\\/\\.\\-]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<date>[\\w+:]+), +(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routing +entry +for +(?P<network>(?P<ip>[\\w\\:\\.]+)\\/(?P<mask>\\d+))(?:, +(?P<net>[\\w\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Known +via +\\\"(?P<known_via>[\\w ]+)\\\", +distance +(?P<distance>\\d+), +metric +(?P<metric>\\d+)( \\(connected\\))?(, +type +(?P<type>\\S+))?(, +candidate +default +path)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(\\* +)?directly +connected, via +(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +metric +is +(?P<metric>\\d+)(, +traffic +share +count +is +(?P<share_count>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<redist_advertiser>\\S+) +\\(protoid=(?P<protoid>\\d+), +clientid=(?P<clientid>\\d+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Installed +(?P<date>[\\S\\s]+) +for +(?P<for>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nexthop>\\S+), from +(?P<from>\\S+), +via +(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((\\S+#)?(show +route))|(Routing +Descriptor +Blocks)|(No +advertising +protos\\.)|(Redist +Advertisers:)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Gateway +of +last +resort +is +(?P<gateway>(not +set)|\\S+)( +to +network +(?P<to_network>\\S+))?$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show rpl",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*route-policy +(?P<name>[\\w\\W\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*# *(?P<description>[a-zA-Z\\W]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*# *(?P<statements>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +med +(?P<set_med>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +origin +(?P<set_route_origin>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +local-preference +(?P<set_local_pref>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +next-hop +(?P<set_next_hop>[0-9\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<set_next_hop_self>(self))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*prepend +as-path +(?P<set_as_path_prepend>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +community +(?P<set_community_list>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +community +(?P<set_community_list>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +community +\\((?P<set_community>[0-9\\:\\s\\,]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +community +\\((?P<set_community>[0-9\\:\\s\\,]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +community +\\((?P<set_community>[0-9\\:\\s\\,]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +community +\\((?P<set_community>[0-9\\:\\s\\,]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +community +\\((?:(?P<set_community>[0-9\\:\\s\\,]+),)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*delete +community *in",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +extcommunity +rt",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set extcommunity +soo",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*delete +extcommunity +rt *in",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +level +(?P<set_level>[a-z0-9\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +metric-type +(?P<set_metric_type>[a-z0-9\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +isis-metric +(?P<set_metric>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +ospf-metric +(?P<set_ospf_metric>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +weight +(?P<set_weight>[0-9\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +tag +(?P<set_tag>[0-9\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*set +spf-priority +(?P<spf_priority>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<actions>(pass|done|drop))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(if|elseif|else) *(?P<condition1>\\S+ \\S+ \\S+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show run",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^key +chain +(?P<key_chain_name>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^key +(?P<key_name>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^accept-lifetime +(?P<accept_lifetime>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^key-string +(?P<key_string>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^send-lifetime +(?P<send_lifetime>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^cryptographic-algorithm +(?P<cryptographic_algorithm>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^accept-tolerance +(?P<accept_tolerance>(\\w+)) !$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*!+\\s*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*router\\sisis\\s+(?P<isis_name>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*segment-routing\\s+(?P<segment_routing_key>\\S+)\\s+(?P<segment_routing_value>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*lsp-gen-interval\\s+(?P<lsp_gen_interval>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*address-family\\s+(?P<address_family>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*interface\\s+(?P<interface>\\S+)\\s*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<generic_key>\\S+)\\s+(?P<generic_value>.+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show segment_routing",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^SRMS \\w+ policy for Process ID (?P<process_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS-IS (?P<isis_id>\\d+) (?P<status>\\w+) policy$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<prefix>[\\w\\.\\/]+)\\s+(?P<sid_index>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Number of mapping entries:\\s+(?P<entries>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SRMS (?P<status>\\w+) policy for Process ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<prefix>[\\w\\.\\/]+)\\s+(?P<sid_index>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Number of mapping entries:\\s+(?P<entries>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer address: (?P<address>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: (?P<state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Capabilities: (?P<stateful>\\w+)\\,\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer address: (?P<address>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: (?P<state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Capabilities: (?P<stateful>\\w+)\\,\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PCEP has been up for: (?P<pcep_up_time>[\\w+\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PCEP session ID: local (?P<local_id>\\d+)\\, remote ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sending KA every (?P<ka_time_intervals>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Minimum acceptable KA interval: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer timeout after (?P<peer_timeout>\\d+)\\sseconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Keepalive messages:\\s+rx\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Request messages:\\s+rx\\s+(?P<request_messages_rx>",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Reply messages:\\s+rx\\s+(?P<reply_messages_rx>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Error messages:\\s+rx\\s+(?P<error_messages_rx>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Open messages:\\s+rx\\s+(?P<open_messages_rx>\\d+)\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Report messages:\\s+rx\\s+(?P<report_messages_rx>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Update messages:\\s+rx\\s+(?P<update_messages_rx>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Initiate messages:\\s+rx\\s+(?P<initiate_messages_rx>",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Node (?P<node_number>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TE router ID: (?P<router_id>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Host name: (?P<host_name>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ISIS system ID: (?P<system_id>[\\w\\.]+\\s+level-\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<adv_prefixes>\\d+\\.\\d+\\.\\d+\\.\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology nodes:\\s+(?P<topology_nodes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefixes:\\s+(?P<prefixes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefix +SIDs: +(?:(?P<prefix_sids>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Links: +(?:(?P<links>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adjacency +SIDs: +(?:(?P<adjacency>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total: +(?P<total>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Regular: +(?P<regular>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Strict: +(?P<strict>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EPE: +(?P<epe>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unprotected: +(?P<unprotected>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Protected: +(?P<protected>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Lookup +Nodes +(?P<lookup>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Consistent +(?P<consistent>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Noded +added: +(?P<added>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Noded +deleted: +(?P<deleted>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Links +added: +(?P<added>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Links +deleted: +(?P<deleted>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefix +added: +(?P<added>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefix +deleted: +(?P<deleted>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PCC (?P<pcc_id>[\\d\\.]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tunnel Name: (?P<tunnel_name>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LSP\\[(?P<lsp_number>\\d+)\\]:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^source (?P<lsp_source>[\\d\\.]+), destination ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)State: Admin (?P<admin_state>\\w+), Operation ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Setup type: (?P<setup_type>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Binding SID: (?P<binding_sid>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PCC (?P<pcc_id>[\\d\\.]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tunnel Name: (?P<tunnel_name>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LSP\\[(?P<lsp_number>\\d+)\\]:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^source (?P<lsp_source>[\\d\\.]+), destination ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)State: Admin (?P<admin_state>\\w+), Operation ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Setup type: (?P<setup_type>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Binding SID: (?P<binding_sid>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^plsp-id (?P<plsp_id>\\d+), flags: D:(?P<d_flag>\\d+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<specified_path>\\w+) path:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric type: (?P<metric_type>\\w+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SID\\[(?P<sid_number>\\d+)\\]: (?P<sid_type>\\w+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<event_time>\\w+ \\d+ \\d+ [\\d\\:]+)\\s+ ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Symbolic-name: (?P<symbolic_name>\\w+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source: (?P<event_source>[\\d\\.]+) Destination: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^D:(?P<d_event>\\d+), R:(?P<r_event>\\d+), ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Peer: (?P<event_peer>[\\d\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<inconsistency_type>\\w+) inconsistencies range: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<prefix>[\\w\\.\\/]+)\\s+(?P<sid_index>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Number of mapping entries:\\s+(?P<entries>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<prefix>\\d+\\.\\d+\\.\\d+\\.\\d+\\/\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SID Index:\\s+(?P<sid_index>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Range:\\s+(?P<range>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last Prefix:\\s+(?P<last_prefix>[\\d\\.\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last SID Index: (?P<last_sid_index>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flags:\\s+(?P<flags>\\w+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show spanning_tree",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^MSTI +(?P<mst_id>\\d+)([\\s\\S]+)?:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VLANS +Mapped: +(?P<vlan>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CIST\\s+Root\\s+Priority\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address\\s+(?P<address>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Ext\\s+Cost\\s+(?P<cist_root_cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root\\s+ID\\s+Priority\\s+(?P<designated_root_priority>",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Int\\s+Cost\\s+(?P<root_cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Max\\s+Age\\s+(?P<max_age>\\d+)\\s+sec,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Max\\s+Hops\\s+(?P<bridge_max_hops>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge\\s+ID\\s+Priority\\s+(?P<bridge_priority>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+)\\s+(?P<port_priority>\\d+)\\.",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)This +bridge +is +(?P<this_bridge_is>[\\w ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mag_interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Pre(\\-)?empt +delay +is +(?P<preempt_delay>\\w+)\\.?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Name:\\s+(?P<name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Revision:\\s+(?P<revision>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Max Age:\\s+(?P<max_age>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Provider +Bridge:\\s+(?P<provider_bridge>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge +ID:\\s+(?P<bridge_id>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +ID:\\s+(?P<port_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^External +Cost:\\s+(?P<external_cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello +Time:\\s+(?P<hello_time>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active:\\s+(?P<active>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BPDUs +sent:\\s+(?P<bdpu_sent>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MSTI +(?P<mst_id>\\d+)( +\\(CIST\\))?:?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VLAN +IDs:\\s+(?P<vlans>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge +Priority:\\s+(?P<priority>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +Priority:\\s+(?P<port_priority>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Cost:\\s+(?P<cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root +Bridge:\\s+(?P<root_bridge>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root +Priority:\\s+(?P<root_priority>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology +Changes:\\s+(?P<topology_changes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VLAN +(?P<vlan_id>\\d+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root\\s+ID\\s+Priority\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address\\s+(?P<address>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Max\\s+Age\\s+(?P<max_age>\\d+)\\s+sec,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge\\s+ID\\s+Priority\\s+(?P<bridge_priority>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Transmit\\s+Hold\\s+count\\s+(?P<bridge_transmit_hold_count>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+)\\s+(?P<port_priority>\\d+)\\.",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VLAN\\s+(?P<vlan_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Pre\\-empt +delay +is +(?P<preempt_delay>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sub\\-interface:\\s+(?P<sub_interface>\\S+)\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Max\\s+Age:\\s+(?P<max_age>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root\\s+Priority:\\s+(?P<root_priority>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root\\s+Bridge:\\s+(?P<root_bridge>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Cost:\\s+(?P<root_cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge\\s+Priority:\\s+(?P<bridge_priority>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge\\s+ID:\\s+(?P<bridge_id>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port\\s+Priority:\\s+(?P<port_priority>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port\\s+ID:?\\s+(?P<port_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello\\s+Time:\\s+(?P<hello_time>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active:\\s+(?P<active>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BPDUs\\s+sent:\\s+(?P<bdpu_sent>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology\\s+Changes:\\s+(?P<topology_changes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VLAN\\s+(?P<vlan_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Pre\\-empt +delay +is +(?P<preempt_delay>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sub\\-interface:\\s+(?P<sub_interface>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Max\\s+Age:\\s+(?P<max_age>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root\\s+Priority:\\s+(?P<root_priority>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root\\s+Bridge:\\s+(?P<root_bridge>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Cost:\\s+(?P<root_cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge\\s+Priority:\\s+(?P<bridge_priority>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge\\s+ID:\\s+(?P<bridge_id>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port\\s+Priority:\\s+(?P<port_priority>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port\\s+ID:?\\s+(?P<port_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello\\s+Time:\\s+(?P<hello_time>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active:\\s+(?P<active>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BPDUs\\s+sent:\\s+(?P<bdpu_sent>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology\\s+Changes:\\s+(?P<topology_changes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show ssh",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<id>(\\d+))\\s+(?P<key_exchange>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Incoming Session",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Outgoing connection",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SSH version : (?P<version>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Incoming sessions)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<id>\\d+) +(?P<chan>\\d+) +(?P<pty>\\S+) +(?P<location>\\S+) +(?P<userid>\\S+) +(?P<host>\\S+) +(?P<ver>\\S+) +(?P<authentication>\\S+) +(?P<connection_type>\\S+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show static_routing",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*VRF: +(?P<vrf>[\\w]+) +Table +Id: +(?P<table_id>[\\w]+) +AFI: +(?P<af>[\\w]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<route>[\\d\\s\\/\\.\\:]+)?(?P<interface>[a-zA-Z][\\w\\/\\.-]+) +(?P<nexthop>[\\w\\/\\.\\:]+) +(?P<object>[\\w]+) +(?P<explicit_path>[\\w]+) +(?P<metrics>[\\w\\/\\[\\]]+)(\\s+(?P<local_label>[\\w\\s]+?))?(\\s+(?P<path_event>(Path|Last).*))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<path_event>Path +is +installed +into +RIB +at +(?P<date>[\\S\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<path_event>Path +is +configured +at +(?P<date>[\\S\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<path_event>Path +is +removed +from +RIB +at +(?P<date>[\\S\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<path_event>Last +RIB +event +is +at +(?P<date>[\\S\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Path +version: +(?P<path_version>[\\d]+), +Path +status: +(?P<path_status>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Path +has +best +tag: +(?P<tag>[\\d]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show traffic_collector",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)(?P<interface>^\\w+[\\.\\/\\d]+) +(?P<status>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Prefix: +(?P<prefix>[\\d\\.\\/]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<counters>(Base|TM Counters)):",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Average +over +the +last +(?P<interval>\\d+) +collection ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<time_slot>[\\d\\:\\-\\s]+): +Packets +(?P<packets>\\d+), ",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show vrf",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^VRF +(?P<vrf>[\\w\\-]+); +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRF +mode: +(?P<mode>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Description *(?P<desc>[\\w\\:\\s\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interfaces:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>([G|g]i.*|[B|b]un.*|[T|t]en.*|[P|p]o.*|[V|v]lan.*|[L|l]o.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address +family +(?P<af>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Export +VPN +route\\-target communities:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Import +VPN +route\\-target +communities:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)RT: *(?P<rt>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No +import +route +policy$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Import +route +policy: +(?P<route_map>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No +export +route +policy$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Export +route +policy: +(?P<route_map>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "show xconnect",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Locally Switching$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^AToM$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Like-to-Like.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<item>([a-zA-Z\\-\\/\\s]+)) +(?P<up>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total: +(?P<up>(\\d+)) +UP, +(?P<down>(\\d+)) +DOWN,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group +(?P<group>\\S+), +XC +(?P<xc>\\S+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Monitor\\-Session: +(?P<monitor_session>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^AC: +(?P<ac>\\S+), +state +is +(?P<state>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Type +(?P<type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU +(?P<mtu>\\d+); +XC +ID +(?P<xc_id>\\S+); +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^packet +totals: +send +(?P<send>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^packet +totals: +receive +(?P<receive>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^packets: +received +(?P<received>\\d+), +sent +(?P<send>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^byte +totals: +send +(?P<send>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^byte +totals: +receive +(?P<receive>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^bytes: +received +(?P<received>\\d+), +sent +(?P<send>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^drops: +illegal +VLAN +(?P<illegal_vlan>\\d+), +illegal +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PW: +neighbor +(?P<neighbor>\\S+), +PW +ID +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EVPN: +neighbor +(?P<neighbor>\\S+), +PW +ID: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PW +class +(?P<pw_class>[\\S ]+), +XC +ID +(?P<xc_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Encapsulation +(?P<encapsulation>\\S+)(, +Auto-discovered +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PW +type +(?P<type>\\S+), +control +word +(?P<control_word>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PW +backup +disable +delay +(?P<backup_disable_delay>\\d+) +sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sequencing +(?P<sequencing>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PW +Status +TLV +(?P<status_tlv>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<label_name>MPLS|EVPN) +Local +Remote$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?!(show +l2vpn))[\\S ]+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Create +time: +(?P<create_time>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +time +status +changed: +(?P<last_time_status_changed>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Backup +PW:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^-+ +-+ +-+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\([\\S ]+\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Backup( +PW)? +for +neighbor +\\S+ +PW +ID +\\d+( +\\( +\\w+ +\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(\\w+ +\\w+ \\d+ +\\S+ +\\w+)|(\\S+\\#)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +CE +ID: +(?P<local_ce_id>\\d+), +Remote +CE +ID: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Type +(?P<type>\\S+); +Num +Ranges: +(?P<num_ranges>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VLAN +ranges: +\\[(?P<vlan_ranges>[\\S ]+)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group +(?P<group_name>\\S+), +MP2MP +(?P<mp2mp>\\S+), +state: +(?P<state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VPN +ID: +(?P<vpn_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VPN +MTU: +(?P<vpn_mtu>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^L2 +Encapsulation: +(?P<l2_encapsulation>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auto +Discovery: +(?P<auto_discovery>\\S+), +state +is +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +Distinguisher: +(?P<route_distinguisher>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Import +Route +Targets:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Export +Route +Targets:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<route_target>[\\d\\.:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Signaling +protocol: *(?P<signaling_protocol>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CE +Range: *(?P<ce_range>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[Wed|Thu|Fri|Sat|Sun|Mon|Tue]+ +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Rewrite +Tags: +\\[(?P<rewrite_tags>[\\S ]+)?\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^XC +ID +(?P<xc_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Encapsulation +(?P<encapsulation>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +address +(?P<source_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Encap +type +(?P<encap_type>\\S+), +control +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LSP +: +(?P<lsp>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^L2 +Encapsulation: +(?P<l2_encapsulation>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +Distinguisher: +(?P<route_distinguisher>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<group>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SB = Standby, SR = Standby Ready, \\(PP\\) = Partially Programmed$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<group>\\S+) +(?P<name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>[a-zA-Z0-9]+) +(?P<status_group>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_1>.*?) +(?P<status_seg1>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_2>[\\S ]+) +(?P<status_seg2>(UP|DN|AD|UR|SB|SR|\\(PP\\)))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<status_group>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_1>.*?) +(?P<status_seg1>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_2>[\\S ]+) +(?P<status_seg2>(UP|DN|AD|UR|SB|SR|\\(PP\\)))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<status_group>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_1>.*?) +(?P<status_seg1>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_2>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<status_group>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_1>.*?) +(?P<status_seg1>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_2>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<group>\\S+) +(?P<name>\\S+) +(?P<status_group>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_1>.*?) +(?P<status_seg1>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_2>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<group>\\S+) +(?P<name>\\S+) +(?P<status_group>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_1>.*?) +(?P<status_seg1>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_2>[\\S ]+) +(?P<status_segment2>(UP|DN|AD|UR|SB|SR|\\(PP\\)))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<status_segment2>(UP|DN|AD|UR|SB|SR|\\(PP\\)))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<status_seg1>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_2>[\\S ]+) +(?P<status_seg2>(UP|DN|AD|UR|SB|SR|\\(PP\\)))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<status_group>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_1>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<status_group>(UP|DN|AD|UR|SB|SR|\\(PP\\))) +(?P<segment_1>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +groups: +(?P<number_of_groups>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +xconnects: +(?P<number_of_xconnects>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Up: (?P<up>\\d+) +Down: +(?P<down>\\d+) +Unresolved: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^AC-PW: +(?P<ac_pw>\\d+) +AC-AC: +(?P<ac_ac>\\d+) +PW-PW: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +Admin +Down +segments: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +MP2MP +xconnects: +(?P<number_of_mp2mp_xconnects>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Up +(?P<up>\\d+) +Down +(?P<down>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Advertised: +(?P<advertised>\\d+) +Non-Advertised: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +CE +Connections: +(?P<number_of_ce_connections>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Backup +PW:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Backup +Interface:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\S ]+): +(?P<value>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "iosxr",
        "command": "traceroute",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^traceroute( +vrf +(?P<vrf>\\S+))? +[\\S ]+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tracing +the +route +to +(?P<traceroute>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tracing +MPLS +Label +Switched +Path +to",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tracing +the +route +to +(?P<name_of_address>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<hop>(\\d+)) +)?(?P<address>([a-zA-Z0-9\\.\\:]+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<code>(!|Q|.|L|D|M|P|R|I|X)) +(?P<hop>(\\d+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<hop>(\\d+)) +)?(?P<address>([a-zA-Z0-9\\.\\:]+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<hop>(\\d+)) +)?(?P<address>([a-zA-Z0-9\\.\\:]+))(?: +\\[(?P<label_name>(MPLS))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<hop>(\\d+)) +)?(?P<name>[\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<hop>(\\d+)) +)?(?P<address>\\*)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "monitor",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<hostname>\\S+)\\s+Seconds:\\s+(?P<seconds>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+)\\s+(?P<link>Up|Down)\\s+(?P<input_packets>\\d+)(\\s+\\((?P<input_pps>\\d+)\\))?\\s+(?P<output_packets>\\d+)(\\s+\\((?P<output_pps>\\d+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Time:\\s+(?P<monitor_time>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "ping",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^PING +(?P<address>\\S+) +\\((?P<source>\\S+)\\): +(?P<data_bytes>\\d+) +data +bytes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PING6\\((?P<data_bytes>\\d+)=\\S+ +bytes\\) +(?P<source>\\S+) --> +(?P<address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<bytes>\\d+)\\s+bytes\\s+from\\s+(?P<from>\\S+)(:|,)\\s+icmp_seq=(?P<icmp_seq>\\d+)\\s+(ttl=(?P<ttl>\\d+)|hlim=(?P<hlim>\\d+)) +time=(?P<time>\\S+) +ms$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<bytes>\\d+)\\s+bytes\\s+from\\s+(?P<from>\\S+):\\s+(?P<message>[\\s\\w]+)(\\(MTU\\s|mtu\\s=\\s)(?P<mtu>\\d+)(\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<send>\\d+) +packets +transmitted, +(?P<received>\\d+) +packets +received, +(?P<loss_rate>\\d+)\\% +packet +loss$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^round-trip +min\\/avg\\/max\\/std(\\-)?dev +\\= +(?P<min>[\\d\\.]+)\\/(?P<avg>[\\d\\.]+)\\/(?P<max>[\\d\\.]+)\\/(?P<stddev>[\\d\\.]+) +ms$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<send>\\d+) +packets +transmitted, +(?P<received>\\d+) packets +received, +(?P<loss_rate>\\d+)\\% +packet +loss$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show arp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<mac_address>[\\w:]+) +(?P<ip_address>\\S+) +(?P<hostname>\\S+) +(?P<interface_name>\\S+) +(?P<arp_table_entry_flags>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +entries: +(?P<total_entries>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mac_address>[\\w:]+) +(?P<ip_address>\\S+) +(?P<interface_name>\\S+) +(?P<arp_table_entry_flags>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +entries: +(?P<total_entries>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show bfd",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<session_neighbor>\\S+) +(?P<session_state>\\S+)( +(?P<session_interface>\\S+))? +(?P<session_detection_time>[\\d\\.]+) +(?P<session_transmission_interval>[\\d\\.]+) +(?P<session_adaptive_multiplier>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<session_neighbor>\\S+) +(?P<session_state>\\S+)( +(?P<session_interface>\\S+))? +(?P<session_detection_time>[\\d\\.]+) +(?P<session_transmission_interval>[\\d\\.]+) +(?P<session_adaptive_multiplier>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Client +(?P<client_name>\\S+), +TX +interval (?P<client_transmission_interval>\\S+), +RX +interval (?P<client_reception_interval>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Session +up +time +(?P<session_up_time>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +diagnostic +(?P<local_diagnostic>\\S+), remote +diagnostic +(?P<remote_diagnostic>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +state +(?P<remote_state>\\S+), +version +(?P<session_version>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Session +type: +(?P<session_type>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<sessions>\\S+) +sessions, +(?P<clients>\\S+) +clients$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Cumulative transmit rate (?P<cumulative_reception_rate>\\S+) pps, cumulative receive rate (?P<cumulative_transmission_rate>\\S+) pps$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show bgp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Name: +(?P<name>\\S+) +Index: +(?P<index>\\d+) +Flags: +\\<(?P<flags>[\\S ]+)\\>$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Export: +\\[ +(?P<export>(\\()?[\\S ]+(\\))?) +\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Options: +\\<(?P<options>Confed|Cluster +Confed|Multihop Confed)\\>$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Options: +\\<(?P<options>GracefulShutdownRcv)\\>$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Holdtime: +(?P<holdtime>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Graceful +Shutdown +Receiver +local-preference: +(?P<gshut_recv_local_preference>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +peers: +(?P<total_peers>\\d+) +Established: +(?P<established>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Table +(?P<name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active +prefixes: +(?P<active_prefix_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RIB +State: +(?P<rib_state>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<type>Internal|External) +(?P<peer_count>\\d+) +(?P<established_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>inet(\\d+)?\\.\\d+) *: +(?P<active_prefix_count>\\d+)\\/(?P<received_prefix_count>\\d+)\\/(?P<accepted_prefix_count>\\d+)\\/(?P<suppressed_prefix_count>\\d+) +External: +(?P<active_external_prefix_count>\\d+)\\/(?P<total_external_prefix_count>\\d+)\\/(?P<accepted_external_prefix_count>\\d+)\\/(?P<suppressed_external_prefix_count>\\d+) +Internal: +(?P<active_internal_prefix_count>\\d+)\\/(?P<total_internal_prefix_count>\\d+)\\/(?P<accepted_internal_prefix_count>\\d+)\\/(?P<suppressed_internal_prefix_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Threading +mode: +(?P<bgp_thread_mode>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Groups: +(?P<group_count>\\d+) +Peers: +(?P<peer_count>\\d+) +Down +peers: +(?P<down_peer_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>inet(\\d+)?.\\d)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Description: +(?P<description>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +Error: +(?P<last_error>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Options: +<(?P<options>[\\S\\s]+)>$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +flaps: +(?P<flap_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Authentication +key +is +configured$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Export: +\\[ +(?P<export_policy>[\\s\\S]+) +\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +flap +event: +(?P<last_flap_event>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer +does +not +support +Addpath$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Entropy +label +NLRI: +(?P<nlri_type>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Table +(?P<name>\\S+) +Bit: +(?P<rib_bit>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RIB +State: +(?P<bgp_rib_state>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Send +state: +(?P<send_state>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active +prefixes: +(?P<active_prefix_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +is +not +running+$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show chassis",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Slot +(?P<slot>\\d+) +information:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State +(?P<state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Temperature +(?P<temperature>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total CPU DRAM +(?P<memory_dram_size>\\d+)\\sMB$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total RLDRAM +(?P<memory_rldram_size>\\d+)\\sMB$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total DDR DRAM +(?P<memory_ddr_dram_size>\\d+)\\sMB$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FIPS Capable +(?P<fips_capable>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FIPS Mode +(?P<fips_mode>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Start time +(?P<start_time>[\\d\\-\\:A-Za-z ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Uptime +(?P<up_time>[\\d\\-\\,A-Za-z ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>[\\S\\s]+) +status:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State +(?P<name>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Part +Type +Version$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+\\s+\\d+) +(?P<type>\\S+) +(?P<firmware>\\S+\\s+\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>\\S+) +(?P<firmware>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hardware +(?P<style>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>(\\S+\\s\\d+)) +(?P<description>\\S+\\s\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+\\s+\\S+\\s+\\d+) +(?P<description>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<version>[\\S\\.\\d]+ [\\S\\.\\d]+) +(?P<part_number>[\\S\\-]+) +(?P<serial_number>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+ \\d+) +(?P<description>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+ \\d+) +(?P<part_number>\\S+) +(?P<serial_number>\\S+) +(?P<description>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<serial_number>\\S+) +(?P<description>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hardware +(?P<style>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hardware +(?P<style>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Jedec Code: +(?P<jedec_code>\\S+) +EEPROM Version: +(?P<eeprom_version>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^S/N: +(?P<serial_number>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Assembly ID: +(?P<assembly_identifier>\\S+) +Assembly Version: +(?P<assembly_version>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Date: +(?P<manufacture_date>\\S+) +Assembly Flags: +(?P<assembly_flags>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ID: +(?P<i2c_identifier>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address_type>\\ABoard Information Record):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address_type>\\AI2C Hex Data:)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address_info>\\AAddress[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>(\\S+\\s\\d+)) +(?P<description>\\S+\\s\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+\\s+\\S+\\s+\\d+) +(?P<description>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<disk_size>\\d+) +MB +(?P<model>\\S+\\s+\\S+\\s+\\S+\\s+\\S+) +(?P<serial_number>\\d+) +(?P<description>\\S+\\s+\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<version>[\\S\\.\\d]+ [\\S\\.\\d]+) +(?P<part_number>[\\S\\-]+) +(?P<serial_number>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+ \\d+) +(?P<description>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+ \\d+) +(?P<part_number>\\S+) +(?P<serial_number>\\S+) +(?P<description>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<serial_number>\\S+) +(?P<description>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<slot>\\d+) +(?P<state>\\S+) +(?P<text>\\S+)( +(?P<cpu_total>\\d+) +(?P<cpu_interrupt>\\d+)( +(?P<cpu_1min>\\d+) +(?P<cpu_5min>\\d+) +(?P<cpu_15min>\\d+))? +(?P<dram>\\d+) +(?P<heap>\\d+) +(?P<buffer>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<slot>\\d+) +(?P<state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<slot>\\d+)\\s+(?P<state>\\S+)\\s+---(?P<comment>Offlined\\s+by\\s+cli\\s+command)---$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Slot +(?P<slot>\\d+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current state +(?P<mastership_state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Election priority +(?P<mastership_priority>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DRAM +(?P<memory_dram_size>\\S+\\s\\S+) +(?P<memory_installed_size>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Memory utilization +(?P<memory_buffer_utilization>\\d+) +percent$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<state>\\d+\\s+\\S+) +CPU utilization:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^User +(?P<user>\\d+) +percent$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Background +(?P<background>\\d+) +percent$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Kernel +(?P<system>\\d+) +percent$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Temperature +(?P<cpu_temperature>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interrupt +(?P<interrupt>\\d+) +percent$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Idle +(?P<idle>\\d+) +percent$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Model +(?P<system>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Serial +ID +(?P<serial_number>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Start time +(?P<start_time>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CPU +[tT]emperature +(?P<cpu_temperature>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Uptime +(?P<uptime>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last reboot reason +(?P<last_reboot_reason>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<load_average_one>[\\d\\.]+) +(?P<load_average_five>[\\d\\.]+) +(?P<load_average_fifteen>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<re_state>[\\{\\S\\s]+\\})$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<class>Temp|Fans) +)?(?P<name>[\\s\\S]+) +(?P<status>OK|Check)( +(?P<measurement>[\\s\\S]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>.*) +status:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State +(?P<state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<active_alarms>\\d+) +alarms +currently +active$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<text>\\S+ +\\d\\d\\:\\d\\d\\:\\d\\d +\\S+) +(?P<alarm_class>\\S+) +(?P<description>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<plane_slot>\\d+) +(?P<state>\\S+) +(?P<up_time>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Plane +(?P<slot>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Plane +state: +(?P<state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<fpc_name>\\S+) +(?P<fpc_slot>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PFE +(?P<pfe>\\d+) +:+(?P<links>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+ +\\d+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: +(?P<state>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DC +input: +(?P<dc_input_status>[\\S\\s]+)( +\\((?P<str_dc_expect_feed>\\S+) +feed +expected, +(?P<str_dc_actual_feed>\\S+) +feed +connected\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Capacity: +(?P<capacity_actual>\\d+) +\\S+ +\\(maximum +(?P<capacity_max>\\d+) +\\S+\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DC +output: +(?P<str_dc_power>\\S+) +\\S+ +\\((?P<str_zone>\\S+) +Zone, +(?P<str_dc_current>\\S+) +\\S+ +at +(?P<str_dc_voltage>\\S+) +\\S+, +(?P<str_dc_load>\\S+)\\% +of +capacity\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +system +capacity: +(?P<capacity_sys_actual>\\S+) +\\S+ +\\(maximum +(?P<capacity_sys_max>\\S+) +\\S+\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +remaining +power: +(?P<capacity_sys_remaining>\\S+) +\\S+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<str_zone>\\S+) +Zone:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Allocated +power: +(?P<capacity_allocated>\\S+) +\\S+ +\\((?P<capacity_remaining>\\S+) +\\S+ +remaining\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Actual +usage: +(?P<capacity_actual_usage>\\S+) +\\S+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+ +\\d+) +status:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State +(?P<state>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\w+ +(?P<power_type>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<temperature_name>.*) +(?P<text>\\d+ +degrees +\\w+ +\\/ +\\d+ +degrees +\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<reference_voltage>[\\d\\.]+ +\\w+( +\\w+)?) +(?P<actual_voltage>\\d+) +\\w+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bus +Revision +(?P<bus_revision>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FPGA +Revision +(?P<fpga_revision>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show class_of_service",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Physical +interface: +(?P<interface_name>\\S+), +Index: +(?P<interface_index>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Maximum +usable +queues|Queues +supported): +(?P<interface_queues_supported>\\d+), +Queues +in +use: +(?P<interface_queues_in_use>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Exclude +aggregate +overhead +bytes: +(?P<overhead_bytes>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Logical +interface +aggregate +statistics: +(?P<aggregate_statistics>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Shaping +rate: +(?P<interface_shaping_rate>\\d+) +bps$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Scheduler +map: +(?P<scheduler_map_name>\\S+), +Index: +(?P<scheduler_map_index>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Congestion-notification: +(?P<congestion_notification_map>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Logical +interface: +(?P<i_logical_name>\\S+), +Index: +(?P<i_logical_index>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<object_type>\\S+) +(?P<object_name>\\S+) +(?P<object_subtype>\\S+( +\\(\\S+\\))?) +(?P<index>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show configuration",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^to +(?P<to>[\\S]+);$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^revert-timer +(?P<revert_timer>[\\S]+);$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^priority +(?P<setup_priority>[\\S]+) +(?P<reservation_priority>[\\S]+);$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^primary +(?P<primary>[\\S]+);$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<flag>[^\\s;]+);$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<type>[\\S]+);$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^vlan-id +(?P<vlan_id>\\S+);$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show ddos",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^DDOS protection global statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<key>[\\s\\S]+)(:|mode) +(?P<value>[\\w\\d]+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show firewall",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Filter: +(?P<filter_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<counter_name>\\S+) +(?P<byte_count>\\d+) +(?P<packet_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Policers:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Counters:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Filter: +(?P<filter_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<counter_name>\\S+) +(?P<byte_count>\\d+) +(?P<packet_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<filter_name>\\APolicers:)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<time>[\\d\\:]+) +(?P<filter_name>\\S+) +(?P<action_name>\\S+) +(?P<interface_name>\\S+) +(?P<protocol_name>\\S+) +(?P<source_address>\\S+) +(?P<destination_address>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show interface",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<interface>\\S+) +(?P<admin_state>\\w+) +(?P<link_state>\\w+) *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<protocol>\\S+) +)?(?P<local>((\\d+\\.[\\d\\.\\/]+)|(\\w+\\:[\\w\\:\\/]+)|(0x\\d+))+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<protocol>\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +Admin +Link +Description$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<admin_status>\\S+) +(?P<oper_status>\\S+) +(?P<description>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Physical +interface: +(?P<name>\\S+), +(?P<admin_status>\\S+), +Physical +link +is +(?P<oper_status>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +index: +(?P<local_index>\\d+), +SNMP +ifIndex: +(?P<snmp_index>\\d+)(, +Generation: +\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Description: +(?P<description>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Type: +\\S+, )?Link-level +type: +(?P<link_level_type>\\S+), +MTU: +(?P<mtu>\\S+)(, +MRU: +(?P<mru>\\d+))?(, +(?P<sonet_mode>\\S+) +mode)?(, +Link-mode: +(?P<link_mode>\\S+))?(, +Speed: +(?P<speed>\\S+))?(, +BPDU +Error: +(?P<bpdu_error>\\S+),)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Speed: +(?P<speed>[^\\s,]+))(, +)?(BPDU +Error: +(?P<bpdu_error>[^\\s,]+))?(, +)?(Loop +Detect +PDU +Error: +(?P<ld_pdu_error>[^\\s,]+))?(, +)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link-level +type: +(?P<link_level_type>\\S+), +MTU: +(?P<mtu>\\S+)(, +MRU: +(?P<mru>\\d+))?(, +(?P<sonet_mode>\\S+) +mode)?(, +Speed: +(?P<speed>\\S+))?(, +BPDU +Error: +(?P<bpdu_error>\\S+),)?( +Loop +Detect +PDU +Error: +(?P<ld_pdu_error>\\S+),)?( +Ethernet-Switching +Error: +(?P<eth_switch_error>\\S+),)?( +MAC-REWRITE +Error: +\\S+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Loop +Detect +PDU +Error: +(?P<ld_pdu_error>\\S+), +Ethernet-Switching +Error: +(?P<eth_switch_error>\\S+), +MAC-REWRITE +Error: +\\S+, +Loopback: +(?P<loopback>\\S+),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Ethernet-Switching +Error: +(?P<eth_switch_error>[^\\s,]+))(, +)?(MAC-REWRITE +Error: +[^\\s,]+)?(, +)?(Loopback: +(?P<loopback>[^\\s,]+))(, +)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Loopback: +(?P<loopback>\\S+),)?( +Source +filtering: +(?P<source_filtering>\\S+),)?( +Flow +control: +(?P<if_flow_control>\\S+),)?( +Auto-negotiation: +(?P<if_auto_negotiation>\\S+),)?( +Remote +fault: +(?P<if_remote_fault>\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +filtering: +(?P<source_filtering>\\S+), +Flow +control: +(?P<if_flow_control>\\S+), +Auto-negotiation: +(?P<if_auto_negotiation>\\S+), +Remote +fault: +(?P<if_remote_fault>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Pad +to +minimum +frame +size: +(?P<pad_to_minimum_frame_size>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Device +flags +: +(?P<if_device_flags>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +flags:( +(?P<hardware_down>Hardware-Down))? +(?P<iff_snmp_traps>\\S+)( +Internal: +(?P<internal_flags>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +flags +: +(?P<if_media_flags>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +type +: +(?P<link_type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CoS +queues +: +(?P<physical_interface_cos_hw_max_queues>\\d+) +supported, +(?P<physical_interface_cos_use_max_queues>\\d+) maximum +usable +queues$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current +address: +(?P<current_physical_address>\\S+), +Hardware +address: +(?P<hardware_physical_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +flapped +: +(?P<interface_flapped>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input +rate +: +(?P<input_bps>\\d+) +bps +\\((?P<input_pps>\\d+) +pps\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input +bytes *: +(?P<input_bytes>\\S+)( +(?P<input_bps>\\S+) +bps)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +bytes *: +(?P<output_bytes>\\S+)( +(?P<output_bps>\\S+) +bps)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input +packets *: +(?P<input_packets>\\S+)( +(?P<input_pps>\\S+) +pps)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +packets *: +(?P<output_packets>\\S+)( +(?P<output_pps>\\S+) +pps)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +rate +: +(?P<output_bps>\\d+) +bps +\\((?P<output_pps>\\d+) +pps\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active +alarms *: +(?P<active_alarms>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active +defects *: +(?P<active_defects>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PCS +statistics +Seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bit +errors +(?P<bit_error_seconds>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Errored +blocks +(?P<errored_blocks_seconds>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Ethernet +FEC +statistics +Errors$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FEC +Corrected +Errors +(?P<fec_ccw_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FEC +Uncorrected +Errors +(?P<fec_nccw_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FEC +Corrected +Errors +Rate +(?P<fec_ccw_error_rate>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FEC +Uncorrected +Errors +Rate +(?P<fec_nccw_error_rate>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +transmit +statistics: +(?P<interface_transmit_statistics>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Logical +interface +(?P<name>\\S+) +\\(Index +(?P<local_index>\\d+)\\) +\\(SNMP +ifIndex +(?P<snmp_index>\\d+)\\)( +\\(Generation +\\S+\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flags: +(?P<iff_up>\\S+)( +SNMP-Traps)?( +(?P<internal_flags>\\S+))?( +VLAN-Tag +\\[[\\S\\s]+\\])? +Encapsulation: +(?P<encapsulation>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input +packets *: +(?P<input_packets>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +packets *: +(?P<output_packets>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Protocol +(?P<address_family_name>\\S+), +MTU: +(?P<mtu>\\S+)(, +Maximum labels: +(?P<maximum_labels>\\S+))?(, +Generation: +(?P<generation>\\S+))?(, +Route table: +(?P<route_table>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Max +nh +cache: +(?P<max_local_cache>\\d+), +New +hold +nh +limit: +(?P<new_hold_limit>\\d+), Curr +nh +cnt: +(?P<intf_curr_cnt>\\d+), +Curr +new +hold +cnt: +(?P<intf_unresolved_cnt>\\d+), +NH +drop +cnt: +(?P<intf_dropcnt>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flags: +(?P<flags>[\\S\\s]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Addresses, +Flags: +(?P<flags>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Destination: +(?P<ifa_destination>\\S+), +Local: +(?P<ifa_local>\\S+)(, +Broadcast: +(?P<ifa_broadcast>\\S+))?(, +Generation: +(?P<generation>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bandwidth: +(?P<logical_interface_bandwidth>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local: +(?P<ifa_local>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv6 +transit +statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dropped +traffic +statistics +due +to +STP +State:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Transit +statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hold-times +: +Up +\\d+ +ms, +Down +\\d+ +ms$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Damping +: +half-life: +\\d+ +sec, +max-suppress: +\\d+ +sec, +reuse: +\\d+, +suppress: +\\d+, +state: +\\S+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input +errors:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +errors:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Errors: +(?P<input_errors>\\d+),)?( *Drops: +(?P<input_drops>\\d+),)?( *Framing +errors: +(?P<framing_errors>\\d+),)?( *Runts: +(?P<input_runts>\\d+),)?( *Policed +discards: +(?P<input_discards>\\d+),)?( *L3 +incompletes: +(?P<input_l3_incompletes>\\d+),)?( *L2 +channel +errors: +(?P<input_l2_channel_errors>\\d+),)?( *L2 +mismatch +timeouts: +(?P<input_l2_mismatch_timeouts>\\d+),?)?( *FIFO +errors: +(?P<input_fifo_errors>\\d+),?)?( *Resource +errors: +(?P<input_resource_errors>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Carrier +transitions: +(?P<carrier_transitions>\\d+), +Errors: +(?P<output_errors>\\d+), +Drops: +(?P<output_drops>\\d+), +Collisions: +(?P<output_collisions>\\d+), +Aged+ packets: +(?P<aged_packets>\\d+),(( +FIFO +errors: +(?P<output_fifo_errors>\\d+),)? +HS +link +CRC +errors: +(?P<hs_link_crc_errors>\\d+),)?( +MTU +errors: +(?P<mtu_errors>\\d+),?)?( +Resource +errors: +(?P<output_resource_errors>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU +errors: +(?P<mtu_errors>\\d+), +Resource +errors: +(?P<output_resource_errors>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FIFO +errors: +(?P<output_fifo_errors>\\d+), +(HS +link +CRC +errors: +(?P<hs_link_crc_errors>\\d+),)?( +MTU +errors: +(?P<mtu_errors>\\d+),?)?( +Resource +errors: +(?P<output_resource_errors>\\d+))?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +octets +(?P<input_bytes>\\d+) +(?P<output_bytes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +statistics: +Receive +Transmit$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +packets +(?P<input_packets>\\d+) +(?P<output_packets>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unicast +packets +(?P<input_unicasts>\\d+) +(?P<output_unicasts>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Broadcast +packets +(?P<input_broadcasts>\\d+) +(?P<output_broadcasts>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Multicast +packets +(?P<input_multicasts>\\d+) +(?P<output_multicasts>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CRC\\/Align +errors +(?P<input_crc_errors>\\d+) +(?P<output_crc_errors>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^FIFO +errors +(?P<input_fifo_errors>\\d+) +(?P<output_fifo_errors>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +control +frames +(?P<input_mac_control_frames>\\d+) +(?P<output_mac_control_frames>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MAC +pause +frames +(?P<input_mac_pause_frames>\\d+) +(?P<output_mac_pause_frames>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Oversized +frames +(?P<input_oversized_frames>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Jabber +frames +(?P<input_jabber_frames>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Fragment +frames +(?P<input_fragment_frames>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VLAN +tagged +frames +(?P<input_vlan_tagged_frames>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Code +violations +(?P<input_code_violations>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +errors +(?P<input_total_errors>\\d+) +(?P<output_total_errors>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Label-switched +interface +\\(LSI\\) +traffic +statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Egress +queues: +(?P<intf_cos_num_queues_supported>\\d+) +supported, +(?P<intf_cos_num_queues_in_use>\\d+) +in +use$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<queue_number>\\d+) +(?P<queue_counters_queued_packets>\\d+) +(?P<queue_counters_trans_packets>\\d+) +(?P<drop_packets>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hold-times +: +Up +(?P<up_hold_time>\\d+) +ms, +Down +(?P<down_hold_time>\\d+) +ms$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Statistics +last +cleared: +(?P<statistics_cleared>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<queue_number>\\d+) +(?P<forwarding_class_name>best-effort|expedited-forwarding|assured-forwarding|network-control)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Filter +statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input +packet +count +(?P<input_packets>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input +packet +rejects +(?P<input_reject_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input +DA +rejects +(?P<input_reject_da_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input +SA +rejects +(?P<input_reject_sa_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +packet +count +(?P<output_packets>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +packet +pad +count +(?P<output_packet_pad_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +packet +error +count +(?P<output_packet_error_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CAM +destination +filters: (?P<cam_destination_filter_count>\\d+), +CAM +source +filters: (?P<cam_source_filter_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Destination +slot: +(?P<destination_slot>\\d+) +(?P<destination_mask>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<cos_queue_number>\\d+) +(?P<cos_queue_forwarding_class>\\S+) +(?P<cos_queue_bandwidth>\\d+) +(?P<cos_queue_bandwidth_bps>\\d+) +(?P<cos_queue_buffer>\\d+) +(?P<cos_queue_buffer_bytes>\\d+) +(?P<cos_queue_priority>\\w+) +(?P<cos_queue_limit>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Direction : +(?P<cos_direction>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Generation: +(?P<generation>\\d+)(, +Route +table: +(?P<route_table>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Policer: +Input: +(?P<policer_input>\\S+)(, +Output: +(?P<policer_output>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Physical +interface: +(?P<name>[^\\s,]+), +(?P<admin_status>[^\\s,]+), +Physical +link +is +(?P<oper_status>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +index: +(?P<local_index>\\d+), +SNMP +ifIndex: +(?P<snmp_index>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link-level +type: +(?P<link_level_type>[^\\s,]+), +MTU: +(?P<mtu>\\d+), +Link-mode: +(?P<link_mode>[^\\s,]+), +Speed: +(?P<speed>[^\\s,]+),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BPDU +Error: +(?P<bpdu_error>[^\\s,]+), +MAC-REWRITE +Error: +(?P<l2pt_error>[^\\s,]+), +Loopback: +(?P<loopback>[^\\s,]+),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +filtering: +(?P<source_filtering>[^\\s,]+), +Flow +control: +(?P<if_flow_control>[^\\s,]+), +Auto-negotiation: +(?P<if_auto_negotiation>[^\\s,]+),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +fault: +(?P<if_remote_fault>[^\\s,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Device +flags *: +((?P<ifdf_none>None+) *)?((?P<ifdf_present>Present+) *)?((?P<ifdf_running>Running+) *)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +flags: +(?P<iff_snmp_traps>\\S+) +Internal: +(?P<internal_flags>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +flags *: +((?P<ifmf_none>None) *)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CoS +queues *: +(?P<physical_interface_cos_hw_max_queues>\\d+) +supported, +(?P<physical_interface_cos_use_max_queues>\\d+) +maximum +usable +queues$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current +address: +(?P<current_physical_address>[^\\s,]+), +Hardware +address: +(?P<hardware_physical_address>[^\\s,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +flapped *: +(?P<interface_flapped>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Statistics last cleared: +(?P<statistics_cleared>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input rate *: +(?P<input_bps>\\d+) +bps +\\((?P<input_pps>\\d+) +pps\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output rate *: +(?P<output_bps>\\d+) +bps +\\((?P<output_pps>\\d+) +pps\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input errors: +(?P<input_error_count>\\d+), +Output errors: +(?P<output_error_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active +alarms *: +(?P<alarm_not_present>None)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active +defects *: +(?P<alarm_not_present>None)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +transmit +statistics: +(?P<interface_transmit_statistics>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Logical +interface +(?P<name>\\S+) +\\(Index +(?P<local_index>\\d+)\\) +\\(SNMP +ifIndex +(?P<snmp_index>\\d+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flags: +(?P<iff_snmp_traps>SNMP-Traps) +(?P<internal_flags>\\S+) +Encapsulation: +(?P<encapsulation>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input +packets *: +(?P<input_packets>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +packets *: +(?P<output_packets>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Security: +Zone: (?P<logical_interface_zone_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Allowed +host-inbound +traffic *: +(?P<inbound_dhcp>dhcp)( +)?(?P<inbound_http>http)( +)?(?P<inbound_https>https)( +)?(?P<inbound_ssh>ssh)( +)?(?P<inbound_telnet>telnet)( +)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Protocol +(?P<address_family_name>[^\\s,]+), +MTU: +(?P<mtu>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flags: +(?P<ifff_sendbcast_pkt_to_re>Sendbcast-pkt-to-re)(, +)?(?P<ifff_is_primary>Is-Primary)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Addresses(, Flags: +)?(?P<flags>.+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Destination: +(?P<ifa_destination>[^\\s,]+))?(, +)?(Local: +(?P<ifa_local>[^\\s,]+))?(, +)?(Broadcast: +(?P<ifa_broadcast>[^\\s,]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[a-zA-Z\\-\\d\\/]+)((?P<physical_interface_value>[\\.\\d]+))? +(?P<admin>\\w+) +(?:(?P<link>\\w+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<policer_family>\\w+) +(?P<policer_input>\\S+)( +((?P<policer_output>\\S+)))?$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show ipv6_neighbors",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<ipv6_nd_neighbor_address>[\\w:]+) +(?P<ipv6_nd_neighbor_l2_address>[\\w:]+) +(?P<ipv6_nd_state>\\S+) +(?P<ipv6_nd_expire>\\d+) +(?P<ipv6_nd_isrouter>\\S+) +(?P<ipv6_nd_issecure>\\S+) +(?P<ipv6_nd_interface_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +entries: +(?P<ipv6_nd_total>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show krt",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Number of operations queued: +(?P<krtq_operations_queued>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routing table adds: +(?P<krtq_rt_table_adds>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface routes: +(?P<krtq_interface_routes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^High pri multicast +Adds\\/Changes: +(?P<krtq_high_multicast_adds_changes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Indirect Next Hop +Adds\\/Changes: +(?P<krtq_indirect_adds_changes>\\d+) +Deletes: +(?P<krtq_indirect_deletes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MPLS +Adds: +(?P<krtq_high_mpls_adds>\\d+) +Changes: +(?P<krtq_high_mpls_changes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^High pri\\s+Adds: +(?P<krtq_high_priority_adds>\\d+)\\s+Changes: +(?P<krtq_high_priority_changes>\\d+)\\s+Deletes: +(?P<krtq_high_priority_deletes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Normal pri Indirects: +(?P<krtq_normal_priority_indirects>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Normal pri\\s+Adds: +(?P<krtq_normal_priority_adds>\\d+)\\s+Changes: +(?P<krtq_normal_priority_changes>\\d+)\\s+Deletes: +(?P<krtq_normal_priority_deletes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^GMP GENCFG Objects: +(?P<krtq_normal_priority_gmp>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routing Table deletes: +(?P<krtq_rt_table_deletes>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number of operations deferred: +(?P<krtq_operations_deferred>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number of operations canceled: +(?P<krtq_operations_canceled>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number of async queue entries: +(?P<krtq_async_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number of async non queue entries: +(?P<krtq_async_non_q_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time until next queue run: +(?P<krtq_time_until_next_run>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routes learned from kernel: +(?P<krtq_kernel_rt_learnt>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time until next scan: +(?P<rtsock_time_until_next_scan>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<krtq_type>([^:(]+?))(\\s*[:(]) (?P<krtq_queue_length>\\d+) queued$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show lacp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Aggregated +interface: +(?P<aggregate_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<lacp_role>\\S+) +(?P<lacp_expired>\\S+) +(?P<lacp_defaulted>\\S+) +(?P<lacp_distributing>\\S+) +(?P<lacp_collecting>\\S+) +(?P<lacp_synchronization>\\S+) +(?P<lacp_aggregation>\\S+) +(?P<lacp_timeout>\\S+) +(?P<lacp_activity>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>\\S+) +(?P<lacp_receive_state>\\S+) +(?P<lacp_transmit_state>\\S+ +\\S+) +(?P<lacp_mux_state>\\S+ +\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show ldp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<ldp_neighbor_address>\\S+) +(?P<ldp_session_state>\\S+) +(?P<ldp_connection_state>\\S+) +(?P<ldp_remaining_time>\\d+)( +)?(?P<ldp_session_adv_mode>\\S+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Downstream +unsolicited +Sessions\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auto +targeted +sessions\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^P2MP\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timers\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Graceful +restart\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGP\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Session +protection\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Traffic +Engineering\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +Job\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Label +allocation\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Protocol +modes\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Sessions\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface_name>\\S+)( +(?P<local_address>\\S+))? +(?P<space_id>\\S+) +(?P<neighbor_count>\\d+) +(?P<next_hello>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello +interval: +(?P<ldp_hello_interval>\\d+), +Hold +time: +(?P<ldp_holdtime>\\d+), +Transport +address: +(?P<ldp_transport_address>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU +discovery: +(?P<ldp_mtu_discovery>\\S+)$^Nonstop +routing +state: +(?P<ldp_session_nsr_state>[\\S\\s]+)$^(?P<next_hop_flag>Next-hop +addresses +received:)$^(?P<interface_address>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show lldp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^LLDP\\s*:\\s*(?P<lldp_global_status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Advertisement\\s+interval\\s*:\\s*(?P<lldp_advertisement_interval>\\d+) +seconds?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Notification\\s+interval\\s*:\\s*(?P<lldp_notification_interval>\\d+) +Second\\(s\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Connection\\s+Hold\\s+timer\\s*:\\s*(?P<ptopo_maximum_hold_time>\\d+) +seconds?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LLDP\\s+MED\\s*:\\s*(?P<lldp_med_global_status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port\\s+Description\\s+TLV\\s+type\\s*:\\s*(?P<lldp_port_description_type>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show mpls",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Total (?P<display_count>\\d+) +displayed, +Up +(?P<up_count>\\d+), +Down +(?P<down_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^[\\d\\.]+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^From: +(?P<source_address>[\\d+\\.]+), +LSPstate: +(?P<lsp_state>[^\\s,]+), +ActiveRoute: +(?P<route_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LSPname: +(?P<name>[^\\s,]+), +LSPpath: +(?P<lsp_path_type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time +left: +(?P<psb_lifetime>\\d+), +Since: +(?P<psb_creation_time>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tspec: +(?P<sender_tspec>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +number: +sender +(?P<lsp_id>\\d+) +receiver +(?P<tunnel_id>\\d+) +protocol +(?P<proto_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<heading>(PATH|RESV))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)incoming +message +handle: +(?P<in_message_handle>\\S+), +Message +ID: +(?P<in_message_id>\\S+), +Epoch: +(?P<in_epoch>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)outgoing +message +state: +(?P<out_message_state>\\S+), +Message +ID: +(?P<out_message_id>\\S+), +Epoch: +(?P<out_epoch>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adspec: +(?P<adspec>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Explct +route: +(?P<addresses>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Record +route: +(?P<addresses>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Enhanced +FRR: (?P<rsvp_lsp_enh_lp_upstream_status>\\S+) +\\(Upstream\\), +Reason: +Compatibility, +Refresh: +(?P<rsvp_lsp_enh_local_prot_refresh_interval>[\\s\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Enhanced +FRR: (?P<rsvp_lsp_enh_lp_downstream_status>\\S+) +\\(Downstream\\), +Reason: +Compatibility, +Refresh: +(?P<rsvp_lsp_enh_local_prot_refresh_interval>[\\s\\S]+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show ntp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<mode_code>[xo\\*\\-\\+\\=]+)? *(?P<remote>[\\w\\.\\:\\-]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(assID\\=(?P<ass_id>\\d+) *)?status\\=(?P<status>\\d+) *(?P<leap_status>\\w+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^reftime\\=(?P<reftime>[\\w\\s\\,\\.\\:]+), +poll\\=(?P<poll>\\d+),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^clock\\=(?P<clock>[\\w\\s\\,\\.\\:]+), +state\\=(?P<state>\\d+),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<key>\\w+)\\=\\\"?(?P<value>[\\w\\.\\:\\s\\(\\)\\-\\@\\/\\_]+)\\\"?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^set +system +ntp +(?P<type>\\w+) +(?P<address>[\\w\\.\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^server +(?P<server_name>[\\s\\S]+);$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^source-address +(?P<source_address>[\\s\\S]+);$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show ospf",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Adj +count: +(?P<adj_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auth +type: +(?P<authentication_type>[\\w ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Protection +type: +(?P<protection_type>[\\w ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Instance: +(?P<instance_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF database, Area +(?P<ospf_area>[\\w\\.\\:\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +(?P<ospf_area1>[\\w\\.\\/]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<area_value>\\d+) +(?P<area_name>\\S+) +LSAs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<externals>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +(?P<ospf_area2>[\\w\\.\\/]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +(?P<interface>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^empty$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^empty$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^empty$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<external_heading>\\AOSPF AS[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<heading>\\AType +ID[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^mask +(?P<address_mask>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Aging timer +(?P<text>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Installed +(?P<installed_time>[\\w\\.\\/\\:]+) ago, expires in +(?P<expired_time>[\\w\\.\\/\\:]+), sent +(?P<sent_time>[\\w\\.\\/\\:]+) ago$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Last changed +(?P<installed_time>[\\S]+) +(?P<installed_time2>[\\S]+) ago, Change count: +(?P<lsa_change_count>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Instance: +(?P<instance_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router ID: +(?P<ospf_router_id>[\\w\\.\\:\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SPRING: +(?P<ospf_spring_enabled>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area: +(?P<ospf_area>[\\w\\.\\:\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Stub +type: +(?P<ospf_stub_type>[\\S+\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +border +routers: +(?P<ospf_abr_count>\\d+), +AS +boundary +routers: +(?P<ospf_asbr_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Full +SPF +runs: +(?P<ospf_full_spf_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +database, +Area +(?P<ospf_area>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Type: +(?P<link_type_name>\\S+), +Node +ID: +(?P<ospf_lsa_topology_link_node_id>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric: +(?P<ospf_lsa_topology_link_metric>\\d+), +(?P<ospf_lsa_topology_link_state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<formatted_tlv_data>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Priority (?P<priority_number>\\d+), \\S+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<formatted_tlv_data>Local +\\d+, +Remote +\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^mask +(?P<address_mask>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology +(?P<ospf_topology_name>\\S+) +\\(ID +(?P<ospf_topology_id>\\S+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^attached router +(?P<attached_router>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +database, +Area +(?P<ospf_area>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Type: +(?P<link_type_name>\\S+), +Node +ID: +(?P<ospf_lsa_topology_link_node_id>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric: +(?P<ospf_lsa_topology_link_metric>\\d+), +(?P<ospf_lsa_topology_link_state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<formatted_tlv_data>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Priority (?P<priority_number>\\d+), \\S+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<formatted_tlv_data>Local +\\d+, +Remote +\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^mask +(?P<address_mask>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^attached +router +(?P<attached_router>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Up +(?P<neighbor_up_time>\\S+ +[\\d:]+), +adjacent +(?P<neighbor_adjacency_time>\\S+ +[\\d:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auth +type: +(?P<authentication_type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DR +addr: +(?P<dr_address>[\\d\\.]+), +Priority: +(?P<router_priority>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<heading>Type \\s+ID[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +database, +Area +(?P<ospf_area>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^mask +(?P<address_mask>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^attached router +(?P<attached_router>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric: +(?P<ospf_lsa_topology_link_metric>\\S+)+, +(?P<ospf_lsa_topology_link_state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology +(?P<ospf_topology_name>\\S+) +Route +Table:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address_prefix>\\S+) +(?P<route_path_type>\\S+) +(?P<route_type>\\S+) +(?P<next_hop_type>\\S+) +(?P<interface_cost>\\d+) +(?P<interface_name>\\S+)( +(?P<interface_address>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^area +(?P<ospf_area>[\\d\\.]+)+, +origin +(?P<route_origin>[\\d\\.]+), +priority +(?P<route_priority>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF database, Area +(?P<ospf_area>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<lsa_type>[a-zA-Z]+) *(?P<lsa_id>\\*?[\\d\\.]+) +(?P<advertising_router>\\S+) +(?P<sequence_number>\\S+) +(?P<age>\\S+) +(?P<options>\\S+) +(?P<checksum>\\S+) +(?P<lsa_length>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology +(?P<ospf_topology_name>\\S+) +Route +Table:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address_prefix>\\S+) +(?P<route_path_type>\\S+) +(?P<route_type>\\S+) +(?P<next_hop_type>\\S+) +(?P<interface_cost>\\d+) +(?P<interface_name>\\S+)( +(?P<interface_address>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^area +(?P<ospf_area>[\\d\\.]+)+, +origin +(?P<route_origin>[\\d\\.]+), +priority +(?P<route_priority>\\w+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show ospf3",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Neighbor-address +(?P<neighbor_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DR-ID +(?P<drid>\\S+), BDR-ID +(?P<bdrid>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<id>[\\d\\.]+) +(?P<interface>\\S+) +(?P<state>\\S+) +(?P<pri>\\S+) +(?P<dead>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor-address +(?P<neighbor_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DR( +)addr( +)(?P<dr_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefix +(?P<ospf3_prefix>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Aging +timer +(?P<aging_timer>(\\S+ ){0,1}[\\d:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Gen +timer +(?P<generation_timer>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Instance: +(?P<instance_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router ID: +(?P<ospf_router_id>[\\w\\.\\:\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area: +(?P<ospf_area>[\\w\\.\\:\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Stub type: +(?P<ospf_stub_type>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Full SPF runs: +(?P<ospf_full_spf_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Backup SPF: +(?P<ospf_backup_spf_status>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF3 +database, +Area +(?P<ospf_area>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<lsa_type>\\S+) *(?P<our_entry>\\*)?(?P<lsa_id>[\\d\\.]+) +(?P<advertising_router>\\S+) +(?P<sequence_number>\\S+) +(?P<age>\\S+) +(?P<checksum>\\S+) +(?P<lsa_length>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Options +(?P<ospf3_options>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Attached router +(?P<attached_router>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<heading>Type \\s+ID[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF3 +Link-Local +database, +interface +(?P<ospf_intf>\\S+) +Area +(?P<ospf_area>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<lsa_type>\\S+) *(?P<our_entry>\\*)?(?P<lsa_id>[\\d\\.]+) +(?P<advertising_router>\\S+) +(?P<sequence_number>\\S+) +(?P<age>\\S+) +(?P<checksum>\\S+) +(?P<lsa_length>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<linklocal_address>fe80+[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefix-count +(?P<prefix_count>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefix +(?P<ospf3_prefix>\\S+) +Prefix-options +(?P<ospf3_prefix_options>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address_prefix>[\\d\\:\\/]+) +(?P<route_path_type>\\S+) +(?P<route_type>\\S+) +(?P<next_hop_type>\\S+) +(?P<interface_cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NH-interface +(?P<interface_name>[\\w\\d\\-\\/\\.]+)(, +NH-addr +(?P<interface_address>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +(?P<ospf_area>\\S+),+ Origin +(?P<route_origin>\\S+),( +Fwd +(?P<forward>\\S+),)? +Priority +(?P<route_priority>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Instance: +(?P<instance_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Realm: +(?P<realm_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<id>[\\d\\.]+) +(?P<interface>\\S+) +(?P<state>\\S+) +(?P<pri>\\S+) +(?P<dead>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor-address +(?P<neighbor_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address_prefix>[\\d\\:\\/]+) +(?P<route_path_type>\\S+) +(?P<route_type>\\S+) +(?P<next_hop_type>\\S+) +(?P<interface_cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NH-interface +(?P<interface_name>[\\w\\d\\-\\/\\.]+)(, +NH-addr +(?P<interface_address>\\S+))?$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show pfe",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Input +packets: +(?P<pfe_input_packets>\\d+) +(?P<input_pps>\\d+) +pps$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +packets: +(?P<pfe_output_packets>\\d+) +(?P<output_pps>\\d+) +pps$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Fabric +Input +: +(?P<pfe_fabric_input>\\d+) +(?P<pfe_fabric_input_pps>\\d+) +pps$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Fabric +Output +: +(?P<pfe_fabric_output>\\d+) +(?P<pfe_fabric_output_pps>\\d+) +pps$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Software +input +control +plane +drops +: +(?P<software_input_control_drops>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Software +input +high +drops +: +(?P<software_input_high_drops>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Software +input +medium +drops +: +(?P<software_input_medium_drops>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Software +input +low +drops +: +(?P<software_input_low_drops>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Software +output +drops +: +(?P<software_output_low_drops>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hardware +input +drops +: +(?P<hardware_input_drops>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ATM +OAM +: +(?P<atm_oam_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Frame +Relay +LMI +: +(?P<fr_lmi_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PPP +LCP/NCP +: +(?P<ppp_lcp_ncp_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF +hello +: +(?P<ospf_hello_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF3 +hello +: +(?P<ospf3_hello_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RSVP +hello +: +(?P<rsvp_hello_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +hello +: +(?P<ldp_hello_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BFD +: +(?P<bfd_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS-IS +IIH +: +(?P<isis_iih_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LACP +: +(?P<lacp_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ARP +: +(?P<arp_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ETHER +OAM +: +(?P<ether_oam_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unknown +: +(?P<unknown_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timeout +: +(?P<timeout_discard>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bits +to +test +: +(?P<bits_to_test_discard>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Data +error +: +(?P<data_error_discard>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Normal +discard +: +(?P<bad_route_discard>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Extended +discard +: +(?P<nexthop_discard>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Info +cell +drops +: +(?P<info_cell_discard>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Fabric +drops +: +(?P<fabric_discard>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input +Checksum +: +(?P<input_checksum>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output +MTU +: +(?P<output_mtu>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<state>[\\S\\s]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<value>\\d+) +(?P<key>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Slot +(?P<slot>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<route_tables>\\S+) +Route +Tables:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<index>\\S+) +(?P<routes>\\d+) +(?P<size>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show platform",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\/(?P<dir>(\\S+))\\/\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<file>([a-zA-Z0-9\\-\\_\\.\\@]+))(?: +\\-\\> +(?P<path>(.*)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\/(?P<dir>(\\S+))\\/(?P<file>([a-zA-Z0-9\\-\\_\\/\\.]+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Junos: +(?P<junosversion>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Model: +(?P<productmodel>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hostname: +(?P<hostname>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^JUNOS +(?P<package>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<file_permissions>\\S+)\\s+(?P<file_links>\\d+)\\s+(?P<file_owner>\\S+)\\s+(?P<file_group>\\S+)\\s+(?P<file_size>\\d+)\\s+(?P<file_date>[\\S\\s]+)\\s+(?P<file_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^total\\s+files:\\s+(?P<total_files>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show route",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<table_name>\\S+): +(?P<destination_count>\\d+) +destinations, +(?P<total_route_count>\\d+) +routes +\\((?P<active_route_count>\\d+) +active, +(?P<holddown>\\d+) +holddown, +(?P<hidden>\\d+) +hidden\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<rt_destination>\\S+) +)?(?P<active_tag>[\\*\\+\\-])?\\[(?P<protocol>[\\w\\-]+)\\/(?P<preference>\\d+)(\\/(?P<preference2>\\d+))?\\] +(?P<text>\\S+( +\\S+)?)(, +metric +(?P<metric>\\d+))?(, +metric2 +(?P<metric2>\\d+))?(, +tag +(?P<rt_tag>\\d+))?(, +MED +(?P<med>\\w+))?(, +localpref +(?P<local_preference>\\d+))?(, +from +(?P<learned_from>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nh_type>MultiRecv)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(\\> +)?(to +(?P<to>\\S+) +)?via +(?P<via>\\S+)(, +(?P<mpls_label>[\\S\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +via +(?P<nh_local_interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)AS +path:(?P<as_path>([()\\d\\s]+ )?\\w)(, validation-state: +(?P<validation_state>\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^to +table +(?P<nh_table>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<table_name>\\S+): +(?P<destination_count>\\d+) +destinations, +(?P<total_route_count>\\d+) +routes +\\((?P<active_route_count>\\d+) +active, +(?P<holddown_route_count>\\d+) +holddown, +(?P<hidden_route_count>\\d+) +hidden\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<rt_destination>\\S+)(\\/(?P<rt_prefix_length>\\d+))? +\\((?P<format>(?P<text>\\d+) +(entry|entries)), +(?P<announced>\\d+) +announced\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)State: +\\<(?P<rt_state>[\\S\\s]+)\\>$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<active_tag>\\*)?(?P<protocol>\\S+)\\s+Preference:\\s+(?P<preference>\\d+)(\\/(\\-)?(?P<preference2>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Next +hop type: +(?P<nh_type>\\S+), +Next +hop +index: +(?P<nh_index>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address: +(?P<nh_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Next-hop +reference +count: +(?P<nh_reference_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source: +(?P<gateway>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nh_string>Next *hop):( +(?P<to>\\S+))? +via +(?P<via>\\S+)( +weight +(?P<weight>\\w+))?(, +(?P<selected_next_hop>\\w+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Protocol +next +hop: +(?P<to>\\S+)( +Metric: +(?P<metric>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Session +Id: +\\d+[a-z]+(?P<session_id>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +AS: +(?P<local_as>\\d+)( +Peer +AS: +(?P<peer_as>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Age:\\s+(?P<age>(\\w+(\\s+\\S+)?)|[\\d:]+)(\\s+Metric:\\s+(?P<metric>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Age:\\s+(?P<age>(\\w+(\\s+\\S+)?)|[\\d:]+)(\\s+Metric2:\\s+(?P<metric2>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Validation +State: +(?P<validation_state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tag: +(?P<rt_tag>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Task: +(?P<task>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Announcement +bits +\\((?P<announce_bits>\\d+)\\): +(?P<announce_tasks>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<aspath_effective_string>AS +path:) +((?P<attr_value>[\\S\\s]+) +Cluster +list: (?P<cluster_list>[\\d\\.\\s]+)|(?P<attr_value2>[\\S\\s]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Accepted +(?P<accepted>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<text>KRT +in-kernel+[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Inactive\\s+reason: +(?P<inactive_reason>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area: +(?P<rt_ospf_area>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Label +operation: +(?P<mpls_label>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Label +TTL +action: +(?P<label_ttl_action>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Load +balance +label: +(?P<load_balance_label>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Label +element +ptr: +(?P<label_element>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Label +parent +element +ptr: +(?P<label_element_parent>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Label +element +references: +(?P<label_element_refcount>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Label +element +child +references: +(?P<label_element_childcount>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Label +element +lsp +id: +(?P<label_element_lspid>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Task: +(?P<task_name>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^OSPF3\\s+realm\\s+ipv6-unicast\\s+area\\s:[\\S\\s]+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Page +\\d+ +idx +\\d+[\\S\\s]+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Advertised +metrics:)|(Flags: +)|(Nexthop: +)|(MED: +)|(Localpref: +)|(AS +path:)|(Communities:)|(Path +\\S+)|(from +\\S+)|(Vector +len)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Indirect +next +hop: +(?P<indirect_nh>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Indirect +next +hops: +(?P<forwarding_nh_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\S+ +Originating +RIB: +[\\S\\s]+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Node +path +count: +)|(Forwarding +nexthops: +)[\\S\\s]+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Cluster +list: +(?P<cluster_list>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router +ID: +(?P<peer_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routing +table: +(?P<table_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address_family>\\S+( +\\S+)?):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enabled +protocols: +(?P<enabled_protocols>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<route_table_type>\\S+): +(?P<route_count>\\d+) +routes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<table_name>\\S+): +(?P<destination_count>\\d+) +destinations, +(?P<total_route_count>\\d+) +routes +\\((?P<active_route_count>\\d+) +active, +(?P<holddown_route_count>\\d+) +holddown, +(?P<hidden_route_count>\\d+) +hidden\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<active_tag>\\*) +)?(?P<rt_destination>[\\d\\.\\:\\/]+) +(?P<to>\\S+)( +(?P<med>\\d+)? +(?P<local_preference>\\d+))? +(?P<as_path>(\\(([\\S\\s]+\\)) +\\w+)|([\\d\\s]+?\\w))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<rt_destination>[\\d\\:\\w\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<active_tag>\\*) +)?(?P<to>\\S+)( +(?P<med>\\d+)? +(?P<local_preference>\\d+))? +(?P<as_path>(\\(([\\S\\s]+\\)) +\\w+)|((\\d\\s)?\\w))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<table_name>\\S+): +(?P<destination_count>\\d+) +destinations, +(?P<total_route_count>\\d+) +routes +\\((?P<active_route_count>\\d+) +active, +(?P<holddown_route_count>\\d+) +holddown, +(?P<hidden_route_count>\\d+) +hidden\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)((?P<active_tag>\\*) +)?(?P<rt_destination>[\\d\\.\\:\\/]+) +(?P<to>\\S+)( +(?P<med>\\d+) +(?P<local_preference>\\d+))? +(?P<as_path>[\\s\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<rt_destination>[\\d\\:\\w\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<active_tag>\\*) +)?(?P<to>\\S+)( +(?P<med>\\d+)? +(?P<local_preference>\\d+))? +(?P<as_path>(\\(([\\S\\s]+\\)) +\\w+)|((\\d\\s)?\\w))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Autonomous +system +number: +(?P<as_number>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router +ID: +(?P<router_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<table_name>\\S+): +(?P<destination_count>\\d+) +destinations, +(?P<total_route_count>\\d+) +routes +\\((?P<active_route_count>\\d+) +active, +(?P<holddown_route_count>\\d+) +holddown, +(?P<hidden_route_count>\\d+) +hidden\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<protocol_name>\\S+): +(?P<protocol_route_count>\\d+) +routes, +(?P<active_route_count>\\d+) +\\w+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router +ID: +(?P<router_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Type: +(?P<instance_type>\\S+) +State: +(?P<instance_state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tables:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interfaces:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<irib_name>\\S+) *: +(?P<irib_route_count>\\d+) +routes +\\((?P<irib_active_count>\\d+) +active, +(?P<irib_holddown_count>\\d+) +holddown, +(?P<irib_hidden_count>\\d+) +hidden\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<instance_name>\\S+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<table_name>[^:]+): +(?P<destination_count>\\d+) +destinations, +(?P<total_route_count>\\d+) +routes +\\((?P<active_route_count>\\d+) +active, +(?P<holddown_route_count>\\d+) +holddown, +(?P<hidden_route_count>\\d+) +hidden\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<active_tag>\\*)? *(?P<rt_destination>[\\s\\S]+)/(?P<rt_prefix_length>\\d+) +\\((?P<rt_entry_count>\\d+) +\\S+, +(?P<rt_announced_count>\\d+) +announced\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP group +(?P<bgp_group_name>\\S+) +type +(?P<bgp_group_type>Internal|External)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route Label: +(?P<route_label>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Nexthop: +(?P<to>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MED: +(?P<med>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Localpref: +(?P<local_preference>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^AS +path: +(?P<as_path>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Communities: +(?P<communities>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flags: +(?P<flags>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routing +table: +(?P<table_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address_family>[^\\s:]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enabled +protocols: +(?P<enabled_protocols>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Destination +Type +RtRef +Next hop +Type Index  +NhRef +Netif$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<rt_destination>\\S+) +(?P<destination_type>\\S+) +(?P<route_reference_count>\\d+) +(?P<to>[\\d\\.|\\d\\:a-fA-F]+)? +(?P<nh_type>\\S+( \\S+)?) +(?P<nh_index>\\d+) +(?P<nh_reference_count>\\d+)( +)?(?P<via>\\S+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<table_name>[^\\s:]+): +(?P<destination_count>\\d+) +destinations, +(?P<total_route_count>\\d+) +routes +\\((?P<active_route_count>\\d+) +active, +(?P<holddown_route_count>\\d+) +holddown, +(?P<hidden_route_count>\\d+) +hidden\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<rt_destination>\\S+) +(?P<active_tag>\\*)?\\[(?P<protocol_name>[^\\s/]+)/(?P<preference>\\d+)/(?P<preference2>\\d+)\\] +(?P<age>[\\d:]+), +metric +(?P<metric>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<selected_next_hop>\\> +)?to +(?P<to>\\S+) +via +(?P<via>[^\\s,]+), +label-switched-path +(?P<lsp_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<table_name>\\S+): +(?P<destination_count>\\d+) +destinations, +(?P<total_route_count>\\d+) +routes +\\((?P<active_route_count>\\d+) +active, +(?P<holddown_route_count>\\d+) +holddown, +(?P<hidden_route_count>\\d+) +hidden\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<rt_destination>[\\d\\:\\.]+)+\\/+(?P<rt_prefix_length>\\d+) +\\((?P<text>\\d+) +entry, +(?P<rt_announced_count>\\d+) +announced\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<text>KRT +in-kernel+[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<active_tag>\\*)?(?P<protocol_name>\\S+)\\s+Preference:\\s+(?P<preference>\\d+)(\\/(\\-)?(?P<preference2>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Next +hop type: +(?P<nh_type>\\S+), +Next +hop +index: +(?P<nh_index>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address: +(?P<nh_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Next-hop +reference +count: +(?P<nh_reference_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source: +(?P<gateway>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nh_string>Next hop):( +(?P<to>\\S+))? +via +(?P<via>\\S+), +selected$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Session +Id: +(?P<session>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)State: +\\<(?P<rt_entry_state>[\\S\\s]+)\\>$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +AS: +(?P<local_as>\\d+) +Peer +AS: +(?P<peer_as>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Age: +(?P<text>[\\d\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Validation +State: +(?P<validation_state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Task: +(?P<task_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Announcement +bits +\\((?P<announce_bits>\\d+)\\): +(?P<announce_tasks>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<aspath_effective_string>AS +path:) +(?P<attr_value>[\\d\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<bgp_rt_flag>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Localpref: +(?P<local_preference>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router +ID: +(?P<peer_id>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<table_name>\\S+): +(?P<destination_count>\\d+) +destinations, +(?P<total_route_count>\\d+) +routes +\\((?P<active_route_count>\\d+) +active, +(?P<holddown_route_count>\\d+) +holddown, +(?P<hidden_route_count>\\d+) +hidden\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<active_tag>\\*)? *(?P<rt_destination>[\\w.:]+)(\\/(?P<rt_prefix_length>\\d+))? +\\((?P<format>(?P<text>\\d+) +(entry|entries)), +(?P<rt_announced_count>\\d+) +announced\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<bgp_rt_flag>Accepted)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Nexthop: +(?P<to>[0-9.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Localpref: +(?P<local_preference>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<aspath_effective_string>AS +path:) +(?P<attr_value>([\\S]+( +)?)+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<table_name>\\S+): +(?P<destination_count>\\d+) +destinations, +(?P<total_route_count>\\d+) +routes +\\((?P<active_route_count>\\d+) +active, +(?P<holddown_route_count>\\d+) +holddown, +(?P<hidden_route_count>\\d+) +hidden\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<active_tag>\\* )?(?P<rt_destination>[0-9.:]+)(\\/(?P<rt_prefix_length>\\d+))? +\\((?P<format>(?P<text>\\d+) +(entry|entries)), +(?P<rt_announced_count>\\d+) +announced\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<bgp_rt_flag>Accepted)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Nexthop: +(?P<to>[0-9.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Localpref: +(?P<local_preference>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<aspath_effective_string>AS +path:) +(?P<attr_value>([\\S]+( +)?)+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show rsvp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^RSVP +neighbor: +(?P<rsvp_neighbor_count>\\d+) +learned$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<rsvp_neighbor_address>\\S+) +(?P<neighbor_idle>\\S+) +((?P<neighbor_up_count>\\d+)/(?P<neighbor_down_count>\\d+)) +(?P<last_changed_time>\\S+) +(?P<hello_interval>\\d+) +((?P<hellos_sent>\\d+)/(?P<hellos_received>\\d+)) +(?P<messages_received>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RSVP +neighbor: +(?P<rsvp_neighbor_count>\\d+) +learned$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address: +(?P<rsvp_neighbor_address>\\S+) +(via: +(?P<rsvp_neighbor_interface>\\S+) +)?status: +(?P<rsvp_neighbor_status>\\S+)( +(?P<rsvp_neighbor_node>\\(Node neighbor\\)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +changed +time: +(?P<last_changed_time>[^\\s,]+), +Idle: +(?P<neighbor_idle>\\S+) +sec, +Up +cnt: +(?P<neighbor_up_count>\\d+), +Down +cnt: +(?P<neighbor_down_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Message +received: +(?P<messages_received>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello: +sent:? (?P<hellos_sent>\\d+), +received: +(?P<hellos_received>\\d+), +interval: +(?P<hello_interval>\\d+) +sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +instance: +(?P<rsvp_neighbor_remote_instance>[^\\s,]+), +Local +instance: +(?P<rsvp_neighbor_local_instance>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Refresh +reduction: +(?P<rsvp_refresh_reduct_status>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Remote +end: +(?P<rsvp_refresh_reduct_remote_status>[^\\s,]+), +Ack-extension: +(?P<rsvp_refresh_reduct_ack_status>[^\\s,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enhanced +FRR: +(?P<rsvp_nbr_enh_lp_status>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LSPs +\\(total +(?P<rsvp_nbr_enh_lp_total_lsp_count>\\d+)\\): +Phop +(?P<rsvp_nbr_enh_lp_phop_lsp_count>\\d+), +PPhop +(?P<rsvp_nbr_enh_lp_pphop_lsp_count>\\d+), +Nhop +(?P<rsvp_nbr_enh_lp_nhop_lsp_count>\\d+), +NNhop +(?P<rsvp_nbr_enh_lp_nnhop_lsp_count>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<session_type>\\S+) RSVP: +(?P<count>\\d+) +sessions$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +(?P<display_count>\\d+) +displayed, +Up +(?P<up_count>\\d+), +Down +(?P<down_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<destination_address>[\\d\\.]+) +(?P<source_address>[\\d\\.]+) +(?P<lsp_state>\\S+) +(?P<route_count>\\d+) +(?P<rsb_count>\\d+) +(?P<resv_style>\\S+) +(?P<label_in>\\S+) +(?P<label_out>\\S+) +(?P<name>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show smnp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<name>\\S+) += +(?P<object_value>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^location +(?P<location>.+);+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^contact +(?P<contact>.+);+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(community +(?P<name>.+) +\\{)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(authorization +(?P<authorization>.+);)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<client>((\\d+\\.[\\d\\.]+\\/[\\d]+)|(\\w+\\:[\\w\\:]+\\/[\\d]+)|(0x\\d+))([\\s\\S])*);$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^source-address +(?P<source_address>.+);$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^trap-group +(?P<name>.+) +\\{$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^version +(?P<version>.+);$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^categories +\\{(?P<categories>.+);$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<target>((\\d+\\.[\\d\\.]+)|(\\w+\\:[\\w\\:]+)|(0x\\d+)));$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SNMP +statistics:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^V3 Input:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Output:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Performance:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(Average response time\\(ms\\): (?P<average_response_time>\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Number of requests dispatched to subagents in last:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(1 minute:(?P<one_minute_request_throughput>\\S+))|(5 minutes:(?P<five_minute_request_throughput>\\S+))|(15 minutes:(?P<fifteen_minute_request_throughput>\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Number of responses dispatched to NMS in last:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(1 minute:(?P<one_minute_response_throughput>\\S+))|(5 minutes:(?P<five_minute_response_throughput>\\S+))|(15 minutes:(?P<fifteen_minute_response_throughput>\\S+))$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show system",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^USER +TTY +FROM +LOGIN@ +IDLE +WHAT *$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<user>\\S+) +(?P<tty>\\S+) +(?P<from>\\S+) +(?P<login>\\S+) +(?P<idle>\\S+) +(?P<command>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^input +protocol +bytes +max +packets +max +drops$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<output>\\S+: +No +such +file +or +directory)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^total +files: +(?P<total_files>\\d)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current time: +(?P<current_time>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time Source: +(?P<time_source>[\\w\\s\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^System booted: +(?P<date_time>[\\w\\s\\-\\:]+) +\\((?P<time_length>[\\w\\s\\:]+)\\s+ago\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Protocols started: +(?P<date_time>[\\w\\s\\-\\:]+) +\\((?P<time_length>[\\w\\s\\:]+)\\s+ago\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last configured: +(?P<date_time>[A-Za-z\\t .\\d\\-\\:]+)+\\((?P<time_length>[\\w+\\s\\d+\\:\\d]+) ago\\) by (?P<user>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<date_time>\\d+\\:\\w+)\\s+up\\s+((?P<days>\\d+)\\s+day(s)?,\\s+)?(?P<mins>[\\w\\:]+)[^,]*,\\s+(?P<user_count>\\d+)\\s+users,\\s+load\\s+averages:\\s+(?P<avg1>[\\d\\.]+),\\s+(?P<avg2>[\\d\\.]+),\\s+(?P<avg3>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Model: +(?P<hardware_model>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Family: +(?P<os_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Junos: +(?P<os_version>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hostname: +(?P<host_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active +Internet +connections +\\(including servers\\) *$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Proto +Recv-Q +Send-Q +Local +Address +Foreign +Address +\\(state\\) *$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<proto>\\S+) +(?P<recv_q>\\S+) +(?P<send_q>\\S+) +(?P<local_address>\\S+) +(?P<foreign_address>\\S+) +(?P<state>.*)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show task",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Stateful +Replication: +(?P<task_gres_state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RE +mode: +(?P<task_re_mode>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Currently +In +Use: +(?P<task_memory_in_use_size>\\d+) +(?P<task_memory_in_use_avail>\\d+)% +(?P<task_memory_in_use_size_status>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +Ever +Used: +(?P<task_memory_max_size>\\d+) +(?P<task_memory_max_avail>\\d+)% +(?P<task_memory_max_when>[\\d\\/\\s\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Available: +(?P<task_memory_free_size>\\d+) +(?P<task_memory_free_size_avail>\\d+)% +(?P<task_memory_free_size_status>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show ted",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^TED +database: +(?P<isis_nodes>\\d+) +ISIS +nodes +(?P<inet_nodes>\\d+) +INET +nodes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NodeID: +(?P<node_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Type: +(?P<type>[\\w-]+), +Age: +(?P<age>\\d+) +secs, +LinkIn: +(?P<link_in>\\d+), +LinkOut: +(?P<link_out>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Protocol: +(?P<protocol>[\\w().]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^To: +(?P<to>\\S+), +Local: +(?P<local>\\S+), +Remote: +(?P<remote>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +interface +index: +(?P<local_interface_index>\\d+), +Remote +interface +index: +(?P<remote_interface_index>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Color: +(?P<color>[\\w<> ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric: +(?P<metric>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Static +BW: +(?P<static_bw>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Reservable +BW: +(?P<reservable_bw>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\[(?P<priority>\\d+)\\] +(?P<bw>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Switching +type: +(?P<switching_type>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Encoding +type: +(?P<encoding_type>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address_family>\\w+), +SID: +(?P<sid>\\d+), +Flags: +(?P<flags>\\w+), +Weight: +(?P<weight>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<prefix>\\S+/\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flags: +(?P<flags>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SRGB +block +\\[Start: +(?P<start>\\d+), +Range: +(?P<range>\\d+), +Flags: +(?P<flags>\\w+)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Algo: +(?P<algo>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TED +database: +(?P<isis_nodes>\\d+) +ISIS +nodes +(?P<inet_nodes>\\d+) +INET +nodes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ted_database_id>\\S+) +(?P<ted_database_type>\\S+) +(?P<ted_database_age>\\d+) +(?P<ted_database_link_in>\\d+) +(?P<ted_database_link_out>\\d+) +(?P<ted_database_protocol>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^To: +(?P<ted_link_to>\\S+), +Local: +(?P<ted_link_local_address>\\S+), +Remote: +(?P<ted_link_remote_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +interface +index: +(?P<ted_link_local_ifindex>\\d+), +Remote +interface +index: +(?P<ted_link_remote_ifindex>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "show version",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Hostname: +(?P<host_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Model: +(?P<product_model>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Junos: +(?P<junos_version>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<output>\\AJLAUNCHD+[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<output>\\Asmartd+[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<output>\\ACopyright+[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<comment>JUNOS[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<comment>KERNEL[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<component>[\\w\\s\\-]+)release +(?P<release>\\S+) +built +by +(?P<builder>\\S+) +on +(?P<build_date>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<re_name>\\Are0+)+:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hostname: +(?P<host_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Model: +(?P<product_model>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Junos: +(?P<junos_version>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<output>\\AJLAUNCHD+[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<output>\\Asmartd+[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<output>\\ACopyright+[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<comment>JUNOS[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<comment>KERNEL[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<component>[\\w\\s\\-]+)release +(?P<release>\\S+) +built +by +(?P<builder>\\S+) +on +(?P<build_date>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "junos",
        "command": "traceroute",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^traceroute(6)? +to +(?P<domain>\\S+) +\\((?P<address>\\S+)\\)( +from +(?P<source>\\S+))?, +(?P<max_hops>\\S+) +hops +max, +(?P<packet_size>\\S+) +byte +packets$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<hop_number>\\S+) +( +(?P<router_name>\\S+))? +(?P<address>\\S+) +(?P<round_trip_time>\\S+ +ms +\\S+ +ms +\\S+ +ms)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "linux",
        "command": "ifconfig",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<interface>\\S+): +flags=(?P<flags>\\S+) +mtu +(?P<mtu>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^inet +(?P<ip>\\S+) +netmask +(?P<netmask>\\S+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^inet6 +(?P<ip>\\S+) +prefixlen +(?P<prefixlen>\\d+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>\\S+)( +(?P<mac>\\S+))?( +txqueuelen +(?P<txqueuelen>\\d+))? ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RX +packets +(?P<rx_pkts>\\d+) +bytes +(?P<rx_bytes>\\d+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RX +errors +(?P<rx_errors>\\d+) +dropped +(?P<rx_dropped>\\d+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TX +packets +(?P<tx_pkts>\\d+) +bytes +(?P<tx_bytes>\\d+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TX +errors +(?P<tx_errors>\\d+) +dropped +(?P<tx_dropped>\\d+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^device( +interrupt +(?P<device_interrupt>\\d+))? ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+)\\s+Link\\s+encap:(?P<description>\\S+(\\s+\\S+)*?)(\\s+HWaddr\\s+\\S+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<flags>[\\S+|\\s]+?)\\s+MTU:(?P<mtu>\\d+)\\s+\\S+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?!bytes).)*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^inet\\s+addr:(?P<ip>(\\S+))\\s+(Bcast:(?P<broadcast>\\S+)\\s+)?Mask:(?P<netmask>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RX\\spackets:(?P<rx_pkts>\\d+)\\serrors:(?P<rx_errors>\\d+)\\sdropped:(?P<rx_dropped>\\d+)\\soverruns:(?P<rx_overruns>\\d+)\\sframe:(?P<rx_frame>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TX\\spackets:(?P<tx_pkts>\\d+)\\serrors:(?P<tx_errors>\\d+)\\sdropped:(?P<tx_dropped>\\d+)\\soverruns:(?P<tx_overruns>\\d+)\\scarrier:(?P<tx_carrier>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^collisions:(?P<tx_collisions>\\d+)\\stxqueuelen:(?P<txqueuelen>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RX\\sbytes:(?P<rx_bytes>\\d+)\\s\\((?P<rx_value>.*?)\\)\\s+TX\\sbytes:(?P<tx_bytes>\\d+)\\s\\((?P<tx_value>.*?)\\)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "linux",
        "command": "ps",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<uid>\\S+)\\s+(?P<pid>\\d+)\\s+(?P<ppid>\\d+)\\s+(?P<c>\\S+)\\s+(?P<stime>\\S+)\\s+(?P<tty>\\S+)\\s+(?P<time>\\S+)\\s+(?P<cmd>.+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "linux",
        "command": "vimcmd",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<vmid>\\S+)\\s+(?P<name>\\S+)\\s+(?P<file>\\S+\\s+\\S+)\\s+(?P<guest_os>\\S+)\\s+(?P<version>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<vmid>\\S+)\\s+(?P<name>\\S+)\\s+(?P<file>\\S+\\s+\\S+)\\s+(?P<guest_os>\\S+)\\s+(?P<version>\\S+)\\s+(?P<annotation>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^.*Snapshot\\s+Id\\s+:\\s+(?P<id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^.*Snapshot\\s+Name\\s+:\\s+(?P<name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^.*Snapshot\\s+Desciption\\s+:\\s+(?P<description>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^.*Snapshot\\s+Created\\s+On\\s+:\\s+(?P<created>\\S+\\s+\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^.*Snapshot\\s+State\\s+:\\s+(?P<state>\\S+\\s+\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show acl",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<type>[A-Z0-9]+) +ACL +(?P<name>[a-z0-9_]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show arp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^IP +ARP +Table +for +(context +)?(?P<vrf>[\\S]+)( +contexts)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +number +of +entries:\\s+(?P<num_entries>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_address>[\\d\\.]+)\\s+(?P<age>[\\d:-]+)\\s+(?P<mac_address>[\\w\\.]+)\\s+((?P<encap_type>ARPA)\\s+)?(?P<interface>\\S+)(\\s+(?P<flags>\\S))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address>[\\d\\.]+) +(?P<age>[\\d+\\-\\:]+) +(?P<mac>[\\w\\.]+) +(?P<interface>\\S+) +(?P<physical_interface>\\S+)( +(?P<flag>[\\*\\w\\+\\#]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Resolved +: +(?P<resolved>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Incomplete +: +(?P<incomplete>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Unknown +: +(?P<unknown>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Total +: +(?P<total>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Sent:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Received:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Total +(?P<total>[\\w]+), +Requests +(?P<requests>[\\w]+), +Replies +(?P<replies>[\\w]+), +Requests +on +L2 +(?P<l2_requests>[\\w]+), +Replies +on +L2 +(?P<l2_replies>[\\w]+)(,)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Gratuitous +(?P<gratuitous>[\\w]+), +Tunneled ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Proxy +arp +(?P<proxy_arp>[\\w]+), +Local-Proxy +arp +(?P<local_proxy_arp>[\\w]+),( +Enhanced +Proxy +arp +(?P<enhanced_proxy_arp>[\\w]+),)?( +Anycast +proxy +Proxy +arp +(?P<anycast_proxy_arp>[\\w]+),)?( +L2 +Port-track +Proxy +arp +(?P<l2_port_track_proxy_arp>[\\w]+),?)?( +Tunneled +(?P<tunneled>[\\w]+))?,?( +Fastpath +(?P<fastpath>[\\w]+))?,?( +Snooped +(?P<snooped>[\\w]+))?,?( +Dropped +(?P<dropped>[\\w]+))?,?( +on +Server +Port +(?P<dropped_server_port>[\\w]+))?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MBUF +operation +failed +: +(?P<mbuf_operation_failed>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Context +not +yet +created +: +(?P<context_not_created>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Invalid +context +: +(?P<invalid_context>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Invalid +ifindex +: +(?P<invalid_ifindex>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Invalid +SRC +IP +: +(?P<invalid_src_ip>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Invalid +DEST +IP +: +(?P<invalid_dest_ip>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Destination +is +our +own +IP +: +(?P<destnination_is_our_own_ip>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Unattached +IP +: +(?P<unattached_ip>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Adjacency +Couldn\\+(?P<adjacency_couldnt_be_added>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Null +Source +IP +: +(?P<null_source_ip>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Null +Source +MAC +: +(?P<null_source_mac>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Client +Enqueue +Failed +: +(?P<client_enqueue_failed>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Dest. +not +reachable +for +proxy +arp +: +(?P<dest_not_reachable_for_proxy_arp>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Dest. +unreachable +for +enhanced +proxy( +)?: +(?P<dest_unreachable_for_enhanced_proxy>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Dest. +on +L2 +port +being +tracked +: +(?P<destnination_on_l2_port_tracked>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Invalid +Local +proxy +arp +: +(?P<invalid_local_proxy_arp>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Invalid +proxy +arp +: +(?P<invalid_proxy_arp>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VIP +is +not +active +: +(?P<vip_is_not_active>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ARP +refresh +skipped +over +core +and +flooded +on +server +: +(?P<arp_refresh_skipped_over_core_and_flooded>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Appeared +on +a +wrong +interface +: +(?P<appeared_on_a_wrong_interface>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Incorrect +length +: +(?P<incorrect_length>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Invalid +protocol +packet +: +(?P<invalid_protocol_packet>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Invalid +Hardware +type +: +(?P<invalid_hardwaretype>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ARP adjacency statistics$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Invalid +layer +2 +address +length +: +(?P<invalid_layer2_address_length>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Invalid +source +IP +address +: +(?P<invalid_source_ip_address>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Source +IP +address +is +our +own +: +(?P<source_ip_address_is_our_own>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*No +mem +to +create +per +intf +structure +: +(?P<no_mem_to_create_per_intf_structure>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Invalid +layer +3 +address +length +: +(?P<invalid_layer3_address_length>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Source +address +mismatch +with +subnet +: +(?P<source_address_mismatch_with_subnet>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Directed +broadcast +source +: +(?P<directed_broadcast_source>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Invalid +destination +IP +address +: +(?P<invalid_destination_ip_address>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Non-local +destination +IP +address +: +(?P<non_local_destination_ip_address>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Invalid +source +MAC +address +: +(?P<invalid_source_mac_address>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Source +MAC +address +is +our +own +: +(?P<source_mac_address_is_our_own>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Received +before +arp +initialization +: +(?P<received_before_arp_initialization>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*L2 +packet +on +untrusted +L2 +port +: +(?P<l2_packet_on_untrusted_l2_port>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Packet +with +VIP +on +standby +FHRP +: +(?P<packet_with_vip_on_standby_fhrp>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Requests +came +for +exising +entries +: +(?P<requests_came_for_exising_entries>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Requests +came +on +a +(l|L)2 +interface +: +(?P<requests_came_on_a_l2_interface>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*L2FM +query +failed +for +a +L2 +Address +: +(?P<l2fm_query_failed_for_a_l2address>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Dropping due to tunneling failures +: +(?P<dropping_due_to_tunneling_failures>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Glean +requests +recv +count +: +(?P<glean_requests_recv_count>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ARP +refresh +requests +received +from +clients: +(?P<arp_refresh_requests_received_from_clients>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Number +of +Signals +received +from +L2rib +: +(?P<number_of_signals_received_from_l2rib>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Adds +(?P<adjacency_adds>[\\w]+), +Deletes +(?P<adjacency_deletes>[\\w]+), +Timeouts +(?P<adjacency_timeouts>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Failed +due +to +limits: +(?P<failed_due_to_limits>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Non-active +FHRP +dest +IP +address. +Learn +and +drop$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Grat +arp +received +on +proxy-arp-enabled +interface$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*: +(?P<statistic_number>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<fastpath>[\\w]+)\\,( +Snooped +(?P<snooped>[\\w]+))?\\,?( +Dropped +(?P<dropped>[\\w]+))\\,?( +on +Server +Port +(?P<dropped_server_port>[\\w]+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Source +IP +address +is +our +own +\\: +(?P<source_ip_address_is_our_own>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show bgp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*BGP +Process +ID *: +(?P<bgp_pid>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP Protocol Started, +reason: *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +Performance +Mode: *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +Protocol +Tag *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +Protocol +State *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +Isolate +Mode *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +MMODE *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +Memory +State *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +asformat *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Segment +Routing +Global +Block *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Number +of +attribute +entries *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*HWM +of +attribute +entries *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Bytes +used +by +entries *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Entries +pending +delete *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*HWM +of +entries +pending +delete *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +paths +per +attribute +HWM *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +AS +path +entries *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Bytes +used +by +AS +path +entries *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +Information +for +VRF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VRF +Id *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VRF +state *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VNID *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Topo +Id *: +(?P<topo_id>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Encap +type *: +(?P<etype>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VTEP +IP *: +(?P<vtep_ip>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VTEP +Virtual +IP *: +(?P<vtep_vip>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VTEP +VIP-R *: +(?P<vipr>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Router-MAC *: +(?P<router_mac>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VIP +Derived +MAC *: +(?P<vipd_mac>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Router-ID *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Configured +Router-ID *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Confed-ID *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Cluster-ID *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*No. +of +configured +peers *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*No. +of +pending +config +peers *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*No. +of +established +peers *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VRF +RD *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VRF +EVPN +RD *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Information +for +address +family",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Table +Id *: +(?P<table_id>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Table +state *: +(?P<table_state>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<peers>[0-9]+) +(?P<active_peers>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<name>[a-zA-Z]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<type>(Export|Import|EVPN Export|",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<rt_list>(\\d+)\\:(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Label +mode *: +(?P<label_mode>[a-zA-Z\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Is +a +Route\\-reflector$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Aggregate +label *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Allocate-index *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Import +default +limit *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Import +default +prefix +count *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Import +default +map *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Export +default +limit *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Export +default +prefix +count *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Export +default +map *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Nexthop +trigger-delay$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*critical +(?P<critical>[0-9]+) +ms$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*non-critical +(?P<non_critical>[0-9]+) +ms$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*template +peer-session ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*template +peer-policy",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*template +peer",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Remote +AS +(?P<remote_as>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Inherits +session +configuration",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Description *: +(?P<desc>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Using +(?P<update_source>(\\S+)) +as",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Connected check is disabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BFD live-detection +is +configured$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*External +BGP +peer +might +be +upto",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*TCP +MD5 +authentication +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Only +passive +connection +setup",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Neighbor +local-as +command",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Private +AS +numbers +removed +from",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Hold +time += +(?P<holdtime>[0-9]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +routing +table +information +for +VRF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +version +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<next_hop>[a-zA-Z0-9\\.\\:\\/\\[\\]\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +Distinguisher *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +neighbor +is +(?P<neighbor_id>[a-zA-Z0-9\\.\\:]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Description *: +(?P<description>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +version +(?P<bgp_version>[0-9]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\s*BGP +state += +(?P<session_state>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Using +(?P<update_source>[a-zA-Z0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BFD live-detection is configured",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Neighbor +local-as +command",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last +read +(?P<last_read>[a-zA-Z0-9\\:]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last +written",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Inherits +session +configuration +from",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Connected check is disabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Private +AS +numbers +removed +from +updates +sent +to +this +neighbor$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*External +BGP +peer +might +be +upto",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*External +BGP +peer +might +be +up to",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*TCP +MD5 +authentication +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Only +passive +connection +setup +allowed$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Received +(?P<received_messages>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Sent +(?P<sent_messages>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Connections +established",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Connections +attempts",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last +reset +by (?P<reset_by>[a-zA-Z]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Neighbor +capabilities *:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Dynamic +capability *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Dynamic +capability +\\(old\\) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +refresh +capability +\\(new\\) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +refresh +capability +\\(old\\) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*4-Byte AS capability: +(?P<capability>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Address +family +VPNv4 +Unicast *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Address +family +VPNv6 +Unicast *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Address +family +IPv4 +MVPN:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Graceful +Restart +capability *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Graceful +Restart +Parameters *:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Restart +time +advertised +to +peer *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Restart +time +advertised +by +peer *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Stale +time +for +routes +advertised +by",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<message_stat>[a-zA-Z\\s]+) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*For +address +family *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +version\n                            ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<accepted_paths>[0-9]+) +accepted",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<num_sent_paths>[0-9]+) +sent +paths$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Community +attribute +sent +to +this",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Extended +community +attribute +sent +to",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Maximum +prefixes +allowed +(?P<num>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Inbound +route-map +configured +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Outbound +route-map +configured +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Third-party +Nexthop +will +not +be",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*SOO +Extcommunity *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Inbound +soft +reconfiguration +allowed$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Nexthop(?: +always)? +set +to +local +peering",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Allow +my +ASN +(?P<num>[0-9]+) +times$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ASN override is enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Default +information +originate,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<inherit_peer_seq>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Local +host *: +(?P<local_host>[0-9\\.\\:]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Foreign +host *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*fd += +(?P<fd>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route reflector client$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Next +Hop +table +for +VRF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Critical *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Nexthop *: +(?P<nh>[a-zA-Z0-9\\.\\:]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IGP +Route +type *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Nexthop +is +(?P<attached>[\\w\\-]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Nexthop +last +resolved *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Metric +next +advertise *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RNH +epoch *: +(?P<rnh_epoch>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Attached +nexthop *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +summary +information +for +VRF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +router +identifier",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +version +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<networks>[0-9]+) +network +entries +and",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +attribute +entries",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +community +entries",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Dampening +configured,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<val>[0-9]+) +received +paths +for +inbound +soft +reconfiguration$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<val1>[0-9]+) +identical, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<neighbor>[a-zA-Z0-9\\.\\:]+) +(?P<v>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<neighbor>[a-zA-Z0-9\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<v>[0-9]+) +(?P<as>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +(?P<route>\\w+) +Dampening +Parameters ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +Distinguisher: +(?P<rd>[0-9\\.:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +Distinguisher: +(?P<rd>[0-9\\.:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dampening +policy +configured: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Half-life +time +: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Suppress +penalty +: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Reuse +penalty +: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Max +suppress +time +: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Max +suppress +penalty +: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Peer +(?P<neighbor_id>(\\S+)) +routes +for +address +family +(?P<address_family>[a-zA-Z0-9\\s\\-\\_]+) *:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +version +is +(?P<bgp_table_version>[0-9]+), +[Ll]ocal +[Rr]outer +ID +is +(?P<local_router_id>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?(?P<path_type>(i|e|c|l|a|r|I))?(?P<prefix>[a-zA-Z0-9\\.\\:\\/\\[\\]\\,]+)(?: *(?P<next_hop>[a-zA-Z0-9\\.\\:\\/\\[\\]\\,]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?(?P<path_type>(i|e|c|l|a|r|I))? *(?P<next_hop>[a-zA-Z0-9\\.\\:]+)(?: +(?P<numbers>[a-zA-Z0-9\\s\\(\\)\\{\\}]+))? +(?P<origin_codes>(i|e|\\?|\\|))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(\\*\\>|s|x|S|d|h|\\*|\\>|\\s)+)(?P<path_type>(i|e|c|l|a|r|I))?( *(?P<origin_codes>(i|e|\\?|\\&|\\|)+)) +(?P<next_hop>[a-zA-Z0-9\\.\\:]+) +(?P<numbers>[a-zA-Z0-9\\s\\(\\)\\{\\}\\?]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<metric>[0-9]+)(?P<space1>\\s{5,10})(?P<localprf>[0-9]+)(?P<space2>\\s{5,10})(?P<weight>[0-9]+)(?: *(?P<path>[0-9\\{\\}\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<value>[0-9]+)(?P<space>\\s{2,21})(?P<weight>[0-9]+)(?: *(?P<path>[0-9\\{\\}\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<weight>[0-9]+) +(?P<path>[0-9\\{\\}\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)(?P<path_type>(i|e|c|l|a|r|I))(?P<prefix>[a-zA-Z0-9\\.\\:\\/\\[\\]\\,]+) +(?P<next_hop>[a-zA-Z0-9\\.\\:]+) +(?P<numbers>[a-zA-Z0-9\\s\\(\\)\\{\\}]+) +(?P<origin_codes>(i|e|\\?|\\&|\\|))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(\\*\\>|s|x|S|d|h|\\*|\\>|\\s)+)(?P<path_type>(i|e|c|l|a|r|I))?( *(?P<origin_codes>(i|e|\\?|\\&|\\|)+))(?P<prefix>[a-zA-Z0-9\\.\\:\\/\\[\\]\\,]+) +(?P<next_hop>[a-zA-Z0-9\\.\\:]+) +(?P<numbers>[a-zA-Z0-9\\s\\(\\)\\{\\}\\?]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<metric>[0-9]+)(?P<space1>\\s{5,10})(?P<localprf>[0-9]+)(?P<space2>\\s{5,10})(?P<weight>[0-9]+)(?: *(?P<path>[0-9\\{\\}\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<value>[0-9]+)(?P<space>\\s{2,21})(?P<weight>[0-9]+)(?: *(?P<path>[0-9\\{\\}\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<weight>[0-9]+) +(?P<path>[0-9\\{\\}\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +Distinguisher *: +(?P<route_distinguisher>(\\S+))(?: +\\((?:VRF +(?P<default_vrf>\\w+)|L2VNI +(?P<rd_l2vni>\\d+)|L3VNI +(?P<rd_l3vni>\\d+))\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Peer +(?P<neighbor_id>(\\S+)) +routes +for",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +version +is\n                            ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +Distinguisher *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Peer +(?P<neighbor_id>(\\S+)) +routes +for",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +version +is\n                            ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<status_codes>(s|x|S|d|h|\\*|\\>|\\s)+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +Distinguisher *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*router +bgp +(?P<bgp_id>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*shutdown$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*evpn$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vni +(?P<evpn_vni>\\d+) +l2$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*rd +(?P<rd>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-target +(?P<evpn_vni_rt_type>[\\w]+) +(?P<evpn_vni_rt>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vrf +(?P<vrf>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*rd +(?P<rd>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*bestpath +(?P<best_path>[a-z\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*cluster-id +(?P<cluster_id>[0-9\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*confederation +identifier +(?P<confederation_identifier>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*confederation +peers +(?P<confederation_peers_as>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*no graceful-restart$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*graceful-restart",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*log-neighbor-changes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*router-id +(?P<router_id>[0-9\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*timers +bgp +(?P<keepalive_interval>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*no enforce-first-as$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*no fast-external-fallover$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*dynamic-med-interval +(?P<dynamic_med_interval>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*flush-routes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*isolate$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*disable-policy-batching ipv4 prefix-list +(?P<disable_policy_batching_ipv4>[a-zA-Z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*disable-policy-batching ipv6 prefix-list +(?P<disable_policy_batching_ipv6>[a-zA-Z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*address-family +(?P<af_name>[a-z0-9\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-target +(?P<af_evpn_vni_rt_type>[\\w]+) +(?P<af_evpn_vni_rt>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*dampening ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*dampening +route-map +(?P<af_dampening_route_map>[A-Z0-9\\-\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*nexthop +route-map +(?P<af_nexthop_route_map>[A-Za-z0-9\\-\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*nexthop +trigger-delay +critical +(?P<af_nexthop_trigger_delay_critical>[0-9]+) +non-critical +(?P<af_nexthop_trigger_delay_non_critical>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*no nexthop trigger-delay$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*no client-to-client reflection$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*distance +(?P<af_distance_extern_as>[0-9]+) +(?P<af_distance_internal_as>[0-9]+) +(?P<af_distance_local>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*maximum-paths( +(?P<af_maximum_paths_type>[a-z]+))? +(?P<af_maximum_paths_value>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)additional-paths send",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)additional-paths receive",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)default-information originate",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*maximum-paths +eibgp +(?P<af_maximum_paths_eibgp>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*aggregate-address +(?P<af_aggregate_address_address>[a-z0-9\\.\\:]+)(\\/(?P<af_aggregate_address_ipv4_mask>[0-9]+))?( +(?P<extra_line>[a-z\\-\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*network +(?P<af_network_number>[0-9\\.\\:]+)( +mask +(?P<af_network_mask>[0-9\\.]+))?( +route-map +(?P<af_network_route_map>[A-Za-z0-9\\-\\_]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*network +(?P<af_network_number>[0-9\\.]+)\\/(?P<af_network_mask>[0-9]+)( +route-map +(?P<af_network_route_map>[A-Za-z0-9\\-\\_]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*redistribute +isis +(?P<af_redist_isis>[0-9]+) +route-map +(?P<af_redist_isis_route_policy>[A-Za-z0-9\\-\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*redistribute +isis +(?P<af_redist_isis>[0-9]+) +route-map +(?P<af_redist_isis_route_policy>[A-Za-z0-9\\-\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*redistribute +(ospf|ospfv3) +(?P<af_redist_ospf>[0-9]+) +route-map +(?P<af_redist_ospf_route_policy>[A-Za-z0-9\\-\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*redistribute +rip +(?P<af_redist_rip>[0-9]+) +route-map +(?P<af_redist_rip_route_policy>[A-Za-z0-9\\-\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*redistribute +static +route-map +(?P<af_redist_static_route_policy>[A-Za-z0-9\\-\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*redistribute +direct +route-map +(?P<af_redist_connected_route_policy>[A-Za-z0-9\\-\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*allocate-label all$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*retain route-target all$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*label-allocation-mode +(?P<per_vrf>[A-Za-z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*neighbor +(?P<neighbor_id>[a-z0-9\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*bfd$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*capability suppress 4-byte-as$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*description +(?P<nbr_description>[A-Za-z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*disable-connected-check$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ebgp-multihop +(?P<nbr_ebgp_multihop_max_hop>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*inherit peer-session +(?P<nbr_inherit_peer_session>[A-Za-z0-9\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*local-as +(?P<nbr_local_as_as_no>[0-9\\.]+)( +(?P<no_prepend>no-prepend)( +(?P<replace_as>replace-as)( +(?P<dual_as>dual-as))?)?)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*remote-as +(?P<nbr_remote_as>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*remove-private-as$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*shutdown$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*timers +(?P<nbr_keepalive_interval>[0-9]+) +(?P<nbr_holdtime>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*update-source +(?P<nbr_update_source>[A-Za-z0-9\\/\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*password +(?P<nbr_password_text>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*transport connection-mode +(?P<nbr_transport_connection_mode>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*address-family +(?P<nbr_af_name>[A-Za-z0-9\\s\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*allowas-in( +(?P<nbr_af_allowas_in_as_number>[0-9]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*inherit peer-policy +(?P<nbr_af_inherit_peer_policy>[A-Za-z0-9\\-]+) +(?P<nbr_af_inherit_peer_seq>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*maximum-prefix +(?P<nbr_af_maximum_prefix_max_prefix_no>[0-9]+)( +(?P<nbr_af_maximum_prefix_threshold>[0-9]+))?( +restart +(?P<nbr_af_maximum_prefix_restart>[0-9]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*maximum-prefix +(?P<nbr_af_maximum_prefix_max_prefix_no>[0-9]+)( +(?P<nbr_af_maximum_prefix_threshold>[0-9]+))?( +(?P<nbr_af_maximum_prefix_warning_only>warning-only))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?:no )?route-map +(?P<nbr_af_route_map_name_in>.*) in$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?:no )?route-map +(?P<nbr_af_route_map_name_out>.*) out$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-reflector-client$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*send-community$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*send-community +extended$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*soft-reconfiguration inbound( +(?P<nbr_af_soft_reconfiguration_extra>.*))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*next-hop-self$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*as-override$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*default-originate( +route-map +(?P<nbr_af_default_originate_route_map>.*))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*soo +(?P<nbr_af_soo>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*template peer-session +(?P<ps_name>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*bfd$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*bfd$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*description +(?P<ps_description>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*disable-connected-check$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ebgp-multihop +(?P<ps_ebgp_multihop_max_hop>[0-9]+)$$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*local-as +(?P<ps_local_as_as_no>[0-9\\.]+)( +no-prepend( +replace-as( +dual-as)?)?)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*password +(?P<ps_password_text>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*remote-as +(?P<ps_remote_as>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*shutdown$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*timers +(?P<ps_keepalive_interval>[0-9]+) +(?P<ps_hodltime>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*transport connection-mode +(?P<ps_transport_connection_mode>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*update-source +(?P<ps_update_source>[A-Za-z0-9\\/\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*template peer-policy +(?P<pp_name>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*allowas-in( +(?P<pp_allowas_in_as_number>[0-9]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*as-override$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*default-originate( +route-map +(?P<pp_default_originate_route_map>.*))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-map +(?P<pp_route_map_name_in>.*) in$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-map +(?P<pp_route_map_name_out>.*) out$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*maximum-prefix +(?P<pp_maximum_prefix_max_prefix_no>[0-9]+)( +(?P<nbr_af_maximum_prefix_threshold>[0-9]+))?(restart +(?P<nbr_af_maximum_prefix_restart>[0-9]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*maximum-prefix +(?P<pp_maximum_prefix_max_prefix_no>[0-9]+)( +(?P<pp_maximum_prefix_threshold>[0-9]+))?( +(?P<pp_maximum_prefix_warning_only>warning-only))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*next-hop-self$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-reflector-client$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*send-community$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*send-community +extended$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*soft-reconfiguration inbound( +(?P<nbr_af_soft_reconfiguration_extra>.*))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*soo +(?P<pp_soo>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Flap +Statistics +for +VRF +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dampening +configured, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dampening +not +configured, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +Distinguisher: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<status>[\\*|d|s|h|\\s])?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<status>[\\*|d|s|h|\\s])?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +peer\\-template +is +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Using +(?P<intf>[\\w\\-\\/\\.]+) +as",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer +is +low\\-memory +exempt$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Disable +logging +neighbor +events$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^External +BGP +peer +might +be +up +to",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Only +passive +connection +setup +allowed$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +local\\-as +command +not +active$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^For +address +family: +(?P<af>[\\w\\s\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Condition\\-map +(?P<con_map>[\\w\\-]+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Inbound +soft +reconfiguration +allowed(?: *\\(always\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Community +attribute +sent +to +this +neighbor$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Extended +community +attribute +sent +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Nexthop(?: +always)? +set +to +local +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Third\\-party +Nexthop +will +not +be +computed.$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +prefixes +allowed +(?P<max_pfx>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SOO +Extcommunity: +(?P<soo>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Weight: +(?P<weight>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Allow +my +ASN +(?P<asn>\\d+) +times$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ASN +override +is +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer +ASN +check +is +disabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Inbound +(?P<type>[\\w\\-\\s]+) +configured",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Outbound +(?P<type>[\\w\\-\\s]+) +configured",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Default +information +originate(, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unsuppress\\-map +(?P<map>[\\w\\-]+) +configured$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Members +of +peer\\-template +(?P<peer>[\\w\\-]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<vrf>[\\w\\-]+): +(?P<neighbor>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Details +for +VRF +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +count +for +(?P<type>\\w+) +rpm +handles: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +policy +statistics +not +available$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^route\\-map +(?P<name>\\S+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<command>[\\w\\s\\-\\>]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +accept +count +for +policy: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +reject +count +for +policy: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +peers +(?P<total>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ASN +(?P<asn>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRF +(?P<vrf>\\S+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^peers +(?P<peer>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nei>[\\w\\.\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +routing +table +information +for +VRF +(?P<vrf>\\S+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BGP +table +version +is +(?P<ver>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Route +Distinguisher: +(?P<rd>[\\w\\.\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<status>s|S|x|d|h|\\*)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_label>\\w+)\\/(?P<out_label>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +summary +information +for +VRF +(?P<vrf_name_out>[\\w]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +version +is +(?P<tableversion>[\\d]+), +(?P<af_name>[\\w\\s]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +attribute +entries +\\[(?P<numberattrs>[\\d]+)\\/(?P<bytesattrs>[\\d]+)\\],",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +community +entries +\\[(?P<numbercommunities>[\\d]+)\\/(?P<bytescommunities>[\\d]+)\\],",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +routing +table +information +for +VRF +(?P<vrf_name_out>[\\w]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route Distinguisher: +(?P<rd>[\\w\\.\\:]+)( +\\(ES +(?P<es>[\\w\\s\\[\\]\\.]+)\\))?( +\\((?P<rd_vrf>[\\w]+)VNI +(?P<rd_vniid>[\\d]+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP routing table entry for +(?P<nonipprefix>[\\w\\[\\]\\:\\.\\/]+), +version +(?P<prefixversion>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Paths: +\\((?P<totalpaths>[\\d]+) +available, +best +#(?P<bestpathnr>[\\d]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Flags: (?P<flag_xmit>[\\S\\s]+) +on +xmit-list(, +(?P<flags_attr>[\\w\\s\\/\\,]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multipath: +(?P<multipath>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Advertised path-id +(?P<path_id>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Path type: +(?P<path_type>[\\w\\s\\(\\)]+), +(?P<pathtypes>[\\S\\s\\,\\:\\/]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*AS-Path: +(?P<as_path>[\\w]+)(, +path locally originated)?(, +path sourced +(?P<internal_external>[\\w]+) to AS)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<ipnexthop>[\\d\\.]+) +\\((?:(?P<inaccessible>(inaccessible)), +)?metric +(?P<nexthopmetric>[\\d]+)\\) +from +(?P<neighbor>[\\d\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Origin +(?P<origin>[\\w]+), +(MED +(?P<med>[\\w\\s]+),)? +localpref +(?P<localpref>[\\d]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Extcommunity: +(?P<extcommunity>[\\w\\s\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Originator: +(?P<originatorid>[\\d\\.]+) +Cluster +list: +(?P<clusterlist>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Path-id +(?P<path_id>[\\d]+) +advertised to peers:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<advertisedto>[\\d\\s\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Received +label +(?P<inlabel>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<attribute>[\\w]+) +Tunnel +Attribute:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*flags: +(?P<flags>[\\w]+), +Tunnel type: +(?P<tunnel_type>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Label: +(?P<label>[\\d]+), +Tunnel +Id: +(?P<tunnel_id>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +neighbor +is +(?P<neighbor>[\\d\\.]+), remote AS +(?P<remoteas>[\\d]+), +(?P<link>[\\w]+) +link,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP version +(?P<version>[\\d]+), remote router ID +(?P<remote_id>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +state += +(?P<state>[\\w\\s\\(\\)]+), +(?P<up>[\\w]+) +for",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Peer is directly attached, interface +(?P<connectedif>[\\w\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BFD live-detection is configured and enabled, state is +(?P<bfd_state>[\\w]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*TCP MD5 authentication is set \\(enabled\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last read +(?P<lastread>[\\w\\:\\.]+), hold time = +(?P<holdtime>[\\d]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last written +(?P<lastwrite>[\\w\\:\\.]+), keepalive timer expiry due +(?P<keepalive>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Received +(?P<msgrecvd>[\\d]+) +messages, +(?P<notificationsrcvd>[\\d]+) +notifications,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Sent +(?P<msgsent>[\\d]+) messages,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Connections established +(?P<connsestablished>[\\d]+), +dropped +(?P<connsdropped>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last reset by us +(?P<resettime>[\\w]+), +due to +(?P<resetreason>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last reset by peer +(?P<peerresettime>[\\w]+), due to +(?P<peerresetreason>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Dynamic capability: advertised +\\(+(?P<cap_advertised>[\\w\\,\\s]+)\\) +received +\\(+(?P<cap_received>[\\w\\,\\s]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Dynamic capability \\(old\\): +(?P<capolddynamicadvertised>[\\w]+)( +(?P<capolddynamicrecvd>[\\w\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route refresh capability \\(new\\): +(?P<caprradvertised>[\\w]+)( +(?P<caprrrecvd>[\\w]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route refresh capability \\(old\\): +(?P<capoldrradvertised>[\\w]+)( +(?P<capoldrrrecvd>[\\w]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*4-Byte AS capability: +(?P<capas4advertised>[\\w]+)( +(?P<capas4recvd>[\\w]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Address family +(?P<af_name>[\\w\\s]+): +(?P<af_advertised>[a][\\w]+)( +(?P<af_recvd>[r][\\w]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Graceful Restart capability: +(?P<capgradvertised>[\\w]+)( +(?P<capgrrecvd>[\\w]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Graceful Restart Parameters:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Address families advertised to peer:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<space>\\s{4})((?P<gr_af_name>(?!Sent)[\\w].*)+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Address families received from peer:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Forwarding state preserved by peer for:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Restart time advertised to peer: +(?P<grrestarttime>[\\d]+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Stale time for routes advertised by peer: +(?P<grstaletiem>[\\d]+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Restart time advertised by peer: +(?P<grrecvdrestarttime>[\\d]+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Extended Next Hop Encoding Capability: +(?P<capextendednhadvertised>[\\w]+)( +(?P<capextendednhrecvd>[\\w]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Receive IPv6 next hop encoding Capability for AF:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<space>\\s{4})(?P<capextendednh_af_name>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Opens: +(?P<openssent>[\\d]+) +(?P<opensrecvd>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Notifications: +(?P<notificationssent>[\\d]+) +(?P<notificationsrcvd>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Updates: +(?P<updatessent>[\\d]+) +(?P<updatesrecvd>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Keepalives: +(?P<keepalivesent>[\\d]+) +(?P<keepaliverecvd>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route Refresh: +(?P<rtrefreshsent>[\\d]+) +(?P<rtrefreshrecvd>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Capability: +(?P<capabilitiessent>[\\d]+) +(?P<capabilitiesrecvd>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Total bytes: +(?P<bytessent>[\\d]+) +(?P<bytesrecvd>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Bytes in queue: +(?P<bytesinqueuesent>[\\d]+) +(?P<bytesinqueuerecvd>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*For address family: +(?P<per_af_name>[\\w\\ ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP table version +(?P<tableversion>[\\d]+), neighbor version +(?P<neighbortableversion>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<pfxrecvd>[\\d]+) +accepted paths consume +(?P<pfxbytes>[\\d]+) +bytes of memory$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Community attribute sent to this neighbor$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Extended community attribute sent to this neighbor$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last End-of-RIB received +(?P<lastendribreceived>[\\w\\:]+) +after session start$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last End-of-RIB sent +(?P<lastendribsent>[\\w\\:]+) +after session start$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*First convergence +(?P<rrconfigured>[\\w\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Local host: +(?P<localaddr>[\\d\\.]+), Local port: +(?P<localport>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Foreign host: +(?P<remoteaddr>[\\d\\.]+), Foreign port: +(?P<remoteport>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*fd = +(?P<fd>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Enhanced error processing\\: +(?P<error_processing>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<discarded_attr>\\d) +discarded +attributes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Last +error +length +received\\: +(?P<last_error_length_sent>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Reset +error +value +received(\\:)? +(?P<reset_error_value_sent>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Reset +error +sent +major\\: +(?P<reset_error_sent_major>\\d+) +minor\\: +(?P<reset_error_sent_minor>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Last +error +length +received\\: +(?P<last_error_length_received>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Reset error value received(\\:)? +(?P<reset_error_value_received>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Reset error received major\\: +(?P<reset_error_received_major>\\d+) +minor\\: +(?P<reset_error_received_minor>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<accepted_prefixes>\\d+) +accepted prefixes +\\(\\d+ +paths\\)\\, +consuming +(?P<memory_consumed_in_bytes>\\d+) +bytes +of +memory$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<received_prefixes>\\d+) +received +prefixes +treated +as +withdrawn$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<sent_prefixes>\\d+) +sent prefixes +\\(\\d+ paths\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Advertise +GW +IP +is +(?P<advertise_gw_ip>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Outbound +route\\-map +configured +is +(?P<outbound_route_map>\\w+)\\, +handle +obtained$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Last +End\\-of\\-RIB +(?P<action>received|sent) +(?P<time>[\\w:]+) +after +session +start$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*First +convergence +(?P<first_convergence>[\\w:]+) +after +session +start +with +(?P<convergence_routes_sent>\\d+) +routes +sent$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<next_hop>[0-9\\.]+) +\\(metric +(?P<metric>[0-9]+)\\).*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Received label +(?P<received_label>[0-9]+).*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +routing +table +information +for +VRF +(?P<vrf>\\S+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +table +version +is +(?P<table_version>[\\d]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +Distinguisher: +(?P<rd>[\\d\\.\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<statuscode>[s|S|x|d|h|>|s|*\\s]+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BGP +routing +table +information +for +VRF +(?P<vrf_name_out>\\S+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route Distinguisher: +(?P<rd>[\\w\\.\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Paths: +\\((?P<totalpaths>[\\d]+) +available,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Flags: (?P<flag_xmit>[\\S\\s]+) +on +xmit-list",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Advertised path-id +(?P<path_id>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Path type: +(?P<path_type>[\\w\\s\\(\\)]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Origin +(?P<origin>[\\w]+), +(MED +(?P<med>[\\w\\s]+),)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Extcommunity: +(?P<extcommunity>[\\w\\s\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Originator: +(?P<originatorid>[\\d\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Path-id +(?P<path_id>[\\d]+) +advertised to peers:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<advertisedto>[\\d\\s\\.]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show cdp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<device_id>\\S+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<device_id>\\S+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<device_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<local_interface>[a-zA-Z]+[\\s]*[\\d\\/\\.]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<device_id>\\S+) +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show checkpoint",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\d+\\) +(?P<id>[\\s\\w\\.\\-]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Created +by +(?P<user>[\\s\\w\\.\\-\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Created +at +(?P<time>[\\s\\w\\.\\-\\:\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Size +is +(?P<size>[,\\d]+) +bytes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Description: +(?P<desc>[\\s\\w\\.\\-\\:]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show dot1x",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)((^[Dd]ot1x)\\s+)?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(\\w+) *\\= *(\\d+)+ *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^([Rr]x[Vv]ersion) \\= *(?P<rxversion>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>((\\w+\\d+)(\\/\\d+)*)) + +(?P<pae>\\w+) + +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Sysauthcontrol +(?P<SysControl>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dot1x +Protocol +Version +(?P<version>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dot1x +Info +for +(?P<intf>\\w+\\d+\\/\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>[\\-\\s\\w]+) +\\= +(?P<value>(((\\w)|(\\())+((:\\w+)|(\\s\\w+)|(.\\w+))*)+(\\))?)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show fabricpath",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)Fabricpath IS-IS domain: +(?P<domain>(\\S+)) +Fabricpath IS-IS adjacency database:$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show fdb",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<entry>[\\w\\*\\+] )?\\s*(?P<vlan>All|[\\d\\-]+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<mac_aging_time>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured +System +Limit: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current +System +Count: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured +System +Action: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Currently +System +is: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<vlan>\\w+) +(?P<conf_limit>\\d+) ",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show feature",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<name>[\\w\\-]+) +(?P<inst>\\d+) ",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show forwarding",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^slot +(?P<slot>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_version>\\w+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show hsrp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)\\s*Extended-hold +\\(NSF\\) +(?P<nsf>[a-zA-Z]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Global +HSRP-BFD",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Total +Groups: +(?P<total_groups>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Version:: +V1-IPV4: +(?P<v1_ipv4>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*State:: +Active: +(?P<active>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*State:: +V6-Active: +(?P<v6_active>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Total +HSRP +Enabled +interfaces:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Tx +\\- +Pass: +(?P<tx_pass>[0-9]+) +Fail:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Rx +\\- +Good: +(?P<rx_good>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Packet +for +unknown +groups:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*Total +MTS: +Rx: +(?P<total_mts_rx>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<intf>(\\S+)) +\\- +Group +(?P<gnum>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Local +state +is +(?P<state>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Forwarding +threshold\\(for +vPC\\),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Preemption +Delay +\\(Seconds\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Hellotime +(?P<hello>(\\d+)) +(?P<hello_unit>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Virtual +IP +address +is +(?P<ip>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)[sS]econdary +[vV]irtual +IP +address +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Active +router +is +(?P<active>(\\S+))(?: *,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Standby +router +is +(?P<standby>(\\S+))(?: *,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Authentication +(?:(MD5, key-string)|(text))?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Virtual +mac +address +is +(?P<mac>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<state_changes>(\\d+)) +state +changes,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)[tT]rack +object +(?P<tracked_object>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)IP +redundancy +name +is +(?P<name>(\\S+)) +\\(default\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Secondary +VIP\\(s\\):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<vip>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*(?P<interface>\\S+) +(?P<minimum_delay>\\d+) +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show igmp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*IGMP +Snooping +(?P<enabled>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IGMPv1\\/v2 +Report +Suppression +(?P<v1v2_report_suppression_enabled>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IGMPv3 +Report +Suppression +(?P<v3_report_suppression_enabled>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Link +Local +Groups +Suppression +(?P<link_local_group_suppression_enabled>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VPC +Multicast +optimization +(?P<vpc_multicast_optimization_enabled>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IGMP +Snooping +information +for +vlan +(?P<vlan_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IGMP +snooping +(?P<ip_igmp_snooping>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Lookup +mode: +(?P<lookup_mode>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IGMP +querier +(?P<igmp_querier>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Querier +interval: +(?P<querier_interval>\\d+) +secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Querier +last +member +query +interval:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Querier +robustness: +(?P<querier_robustness>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Switch\\-querier +(?P<switch_querier>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IGMP +Explicit +tracking +(?P<igmp_explicit_tracking>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IGMPv2 +Fast +leave +(?P<v2_fast_leave>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Number +of +router\\-ports: +(?P<router_ports_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Number +of +groups: +(?P<groups_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VLAN +vPC +function +(?P<vlan_vpc_function>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<space>\\s{4})(?P<active_ports>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Report +Flooding: +(?P<report_flooding>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interfaces +for +Report +Flooding: +(?P<report_flooding_interfaces>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Use +Group +Address +for +Proxy +Leaves: +(?P<group_address_for_proxy_leaves>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +Interfaces +for +VRF +\\\"(?P<vrf>\\S+)\\\", +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>[\\w\\/\\.\\-]+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +address: +(?P<ip>[\\w\\.\\:]+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active +querier: +(?P<querier>[\\w\\.\\:]+)(, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active +querier: +(?P<querier>[\\w\\.\\:]+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Membership +count: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Old +Membership +count +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +version: +(?P<ver>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +query +interval: +(?P<intverval>\\d+) +secs, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +max +response +time: +(?P<time>\\d+) +secs, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +startup +query +interval: +(?P<intvl>\\d+) +secs, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +startup +query +count: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +last +member +mrt: +(?P<mrt>\\d+) +secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +last +member +query +count: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +group +timeout: +(?P<timeout>\\d+) +secs, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +querier +timeout: +(?P<timeout>\\d+) +secs, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +unsolicited +report +interval: +(?P<val>\\d+) +secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +robustness +variable: +(?P<val1>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +reporting +for +link\\-local +groups: +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +interface +enable +refcount: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +interface +immediate +leave: +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +VRF +name +(?P<vrf>\\S+) +\\(id +(?P<id>\\d+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +Report +Policy: +(?P<policy>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +State +Limit: +(?P<max_groups>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +interface +statistics: +(?P<dummy>[\\w\\-\\s\\(\\)]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^v2\\-queries: +(?P<sent1>\\d+)\\/(?P<received1>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^v3\\-queries: +(?P<sent1>\\d+)\\/(?P<received1>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Packets +dropped +due +to +router\\-alert +check: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +PIM +DR: +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +vPC +SVI: +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +Connected +Group +Membership +for +VRF +\\\"(?P<vrf>\\S+)\\\"",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<group>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<group>[\\w\\.\\:]+) +(?P<type>[SDLTH\\*]+) +(?P<intf>[\\w\\.\\/\\-]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IGMP +Locally +Joined +Group +Membership +for +VRF +\\\"(?P<vrf>\\S+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<group>[\\w\\.\\:]+) +(?P<source>[\\w\\.\\:\\*]+) +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show interface",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<interface>\\S+)\\s*is\\s*(?P<link_state>(down|up))?(administratively\\s+(?P<admin_1>(down|up)))?\\s*(\\(Administratively\\s*(?P<admin_2>(down|up))\\))?(\\(VLAN\\/BD\\s+is+\\s+(down|up)\\))?(,\\s*line\\s+protocol\\s+is\\s+(?P<line_protocol>\\w+))?(,\\s+autostate\\s+(?P<autostate>\\S+))?(\\(Link\\s+not\\s+connected\\))?(\\(SFP\\s+validation\\s+failed\\))?(\\(SFP\\s+not\\s+inserted\\))?(\\(suspended\\(.*\\)\\))?(\\(\\S+ErrDisabled\\))?(\\(XCVR\\s+not\\s+inserted\\))?(\\(.*ACK.*\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^admin +state +is +(?P<admin_state>([a-zA-Z0-9\\/\\.]+))(?:,)?(?: +(?P<dedicated_intf>(Dedicated Interface)))?(?:, +\\[parent +interface +is +(?P<parent_intf>(\\S+))\\])?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dedicated Interface$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Belongs *to *(?P<port_channel_int>[a-zA-Z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hardware: *(?P<types>[a-zA-Z0-9\\/\\s]+), *address: *(?P<mac_address>[a-z0-9\\.]+) *\\(bia *(?P<phys_address>[a-z0-9\\.]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Description: *(?P<description>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Internet *Address *is *(?P<ip>[0-9\\.]+)\\/(?P<prefix_length>[0-9]+)(?: *(?P<secondary>(secondary)))?(?: *tag *(?P<route_tag>[0-9]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU *(?P<mtu>[0-9]+) *bytes, *BW *(?P<bandwidth>[0-9]+) *Kbit( *, *DLY *(?P<delay>[0-9]+) *usec)?,?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTU *(?P<mtu>[0-9]+) *bytes, *BW *(?P<bandwidth>[0-9]+) *Kbit, *,? *BW *([0-9]+) *Kbit, *DLY *(?P<delay>[0-9]+) *usec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^reliability *(?P<reliability>[0-9\\/]+), *txload *(?P<txload>[0-9\\/]+), *rxload *(?P<rxload>[0-9\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Encapsulation *(?P<encapsulation>[a-zA-Z0-9\\.\\s]+), *medium *is *(?P<medium>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Encapsulation *(?P<encapsulation>[a-zA-Z0-9\\.\\s]+), *Vlan *ID *(?P<first_dot1q>[0-9]+), *medium *is *(?P<medium>[a-z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Encapsulation *(?P<encapsulation>[a-zA-Z0-9\\.\\s]+), *([\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port *mode *is *(?P<port_mode>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^auto-duplex, +auto-speed$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<duplex_mode>[a-z]+)-duplex, *(?P<port_speed>[a-z0-9\\-]+)(?: *[G|M]b/s)?(?:, +media +type +is (?P<media_type>\\w+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Beacon *is *turned *(?P<beacon>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auto-Negotiation *is *turned *(?P<auto_negotiate>(off))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auto-Negotiation *is *turned *(?P<auto_negotiate>(on))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input *flow-control *is *(?P<receive>(off)+), *output *flow-control *is *(?P<send>(off)+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Input *flow-control *is *(?P<receive>(on)+), *output *flow-control *is *(?P<send>(on)+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auto-mdix *is *turned *(?P<auto_mdix>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Switchport *monitor *is *(?P<switchport_monitor>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EtherType *is *(?P<ethertype>[a-z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Members +in +this +channel *: *(?P<port_channel_member_intfs>[\\w\\/\\.\\-\\,\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^EEE *\\(efficient-ethernet\\) *: *(?P<efficient_ethernet>[A-Za-z\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last *link *flapped *(?P<last_link_flapped>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last *clearing *of *\\\"show *interface\\\" *counters *(?P<last_clear>[a-z0-9\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last *clearing *of *\\\" *\\\" *counters *(?P<last_clear>[a-z0-9\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface_reset>[0-9]+) *interface *resets$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<load_interval>[0-9\\#]+) *(minute|second|minutes|seconds) *input *rate *(?P<in_rate>[0-9]+) *bits/sec, *(?P<in_rate_pkts>[0-9]+) *packets/sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<load_interval>[0-9\\#]+) *(minute|second|minutes|seconds) *output *rate *(?P<out_rate>[0-9]+) *bits/sec, *(?P<out_rate_pkts>[0-9]+) *packets/sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^input *rate *(?P<in_rate_bps>[0-9]+) *bps, *(?P<in_rate_pps>[0-9]+) *pps; *output *rate *(?P<out_rate_bps>[0-9]+) *bps, *(?P<out_rate_pps>[0-9]+) *pps$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<rx>(RX|Rx))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_unicast_pkts>[0-9]+) +unicast +packets +(?P<in_multicast_pkts>[0-9]+) +multicast +packets +(?P<in_broadcast_pkts>[0-9]+) +broadcast +packets$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_pkts>[0-9]+) +input +packets(?: +(?P<in_octets>[0-9]+) +bytes)?(?: +(?P<in_unicast_pkts>[0-9]+) +unicast +packets +(?P<in_multicast_pkts>[0-9]+) +multicast +packets)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_jumbo_packets>[0-9]+) +jumbo +packets *(?P<in_storm_suppression_packets>[0-9]+) *storm *suppression *packets$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_runts>[0-9]+) *runts *(?P<in_oversize_frame>[0-9]+) *giants *(?P<in_crc_errors>[0-9]+) *CRC(/FCS)? *(?P<in_no_buffer>[0-9]+) *no *buffer$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_errors>[0-9]+) *input *error *(?P<in_short_frame>[0-9]+) *short *frame *(?P<in_overrun>[0-9]+) *overrun *(?P<in_underrun>[0-9]+) *underrun *(?P<in_ignored>[0-9]+) *ignored$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_watchdog>[0-9]+) *watchdog *(?P<in_bad_etype_drop>[0-9]+) *bad *etype *drop *(?P<in_unknown_protos>[0-9]+) *bad *proto *drop *(?P<in_if_down_drop>[0-9]+) *if *down *drop$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_with_dribble>[0-9]+) *input *with *dribble *(?P<in_discard>[0-9]+) *input *discard$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_mac_pause_frames>[0-9]+) *Rx *pause$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<tx>(TX|Tx))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_unicast_pkts>[0-9]+) *unicast *packets *(?P<out_multicast_pkts>[0-9]+) *multicast *packets *(?P<out_broadcast_pkts>[0-9]+) *broadcast *packets$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_pkts>[0-9]+) *output *packets *(?P<out_octets>[0-9]+) *bytes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_jumbo_packets>[0-9]+) *jumbo *packets$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_errors>[0-9]+) *output *error *(?P<out_collision>[0-9]+) *collision *(?P<out_deferred>[0-9]+) *deferred *(?P<out_late_collision>[0-9]+) *late *collision$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_lost_carrier>[0-9]+) *lost *carrier *(?P<out_no_carrier>[0-9]+) *no *carrier *(?P<out_babble>[0-9]+) *babble *(?P<out_discard>[0-9]+) *output *discard$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<out_mac_pause_frames>[0-9]+) *Tx *pause$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Members +in +this +channel *: *(?P<port_channel_member_intfs>[\\w\\/\\.\\-\\,\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<in_broadcast_pkts>[0-9]+) +broadcast +packets +(?P<in_octets>[0-9]+) +bytes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *Interface *Status *for *VRF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[a-zA-Z0-9\\/\\-\\.]+), *Interface",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Unnumbered +interfaces +of +(?P<unnumbered_intf>[\\w\\.\\/]+): *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(([E|e]thernet|[L|l]oopback|[T|t]unnel|[V|v]lan|mti|[t|T]unnel-te|[p|P]ort-channel)[\\d\\/\\.]+):",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *address: *(?P<ip>[0-9\\.]+), *IP",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *address: *(?P<ip>[0-9\\.]+), *IP *subnet: *(?P<ip_subnet>[a-z0-9\\.]+)\\/(?P<prefix_length>[0-9\\,]+)(\\s*(?P<secondary>secondary)\\s*)?(?: *route-preference: *(?P<route_preference>[0-9]+),)?(?: *tag: *(?P<route_tag>[0-9]+)?)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<route_tag>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *broadcast *address:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *multicast *groups *locally *joined:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*show",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<multicast_groups_address>[a-z0-9\\.\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *MTU: *(?P<ip_mtu>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *primary *address *route-preference:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *proxy *ARP *: *(?P<proxy_arp>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *Local *Proxy *ARP *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *multicast *routing:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *icmp *redirects:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP directed-broadcast:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *Forwarding: *(?P<ip_forwarding>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *icmp *unreachables *\\(except *port\\):",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *icmp *port-unreachable:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *unicast *reverse *path *forwarding:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP *load *sharing: *(?P<load_sharing>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(IP|ip) *interface *statistics *last *reset: *(?P<int_stat_last_reset>[a-zA-Z0-9\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Unicast *packets *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Unicast *bytes *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multicast *packets *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multicast *bytes *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Broadcast *packets *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Broadcast *bytes *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Labeled *packets *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Labeled *bytes *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*WCCP *Redirect *outbound:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*WCCP *Redirect *inbound:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*WCCP *Redirect *exclude:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP +unnumbered +interface +\\((?P<unnum_intf>[\\w\\/\\.]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[a-zA-Z0-9\\.\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Name: *(?P<interface>[a-zA-Z0-9\\/\\-\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Switchport: *(?P<switchport_status>[a-zA-Z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Switchport *Monitor: *(?P<switchport_monitor>[a-zA-Z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Operational *Mode: *(?P<switchport_mode>[\\w\\s-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Access *Mode *VLAN: *(?P<access_vlan>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Trunking *Native *Mode *VLAN:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Trunking *VLANs *Allowed: *(?P<trunk_vlans>[0-9\\,\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Administrative *private-vlan *primary",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Administrative *private-vlan *secondary",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Administrative *private-vlan *primary",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Administrative *private-vlan *secondary",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Administrative *private-vlan *trunk *native",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Administrative *private-vlan *trunk",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Administrative *private-vlan *trunk",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Administrative *private-vlan *trunk",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Operational *private-vlan:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 *Interface *Status *for *VRF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?:(?P<interface>[a-zA-Z0-9\\/\\-\\.]+)), Interface",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 address:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Anycast configured addresses:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<ip>[a-z0-9\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 *subnet:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 *link-local *address:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 *virtual *addresses *configured:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(IPv6 virtual *(?P<virtual_add>(addresses|address) configured:))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<ipv6_virtual_addresses>[a-z0-9\\:\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 *multicast *routing:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 *report *link *local:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 *Forwarding *feature:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<multicast_groups>(IPv6 *multicast *(groups|group) *locally *joined:))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<ipv6_multicast_group_addresses>[a-z0-9\\(\\)\\:\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 *multicast *\\(S\\,G\\) *entries *joined:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\((?P<ip_list>.*)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 *MTU: *(?P<ipv6_mtu>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 *unicast *reverse *path *forwarding:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 *load *sharing:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 *interface *statistics *last *reset:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Unicast *packets:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Unicast *bytes: *(?P<unicast_bytes_forwarded>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multicast *packets: *(?P<multicast_packets_forwarded>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multicast *bytes: *(?P<multicast_bytes_forwarded>[0-9]+)\\/",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interface +IP Address +Interface Status$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[a-zA-Z0-9\\/\\.\\-]+) +(?P<ip_address>[a-z0-9\\.]+) +(?P<interface_status>[a-z\\-\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<ipaddress_extension>\\([a-z0-9]+\\))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +VRF +Status +IP Address +Speed +MTU$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<port>[a-zA-Z0-9]+) +(?P<vrf>[a-zA-Z0-9\\-]+) +(?P<status>[a-zA-Z]+) +(?P<ip_address>(\\S+)) +(?P<speed>[0-9]+) +(?P<mtu>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Ethernet +VLAN +Type +Mode +Status +Reason +Speed +Port$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\S]+) +(?P<vlan>[a-zA-Z0-9\\-]+) +(?P<type>[a-zA-Z]+) +(?P<mode>[a-z]+) +(?P<status>[a-z]+) +(?P<reason>[a-zA-Z\\s]+) +(?P<speed>[0-9a-zA-Z\\(\\)]+) +(?P<port>[0-9\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port-channel +VLAN +Type +Mode +Status +Reason +Speed +Protocol$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+) +(?P<vlan>\\S+) +(?P<type>[a-zA-Z]+) +(?P<mode>[a-z]+) +(?P<status>[a-z]+) +(?P<reason>[\\w\\s]+) +(?P<speed>\\S+) +(?P<protocol>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +Status +Description$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[a-zA-Z0-9\\/]+) +(?P<status>[a-z]+) +(?P<description>[a-zA-Z\\s\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +Secondary +VLAN\\(Type\\) +Status +Reason$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\S]+) +(?P<type>[\\w\\-]+) +(?P<status>[\\w]+) +(?P<reason>[\\w\\s\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^interface +(?P<intf_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*no shutdown$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*host-reachability protocol +(?P<protocol>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*source-interface +(?P<src_intf>[a-zA-Z0-9\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*member vni +(?P<vni>[0-9\\-]+)( +(?P<associate_vrf>[a-zA-Z\\-]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*mcast-group +(?P<ip>[0-9\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*suppress-arp$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^switchport$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^switchport +mode +(?P<mode>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^switchport +trunk +allowed +vlan +(?P<trunk_vlans>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^switchport +trunk +native +vlan +(?P<trunk_native_vlan>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^switchport +access +vlan +(?P<access_vlan>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^channel-group +(?P<port_channel_int>\\d+) +mode +(?P<mode>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^speed +(?P<speed>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^duplex +(?P<duplex>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^description +(?P<description>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^vpc +(?P<vpc>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interface: +(?P<intf>[\\w]+)\\,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Source-Interface: +(?P<src_intf>[a-zA-Z0-9\\-]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VPC Capability: +(?P<vpc>[a-zA-Z0-9\\-]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<interface>(\\S+)) +(?P<type>(\\S+))? +(?P<speed>(\\S+))? +(?P<description>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<interface>(\\S+)) +(?P<name>(\\S+))? +(?P<status>(\\S+))? +(?P<vlan>(\\S+)) +(?P<duplex_code>(\\S+)) +(?P<port_speed>(\\S+))( +(?P<type>(\\S+)))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<interface>(\\S+)) +(?P<name>([\\S\\s]+))(?<! ) +(?P<status>(\\S+)) +(?P<vlan>(\\S+)) +(?P<duplex_code>([a-z]+)) +(?P<port_speed>(\\S+)) +(?P<type>([\\S\\s]+))$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show isis",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^ISIS +[Pp]rocess *: +(?P<isis_process>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Instance +number *: +(?P<instance_number>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^UUID *: +(?P<uuid>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Process +ID +(?P<process_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRF *: +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^System +ID *: +(?P<sysid>[a-zA-Z\\d\\-\\.]+) +IS-Type *: +(?P<is_type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SAP *: +(?P<sap>\\d+) +Queue +Handle *: +(?P<queue_handle>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +LSP +MTU *: +(?P<lsp_mtu>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Stateful +HA +(?P<stateful_ha>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Graceful +Restart +(?P<gr>\\w+)\\. +State *: +(?P<state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +graceful +restart +status *: +(?P<last_gr_status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Start-Mode +(?P<start_mode>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BFD +IPv4 +is +(?P<bfd_ipv4>[\\w\\s]+) +for +ISIS +process: +(?P<name>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BFD +IPv6 +is +(?P<bfd_ipv6>[\\w\\s]+) +for +ISIS +process: +(?P<name>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology-mode +is +(?P<topology_mode>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric-style *: +advertise\\((?P<adv>.*)\\), +accept\\((?P<acc>.*)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<area>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Process +is +(?P<process>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRF +ID *: +(?P<vrf_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<route>[\\w\\s]+) +during +non-graceful +controlled +restart$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<resolution>\\w+) +resolution +of +L3->L2 +address +for +ISIS +adjacency$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SR +IPv4 +is +(?P<sr_ipv4>[\\w\\s]+) +for +ISIS +process: +(?P<name>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SR +IPv6 +is +(?P<sr_ipv6>[\\w\\s]+) +for +ISIS +process: +(?P<name>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?!Level)(?P<interface>[a-zA-Z][\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology *: +(?P<topology>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Address +family +(?P<af>[\\S\\s]+?) *:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +interface *: +(?P<num>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Distance *: +(?P<distance>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Level *(?P<level>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No auth type and keychain$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auth +check +(?P<auth_check>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^L1 +Next +SPF *: +(?P<l1_next_spf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^L2 +Next +SPF *: +(?P<l2_next_spf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS-IS +[Pp]rocess: +(?P<process_id>\\S+) +VRF: +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+), +Interface +status: +(?P<status>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +address: +(?P<ip>\\S+), +IP +subnet: +(?P<subnet>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ipv6>\\S+) +\\[(?P<state>\\S+)\\]$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv6 +subnet: +(?P<subnet>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv6 +link-local +address: +(?P<link_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Level *(?P<level>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^No auth type and keychain$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auth +check +(?P<auth_check>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Index: +(?P<index>\\w+), +Local +Circuit +ID: +(?P<circuit_id>\\w+), +Circuit +Type: +(?P<circuit_type>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BFD +IPv4 +is +(?P<bfd_ipv4>[\\s\\w]+) +for +Interface +(?P<intf>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BFD +IPv6 +is +(?P<bfd_ipv6>[\\s\\w]+) +for +Interface +(?P<intf>.*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MTR +is +(?P<mtr>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Passive +level: +(?P<passive>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<level>\\d+) +(?P<metric>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LSP +interval: +(?P<lsp_interval>[\\d]+) +ms, +MTU: +(?P<mtu>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<level>\\S+) +Designated +IS: +(?P<designated_is>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<level>\\d+) +(?P<metric_0>\\d+) +(?P<metric_2>\\d+) +(?P<csnp>\\d+) +(?P<next_csnp>[\\w\\:]+) +(?P<hello>\\d+) +(?P<multi>\\d+) +(?P<next_iih>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<level>\\d+) +(?P<adjs>\\d+) +(?P<adjs_up>\\d+) +(?P<pri>\\d+) +(?P<circuit_id>\\S+) +(?P<since>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<level>\\d+) +(?P<mt>\\d+) +(?P<metric>\\d+) +(?P<metric_cfg>\\w+) +(?P<fwdng>\\w+) +(?P<ipv4_mt>\\w+) +(?P<ipv4_cfg>\\w+) +(?P<ipv6_mt>\\w+) +(?P<ipv6_cfg>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS-IS +[Pp]rocess: +(?P<process_id>\\S+) +SPF +information +VRF: +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SPF +log +for +Topology +(?P<topology>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +number +of +SPF +calculations: +(?P<total_num>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Log +entry +\\(current\\/max\\): +(?P<curr>\\d+)\\/(?P<max>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Log +entry: +(?P<entry>\\d+), +Ago: +(?P<ago>[\\d\\.\\:]+), +Date: +(?P<date>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<level>\\d+) +(?P<instance>\\S+) +(?P<init>[\\d\\.]+) +(?P<spf>\\S+) +(?P<is_update>\\S+) +(?P<urib_update>\\S+) +(?P<total>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<level>\\d+) +(?P<node>\\d+) +(?P<count>\\d+) +(?P<changed>\\d+) +(?P<reason>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS-IS +[Pp]rocess: +(?P<process_id>\\S+) +VRF: +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<sysid>\\S+) +(?P<snpa>[\\w\\.]+) +(?P<level>\\d+) +(?P<state>\\S+) +(?P<hold_time>[\\d\\:]+) +(?P<interface>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS-IS +Process: +(?P<process_id>\\S+) +dynamic +hostname +table +VRF: +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<level>\\d+) +(?P<system_id>[a-zA-Z\\d\\-\\.]+)(?P<star>\\*)? +(?P<dynamic_hostname>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS-IS +Process: +(?P<process_id>\\S+) +dynamic +hostname +table +VRF: +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<level>\\d+) +(?P<lsp_id>[a-zA-Z\\d\\-\\.]+)(?P<star>\\*)? +(?P<dynamic_hostname>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS-IS +Process: +(?P<process_id>\\S+) +LSP +database +VRF: +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IS-IS +Level-(?P<level>\\d+) +Link +State +Database(:)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Instance *: +(?P<instance>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +Address *: +(?P<area_address>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NLPID *: +(?P<nlp_id>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(MT TopoId *: +)?TopoId:(?P<topo_id>\\d+) +Att: +(?P<att>\\d+) +Ol: +(?P<ol>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hostname *: +(?P<hostname>\\S+) +Length *: +(?P<length>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Extended +IS *: +(?P<ext>\\S+) +Metric *: +(?P<metric>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TopoId *: +(?P<topo_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(MtExtend +IS *: +)?(?P<mt_ext>\\S+) +Metric *: +(?P<metric>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +Address *: +(?P<ip_address>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Extended +IP *: +(?P<ext_ip>\\S+) +Metric *: +(?P<metric>\\d+) +\\((?P<up_down>\\S+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv6 +Address *: +(?P<ip_address>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Router +ID *: +(?P<router_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MT-IPv6 +Prefx *: +TopoId *: +(?P<topo_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<prefix>\\S+) +Metric *: +(?P<metric>\\d+) +\\((?P<up_down>\\w+)\\/(?P<ext_origin>\\w+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unknown +Sub-TLV *: +Length *: +(?P<length>\\d+) +Type *: +(?P<type>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Digest +Offset *: +(?P<offset>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show l2route",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*(?P<topology>[0-9]+) +(?P<mac_address>[a-z0-9\\.]+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<topology>[0-9]+) +(?P<mac_address>[a-z0-9\\.]+) ",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show lag",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*(?P<system_priority>[\\d]+), *(?P<system_id_mac>[\\w.\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^port-channel\\d+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<port_channel>[\\w-]+)[\\xa0 ]+neighbors$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^port-channel\\d+$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +membership +update +is +(?P<last_update_status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^First +operational +port +is +(?P<first_oper_port>[\\w/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +bundled +member +is +(?P<last_bundled_member>[\\w/]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show lldp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<timer>[\\w\\s-]+) +in +seconds: +(?P<seconds>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Chassis +id: +(?P<chassis_id>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +id: +(?P<port_id>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +Port +id: +(?P<local_port_id>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +Description: +(?P<port_description>(?!null).+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^System +Name: +(?P<system_name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^System +Description: +(?P<system_description>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<copyright>Copyright +\\([c|C]\\) +.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<compiled_by>Compiled +.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<technical_support>(Technical|TAC) (S|s)upport: +.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time +remaining: +(?P<time_remaining>\\d+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^System +Capabilities: +(?P<system>[\\w ,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enabled +Capabilities: +(?P<enabled>[\\w ,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Management +Address: +(?P<mgmt_address_ipv4>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Management +Address +IPV6: +(?P<mgmt_address_ipv6>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Vlan +ID: +(?P<vlan_id>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +entries +displayed: +(?P<total_entries>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<custom_name>VRP .+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<special_name>HUA.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<pattern>[\\w\\s]+): +(?P<value>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show mcast",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*(?P<address_family>[\\w\\W]+) [mM]ulticast",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\((?P<source_address>[0-9\\.\\*\\/]+), +(?P<multicast_group>[a-zA-Z0-9\\.\\/\\:]+)\\), *(?P<bidir>(\\S+))? *uptime: +(?P<uptime>[0-9a-zA-Z\\:\\.]+)(,)?(?: *(?P<flag>[0-9a-zA-Z\\(\\)\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Incoming +interface:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Outgoing +interface +list: +\\(count:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?:(?P<outgoing_interface>[a-zA-Z0-9\\/\\.\\-]+),)? +uptime: +(?:(?P<oil_uptime>[a-zA-Z0-9\\:]+),)? +(?:(?P<oil_flags>[a-zA-Z0-9\\,\\.\\(\\)\\s]+))?(, *\\((?P<flag>[\\S\\s]+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<address_family>[\\w\\W]+) [mM]ulticast +[rR]outing +[tT]able +for +VRF +(?P<vrf>[a-zA-Z0-9\\\"]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\((?P<source_address>(\\S+)), +(?P<multicast_group>(\\S+))\\), *(?P<bidir>(\\S+),)? *uptime: +(?P<uptime>[0-9a-zA-Z\\:\\.]+)(,)?(?: *(?P<flag>[a-zA-Z0-9\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Incoming +interface: +(?P<incoming_interface>[a-zA-Z0-9\\/\\.]+), +RPF +nbr: +(?P<rpf_nbr>[a-zA-Z0-9\\:\\,\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Outgoing +interface +list: +\\(count:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?:(?P<outgoing_interface>[a-zA-Z0-9\\/\\.\\-]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?:(?P<outgoing_interface>[a-zA-Z0-9\\/\\.\\-]+),)? +uptime: +(?:(?P<oil_uptime>[a-zA-Z0-9\\:]+),)? +(?:(?P<oif_rpf>[a-zA-Z0-9\\s]+),)? +(?P<oil_flags>(\\(RPF\\))+)*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(Static-route|Mstatic-route) +for +VRF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<address_family>[a-zA-Z0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<mroute>[0-9\\.\\/]+), +configured +nh:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<mroute>[0-9\\.\\/]+), +configured +nh:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<urib>(\\(installed in urib\\))+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<address_family>[\\w\\W]+) +Configured +Static +Routes +for +VRF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<mroute>[a-zA-Z0-9\\:\\/]+) +->",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*nh_vrf *(?P<nh_vrf>[a-zA-Z0-9\\(\\)]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*real-next-hop: +(?P<neighbor_address>[a-zA-Z0-9\\:]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*rnh(?P<rnh_status>[a-zA-Z0-9\\(\\)\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*bfd_enabled +(?P<bfd_enable>(no)+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*bfd_enabled +(?P<bfd_enable>(yes)+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv4 +Multicast +Routing +Table +for +table\\-id: +(?P<vrf_id>(?!wildcard)[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Total +number +of +groups: +(?P<total_number_group>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\((?P<saddr>[\\w\\/\\.\\*]+), +(?P<gaddr>[\\w\\/\\.]+)\\), +RPF +Interface:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Received +Packets: +(?P<rcv_packets>[\\d]+) +Bytes: +(?P<rcv_bytes>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Number +of +Outgoing +Interfaces: +(?P<num_of_oifs>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Null +Outgoing +Interface +List$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Outgoing +Interface +List +Index: +(?P<oif_index>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<space>\\s{6})(?P<oif>[\\w\\-\\/]+)( +\\((?P<encap>[\\w]+) +Encap\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*\\( +Mem +L2 +Ports: +(?P<mem_l2_ports>[\\w\\s\\-\\/]+) +\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)\\s*l2_oiflist_index: +(?P<l2_oiflist_index>[\\d]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show mld",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^ICMPv6 +MLD +Interfaces +for +VRF +\\\"(?P<vrf>\\S+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +Interfaces +for +VRF +\\\"(?P<vrf>\\S+)\\\", ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>[\\w\\/\\.\\-]+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address>(?P<ip>[a-z0-9\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +Local +Address *: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv6 +Link\\-local +Address *: *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active +Querier: +(?P<querier>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Querier +version: +(?P<version>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +Membership +count: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +version: +(?P<ver>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +query +interval: +(?P<intverval>\\d+) +secs, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +max +response +time: +(?P<time>\\d+) +secs, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +startup +query +interval: +(?P<intvl>\\d+) +secs, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +startup +query +count: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +last +member +mrt: +(?P<mrt>\\d+) +secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +last +member +query +count: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +group +timeout: +(?P<timeout>\\d+) +secs, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +querier +timeout: +(?P<timeout>\\d+) +secs, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +unsolicited +report +interval: +(?P<val>\\d+) +secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +robustness +variable: +(?P<val1>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +reporting +for +link\\-local +groups: +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +interface +enable +refcount: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +immediate +leave: +(?P<status>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +Report +Policy: +(?P<policy>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +State +Limit: +(?P<max_groups>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<title>[\\w\\s]+) *: +(?P<sent1>\\d+)\\/(?P<received1>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^show +ipv6 +mld +groups.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +Connected +Group +Membership +for +VRF +\\\"(?P<vrf>\\S+)\\\"",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<group>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<group>\\w+\\:\\:\\w+) +(?P<type>\\w+) +(?P<intf>[\\w\\.\\/\\-]+) +(?P<uptime>[\\w\\.\\:]+) +(?P<expires>[\\w\\.\\:]+) +(?P<last_reporter>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<source>[\\w\\.\\:]+) +(?P<type>\\w+) +(?P<intf>[\\w\\.\\/\\-]+) +(?P<uptime>[\\w\\.\\:]+) +(?P<expires>[\\w\\.\\:]+) +(?P<last_reporter>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\((?P<source>[\\w\\.\\:\\*]+), *(?P<group>[\\w\\.\\:]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Type: +(?P<type>\\w+), Interface: +(?P<intf>[\\w\\.\\/\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Uptime\\/Expires *: +(?P<uptime>[\\w\\.\\:]+)/(?P<expires>[\\w\\.\\:]+), +Last +Reporter *: +(?P<last_reporter>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Group +Type +Interface +Last +Reported$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MLD +Locally +Joined +Group +Membership +for +VRF +\\\"(?P<vrf>\\S+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\((?P<source>[\\w\\.\\:\\*]+), *(?P<group>[\\w\\.\\:]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<type>\\w+) +(?P<intf>[\\w\\.\\-\\/]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<group>[\\w\\.\\:]+) +(?P<source>[\\w\\.\\:\\*]+) +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show msdp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*MSDP +peer +(?P<address>[\\d\\.]+) +for +VRF +\\\"(?P<vrf>[\\w]+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*AS +(?P<peer_as>[\\d]+), +local address: +(?P<connect_source_address>[\\d\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Description: +(?P<description>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Connection status: +(?P<session_state>[\\w\\-]+)(, +(Connecting|Listening) +in:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Uptime\\(Downtime\\): +(?P<elapsed_time>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last +reset +reason: +(?P<reset_reason>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Password: +(?P<password>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Keepalive Interval: +(?P<keepalive_interval>[\\d]+) +sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Keepalive +Timeout: +(?P<keepalive_timeout>[\\d]+) +sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Reconnection +Interval: +(?P<reconnection_interval>[\\d]+) +sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Policies:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*SA +in: +(?P<sa_in>[\\w]+), +SA +out: +(?P<sa_out>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*SA +limit: +(?P<sa_limit>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Member +of +mesh-group: +(?P<mesh_group>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Statistics +\\(in/out\\):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last messaged received: +(?P<last_message_received>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*SAs: +(?P<in_sas>[\\d]+)/+(?P<out_sas>[\\d]+), +SA-Requests:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*In/Out +Ctrl +Msgs: +(?P<in_ctrl_msg>[\\d]+)/+(?P<out_ctrl_msg>[\\d]+), In/Out Data Msgs:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Remote/Local Port +(?P<remote_port>[\\d]+)/+(?P<local_port>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RPF check failures: +(?P<rpf_check_failures>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Cache Lifetime: +(?P<cache_lifetime>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Established Transitions: +(?P<established_transition>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Connection Attempts: +(?P<connection_attemps>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Discontinuity Time: +(?P<discontinuity_time>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*MSDP SA Route Cache for VRF +\\\"(?P<vrf>[\\w]+)\\\" +\\- +(?P<number_of_entries>[\\d]+) +entries$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<source>[\\d\\.]+) +(?P<group>[\\d\\.]+) +(?P<rp>[\\d\\.]+) +(?P<asn>[\\d\\.]+) +(?P<uptime>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Peer: +(?P<peer>[\\d\\.]+), +Expires: +(?P<expire>[\\d\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<match1>route\\-map +(?P<sa_filter>\\S+) +permit +(?P<permit>\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<match>ip +prefix\\-list +(?P<sa_filter>\\S+) +seq +(?P<seq>\\d+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<match2>match +ip +address +(?P<match_ip>\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +accept +count +for +policy: +(?P<total_accept_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +reject +count +for +policy: +(?P<total_reject_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MSDP +Peer +Status +Summary +for +VRF +\\\"(?P<vrf>\\S+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Local +ASN: +(?P<local_as>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +configured +peers: +(?P<num_of_configured_peers>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +established +peers: +(?P<num_of_established_peers>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +shutdown +peers: +(?P<num_of_shutdown_peers>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<address>[\\d\\.]+) +(?P<peer_as>\\d+) +(?P<session_state>[\\w\\/\\-]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ip +msdp +keepalive +(?P<peer>[\\d\\.]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ip +msdp +description +(?P<peer>[\\d\\.]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ip +msdp +reconnect\\-interval +(?P<connect_retry_interval>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ip +msdp +originator\\-id +(?P<originating_rp>[\\w\\.\\-\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ip +msdp +peer +(?P<peer>[\\d\\.]+) +connect\\-source +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show nd",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^No. +of +Adjacency +hit +with +type +(?P<adjacency>([\\w\\s]+)): +Packet +count +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adjacency +statistics +last +updated +before: +(?P<adjacency_statistics_last_updated_before>(\\w+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +number +of +entries: +(?P<total_number_of_entries>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<neighbor_key>(?!Total number of entries)[A-Za-z\\s]+) +: +(?P<neighbor_value>[\\w\\/\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ICMPv6 ND Interfaces for VRF +\\\"(?P<vrf>[\\w]+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[\\w\\/\\.]+), +Interface status:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 address:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<ipv6_address>[\\w\\:\\/]+)( +\\[VALID\\])?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 +link\\-local +address: +(?P<link_address>[\\w\\:\\/]+)( +\\[VALID\\])?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ND mac-extract : +(?P<nd_mac_extract>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s* ICMPv6 active timers:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last Neighbor-Solicitation sent: +(?P<last_neighbor_solicitation_sent>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last Neighbor-Advertisement sent: +(?P<last_neighbor_advertisement_sent>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Last Router-Advertisement sent: +(?P<last_router_advertisement_sent>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Next Router-Advertisement sent in: +(?P<next_router_advertisement_sent>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Router-Advertisement parameters:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Periodic +interval: +(?P<interval>\\d+) +to +(?P<to_interval>\\d+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Send +\\\"(?P<router_adv_key>[\\w\\s]+)\\\" +(option value|flag|value|field): +(?P<value>\\w+)( +(secs|ms))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Suppress RA: +(?P<suppress>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Suppress MTU in RA: +(?P<suppress_mtu>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Suppress Route Information Option in RA: +(?P<suppress_route_information>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Neighbor-Solicitation parameters:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*NS retransmit interval: +(?P<retransmit_interval>\\d+) +ms$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ND NUD retry +(?P<nd_nud_retry>\\w+): +(?P<nd_nud_retry_value>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ICMPv6 error message parameters:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Send redirects: +(?P<redirects>\\w+) +\\((?P<redirects_count>\\d+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Send unreachables: +(?P<unreachables>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ICMPv6 DAD parameters:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Maximum +DAD +attempts: +(?P<maximum_attempts>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Current +DAD +attempt : +(?P<current_attempt>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ICMPv6 Adjacency Table for +(?P<vrf>[\\w]+) +VRFs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<neighbor>[\\w\\:]+)?( +(?P<age>[\\d\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^((?P<router>\\w+) )?(?P<neighbor>[a-f0-9\\:]+) +on",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current_hop_limit +(?P<current_hop_limit>\\d+), +Lifetime +(?P<lifetime>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^HomeAgentFlag +(?P<homeagentflag>\\d+), +Preference +(?P<preference>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Reachable time +(?P<reachable_time>\\d+) +msec, +Retransmission time +(?P<retransmission_time>\\d+) +msec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Prefix +(?P<prefix>[\\w\\:\\/]+) *onlink_flag +(?P<onlink_flag>\\d+) +autonomous_flag +(?P<autonomous_flag>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^valid lifetime +(?P<valid_lifetime>\\d+), +preferred lifetime +(?P<preferred_lifetime>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show ntp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Total +peers *: +(?P<total_peer>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mode_code>[\\*\\-\\+\\=]+)? *(?P<remote>[\\w\\.\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mode_code>[\\*\\-\\+\\=]+)? *(?P<remote>[\\w\\.\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<st>\\d+) +(?P<poll>\\d+) +(?P<reach>\\d+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<peer>[\\w\\.\\:]+) +(?P<type>\\w+)( *\\((?P<conf>configured)\\))?$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show ospf",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Routing +Process +(?P<instance>\\d+) +with +ID +(?P<router_id>[\\d\\.]+) +VRF +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Routing +Process +Instance +Number +(?P<instance>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Stateful +High +Availability +(?P<enable>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Graceful\\-restart +is +(?P<gr_enable>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Grace +period: +(?P<interval>\\w+) +state: +(?P<state>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +graceful +restart +exit +status: +(?P<status>\\w+).*?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Supports +only +single +TOS\\(TOS0\\) +routes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Supports +opaque +LSA$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Administrative +distance +(?P<pref_all>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BFD +is +enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Reference +Bandwidth +is +(?P<bd>\\d+) +(?P<unit>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SPF +throttling +delay +time +of +(?P<time>[\\d\\.]+) +msecs,$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SPF +throttling +hold +time +of +(?P<time>[\\d\\.]+) +msecs,$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SPF +throttling +maximum +wait +time +of +(?P<time>[\\d\\.]+) +msecs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LSA +throttling +start +time +of +(?P<time>[\\d\\.]+) +msecs,$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LSA +throttling +hold +interval +of +(?P<time>[\\d\\.]+) +msecs,$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LSA +throttling +maximum +wait +time +of +(?P<time>[\\d\\.]+) +msecs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Minimum +LSA +arrival +(?P<time>[\\d\\.]+) +msec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +number +of +non +self\\-generated +LSA +allowed +(?P<max>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Originating +router +LSA +with +maximum +metric$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LSA +group +pacing +timer +(?P<time>\\d+) +secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum paths to destination +(?P<path>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +external +LSAs +(?P<total>\\d+), +checksum +sum +(?P<checksum>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +opaque +AS +LSAs +(?P<total>\\d+), +checksum +sum +(?P<checksum>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +areas +is +(?P<total>\\d+), +(?P<normal>\\d+) +normal, +(?P<stub>\\d+) +stub, +(?P<nssa>\\d+) +nssa$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +active +areas +is +(?P<total>\\d+), +(?P<normal>\\d+) +normal, +(?P<stub>\\d+) +stub, +(?P<nssa>\\d+) +nssa$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Install +discard +route +for +summarized +(?P<type>\\w+) +routes.$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +(?P<type>\\w+)?\\((?P<area>[\\w\\.\\:]+)\\)( *\\((?P<status>\\w+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^This +area +is +a +(?P<type>\\w+) +area$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Generates +stub +default +route +with +cost +(?P<cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Area +has +existed +for +(?P<time>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interfaces +in +this +area: +(?P<num1>\\d+) +Active +interfaces: +(?P<num2>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Passive +interfaces: +(?P<num1>\\d+) +Loopback +interfaces: +(?P<num2>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SPF +calculation +has +run +(?P<num1>\\d+) +times$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +SPF +ran +for +(?P<num1>[\\d\\.]+)s$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<prefix>[\\d\\/\\.]+) +(Active|Passive) +\\(Num +nets: +(?P<net>\\d+)\\) +(?P<advertise>\\w+) +Cost +configured +(?P<cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +LSAs: +(?P<num1>\\d+), +checksum +sum +(?P<num2>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Redistributing +External +Routes +from$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<redist>[\\w]+)(?:-(?P<redist_id>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Name +Lookup +is +(?P<name_lookup>enabled|disabled)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Summarization +is +(?P<summary>disabled)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Perform +(?P<perform_translation>\\S+) +LSA +translation$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<authentication>No|Message\\-digest|Simple)(?: +password)?(?: +authentication(?: +available)?)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Generates +NSSA +(?P<generate_nssa>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^This +router +is +(?P<this_router_is>[\\w\\s]+)(?:\\.)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>[\\w\\.\\-\\/]+) +\\- +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +Autoconfig +not +enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +Autoconfig +is +enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +Sync +is +enabled,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LDP +Sync +not +enabled, +not +required$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State +(?P<state>\\w+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Virtual +link +(?P<link>\\w+) +to +router +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<link>\\w+)-(?P<area>[\\w\\.\\:]+)-",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Transit +area +(?P<transit_area_id>[\\w\\.\\:]+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unnumbered +interface +using +IP +address +of +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Process +ID +(?P<inst>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State +(?P<state>\\w+), +Network +type",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Index +(?P<index>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nbr_count>\\d+) +Neighbors, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timer +intervals: +Hello +(?P<hello>\\d+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello +timer +due +in +(?P<hello_timer>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<auth_type>[\\w\\-]+) +authentication(, +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +opaque +link +LSAs: +(?P<count>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adjacency +Information *:?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Destination +IP +address: +(?P<dest>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +(?P<nei>[\\w\\.\\:]+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Process +ID +(?P<inst>\\d+) +VRF +(?P<vrf>\\S+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^-(?P<remote>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State +is +(?P<status>\\w+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello +options +(?P<hello>\\w+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +non\\-hello +packet +received +(?P<last>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dead +timer +due +in +(?P<dead_timer>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<intf>(\\S+)) +is +(?P<enable>(up|down)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +address +(?P<ip_address>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IP +address +(?P<ip_address>(\\S+)), +Process",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Process +ID +(?P<pid>(\\S+)) +VRF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unnumbered +interface +using +IP +address +of",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Enabled +by +interface +configuration$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State +(?P<state>(\\S+)), +Network +type ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Index +(?P<index>(\\d+))(?:, +Transmit +delay\n                           ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Index +(?P<index>(\\d+)), +Passive +interface$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(D|d)esignated +(R|r)outer +(ID|Id):",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(B|b)ackup +(D|d)esignated +(R|r)outer",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<num_neighbors>(\\d+)) +Neighbors, +flooding",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timer +intervals: +Hello +(?P<hello>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello +timer +due +in +(?P<hello>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Simple +authentication(?:, +using +keychain",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Message-digest +authentication, +using",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +opaque +link +LSAs:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BFD +is +enabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +(?P<neighbor_router_id>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Process +ID +(?P<instance>(\\S+)) +VRF",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State +is +(?P<state>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Neighbor +priority +is +(?P<priority>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^DR +is +(?P<dr_ip>(\\S+)) +BDR +is",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hello +options +(?P<hello_options>(\\S+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last +non-hello +packet +received",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dead +timer +due +in +(?P<dead_timer>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ *OSPF +Router +with +ID +\\((?P<router_id>(\\S+))\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<lsa_type_name>(.*)) +Link +States",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LS +age: +(?P<age>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Options: +(?P<option>([a-zA-Z0-9]+))(?:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LS +Type: +(?P<lsa_type>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +State +ID: +(?P<lsa_id>(\\S+))",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Advertising +Router: +(?P<adv_router>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^LS +Seq +Number: +(?P<ls_seq_num>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Checksum: +(?P<checksum>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Length: +(?P<length>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Network +Mask: +\\/(?P<net_mask>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric +Type: +2 +\\(.*\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TOS: +(?P<tos>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TOS: +(?P<tos>(\\d+)) +Metric: +(?P<metric>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Metric: +(?P<metric>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Forward +Address: +(?P<addr>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^External +Route +Tag: +(?P<tag>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Attached +Router: +(?P<att_router>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +links: +(?P<num>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +connected +to: +a +(?P<type>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(Link +ID\\) +Network\\/Subnet +Number:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(Link +ID\\) +Designated +Router +address:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(Link +ID\\) +Neighboring +Router +ID:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(Link +Data\\) +Network +Mask:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\(Link +Data\\) +Router +Interface +address:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +TOS +metrics: +(?P<num>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^TOS +(?P<tos>(\\d+)) +Metric: +(?P<metric>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Opaque +Type: +(?P<type>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Opaque +ID: +(?P<id>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Fragment +number: +(?P<num>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MPLS +TE +router +ID *: +(?P<mpls>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number +of +Links *: +(?P<links>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +connected +to +(?P<link>(.*))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?:Link-ID +:)? *(Link +ID|Link-ID) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?:Interface +Address +:)? *Interface",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Admin +Metric *: +(?P<te_metric>(\\d+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +(B|b)andwidth *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +(R|r)eservable +(B|b)andwidth *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Affinity +Bit *: +(?P<admin_group>(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Priority +(?P<num1>(\\d+)) *:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Unknown +Sub-TLV *: +Type += +(?P<type>(\\d+)),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<something>([0\\s]+))$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show pim",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*PIM6? +Interface +Status +for +VRF+ \\\"(?P<vrf>[\\w]+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface_name>[\\w\\/\\.\\-]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<space>\\s{4})",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +DR: +(?P<dr_address>[\\w\\:]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +neighbor +count: +(?P<nbr_count>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +hello +interval: +(?P<hello_interval>[\\d]+) +secs",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +neighbor +holdtime: +(?P<holdtime>[\\d]+) +secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +configured +DR +priority: +(?P<configured_dr_priority>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +configured +DR +delay: +(?P<configured_dr_delay>[\\d]+) +secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +border +interface: +(?P<border_interface>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +GenID +sent +in +Hellos: +(?P<genid>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +Hello +MD5-AH +Authentication: +(?P<md5_authentication>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +Neighbor +policy: +(?P<nbr_policy>(?!none +configured)[\\w\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +Join-Prune +inbound +policy: +(?P<jp_inbound_policy>(?!none)[\\w\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +Join-Prune +outbound +policy: +(?P<jp_outbound_policy>(?!none)[\\w\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +Join-Prune +interval: +(?P<jp_interval>[\\d]+) +minutes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +Join-Prune +next +sending: +(?P<jp_next_sending>[\\d]+) +minutes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +BFD +enabled: +(?P<bfd_enabled>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +passive +interface: +(?P<passive>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +VPC +SVI: +(?P<vpc_svi>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +Auto +Enabled: +(?P<auto_enabled>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6? +Interface +Statistics+(, +last +reset: +(?P<last_reset>[\\w\\:]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Hellos: +(?P<hellos>[\\d\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Grafts: +(?P<grafts>[\\d\\/]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*DF-Offers: +(?P<df_offers>[\\d\\/]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Checksum errors: +(?P<checksum>[\\d]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Authentication +failed: +(?P<authentication_failed>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Packet +length +errors: +(?P<packet_length_errors>[\\d]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Packets +from +non\\-neighbors: +(?P<packets_from_non_neighbors>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Packets +received +on +passiveinterface:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*JPs +received +on +RPF\\-interface:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<s_g>[\\w\\(\\)\\,\\*]+) +Joins +received +with +no\\/+wrong RP:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<s_g>[\\w\\(\\)\\,\\*\\/]+) +JPs +received +for +SSM\\/Bidir +groups:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*JPs +filtered +by +inbound +policy:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*JPs +filtered +by +outbound +policy:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(PIM6|PIM) +RP +Status +Information +for +VRF +\\\"(?P<vrf_name>[\\w\\S]+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BSR: +(?P<bsr>[\\w\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BSR(\\:)? +(?P<bsr_candidate>[\\w\\s\\.\\*\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Auto-RP +disabled$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Auto-RP RPA: +(?P<auto_rp_address>[\\w\\S]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BSR +RP +Candidate +policy: +(?P<bsr_rp_candidate_policy>[\\w\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BSR +RP +policy: +(?P<bsr_rp_policy>[\\w\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Auto\\-RP +Announce +policy: +(?P<auto_rp_announce_policy>[\\w\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Auto\\-RP +Discovery +policy: +(?P<auto_rp_discovery_policy>[\\w\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Anycast\\-RP +(?P<anycast_rp>[\\w\\d\\S]+) +members:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<anycast_rp_members>[\\w\\.\\:\\*\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RP: +(?P<rp>[\\w\\d\\S]+), +\\(+(?P<df_ordinal>[\\d\\S]+)+\\),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RP: +(?P<rp>[\\w\\d\\S]+), +\\(+(?P<df_ordinal>[\\d\\S]+)+\\),$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*uptime: +(?P<uptime>[\\w\\.\\:]+),?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RP\\-source:( +(?P<rp_source>\\S+))? +\\(+(?P<info_source_type>\\w+)+\\),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RP\\-source: +(?P<rp_source>\\S+) +\\(+(?P<info_source_type>\\w+)+\\),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^group +ranges:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*priority: +(?P<priority>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<group_ranges>[\\w\\/\\.\\:\\s]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*priority: +(?P<priority>\\d+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Bidir-PIM6 +Designated +Forwarder",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<rp_address>[\\w\\:\\.]+) +\\((?P<ordinal>\\d+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<space>\\s{23})",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>[\\w\\-\\/]+) +(?P<df_address>[\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Bidir-PIM +Designated +Forwarder",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<rp_address>[\\d\\.]+) +\\((?P<ordinal>\\d+)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface>\\S+) +(?P<df_address>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6 +Routing +Table +for +VRF +\\\"(?P<vrf_name>[\\S]+)\\\" +\\-",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\((?P<source_address>[\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Incoming +interface: (?P<incoming_interface>[\\S]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Oif-list: +\\((?P<oif_count>[\\d]+)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Immediate-list: +\\((?P<imm_count>[\\d]+)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Sgr-prune-list: +\\((?P<sgr_count>[\\d]+)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Timeout-interval: +(?P<timeout_interval>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PIM6? +Neighbor +Status +for +VRF +\\\"(?P<vrf_name>[\\S]+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<neighbor>[\\S]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Secondary +addresses:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<secondary_address>([a-zA-Z0-9\\.\\:]+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Routing +Table +for +VRF +\\\"(?P<vrf_name>[\\S]+)\\\" +\\-",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\((?P<source_address>[\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Incoming +interface: (?P<incoming_interface>[\\S]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Oif-list: +\\((?P<oif_count>[\\d]+)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Immediate-list: +\\((?P<imm_count>[\\d]+)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Sgr-prune-list: +\\((?P<sgr_count>[\\d]+)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Timeout-interval: +(?P<timeout_interval>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM6 +Group\\-Range +Configuration +for +VRF +\\\"(?P<vrf_name>[\\S]+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<group_range>[^\\s*Group-range][\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Neighbor +Status +for +VRF +\\\"(?P<vrf_name>[\\S]+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<neighbor>[\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<vrf>[\\w\\d]+) +(?P<vrf_id>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*State +Limit: +(?P<state_limit>(?!None)\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Register +Rate +Limit: +(?P<register_rate_limit>(?!none)\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Register +source +interface +: +(?P<intf_name>[\\w\\d\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Shared +tree +ranges: +(?P<shared_tree_ranges>(?!none)\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\(S\\,G\\)\\-expiry +timer: +(?P<expiry_timer_configured>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\(S\\,G\\)\\-list +policy: +(?P<sg_list_policy>(?!none)[\\w\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\(S\\,G\\)\\-expiry +timer +config +version +(?P<expiry_timer_config_version>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Pre\\-build +SPT +for +all +\\(S\\,G\\)s +in +VRF: +(?P<pre_build_spt>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*CLI +vrf +done: +(?P<cli_vrf_done>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +cibtype +[a|A]uto +[e|E]nabled: +(?P<cibtype_auto_enabled>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +VxLAN +VNI +ID: +(?P<vxvlan_vni_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Group\\-Range +Configuration +for +VRF +\\\"(?P<vrf_name>[\\S]+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<group_range>[^\\s*Group-range][\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ip +pim +register-policy( +prefix-list)? +(?P<rg_policy_name>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vrf +context +(?P<vrf_name>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*C: +No. +of +comparisions, +M: +No. +of matches$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-map +(?P<route_map>[\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*match +ip +multicast +group +(?P<group>[\\w\\.\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ip +prefix-list +(?P<prefix_list>[\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Total +accept +count +for +policy: +(?P<accept_policy_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Total +reject +count +for +policy: +(?P<reject_policy_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Interface +Status +for +VRF+ \\\"(?P<vrf>[\\w]+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interface_name>[\\w\\/\\.\\-]+),?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP +address: +(?P<address>[\\w\\.]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +DR: +(?P<dr_address>[\\w\\.]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +neighbor +count: +(?P<nbr_count>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +hello +interval: +(?P<hello_interval>[\\d]+) +secs",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +neighbor +holdtime: +(?P<holdtime>[\\d]+) +secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +configured +DR +priority: +(?P<configured_dr_priority>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +configured +DR +delay: +(?P<configured_dr_delay>[\\d]+) +secs$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +border +interface: +(?P<border_interface>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +GenID +sent +in +Hellos: +(?P<genid>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Hello +MD5-AH +Authentication: +(?P<md5_authentication>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Neighbor +policy: +(?P<nbr_policy>(?!none)[\\w\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Join-Prune +inbound +policy: +(?P<jp_inbound_policy>(?!none)[\\w\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Join-Prune +outbound +policy: +(?P<jp_outbound_policy>(?!none)[\\w\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Join-Prune +interval: +(?P<jp_interval>[\\d]+) +minutes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Join-Prune +next +sending: +(?P<jp_next_sending>[\\d]+) +minutes$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +BFD +enabled: +(?P<bfd_enabled>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +passive +interface: +(?P<passive>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +VPC +SVI: +(?P<vpc_svi>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Auto +Enabled: +(?P<auto_enabled>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*PIM +Interface +Statistics+(, +last +reset: +(?P<last_reset>[\\w\\:]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Hellos: +(?P<hellos>[\\d\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Grafts: +(?P<grafts>[\\d\\/]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*DF-Offers: +(?P<df_offers>[\\d\\/]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Checksum errors: +(?P<checksum>[\\d]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Authentication +failed: +(?P<authentication_failed>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Packet +length +errors: +(?P<packet_length_errors>[\\d]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Packets +from +non\\-neighbors: +(?P<packets_from_non_neighbors>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Packets +received +on +passiveinterface:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*JPs +received +on +RPF\\-interface:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<s_g>[\\w\\(\\)\\,\\*]+) +Joins +received +with +no\\/+wrong RP:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<s_g>[\\w\\(\\)\\,\\*\\/]+) +JPs +received +for +SSM\\/Bidir +groups:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*JPs +filtered +by +inbound +policy:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*JPs +filtered +by +outbound +policy:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<vrf>[\\w\\d]+) +(?P<vrf_id>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*State +Limit: +(?P<state_limit>(?!None)\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Register +Rate +Limit: +(?P<register_rate_limit>(?!none)\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Shared +tree +route-map: +(?P<route_map>[\\w\\d\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-ranges:( +(?P<route_range>[\\w\\d\\S]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Shared +tree +ranges: +(?P<shared_tree_ranges>(?!none)\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^feature +pim$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^feature +pim6$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ip(v6)? +pim *(bsr)? +bsr\\-candidate +(?P<bsr_candidate_interface>[\\w\\/\\.\\-]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<af>ip|ipv6) +pim +rp\\-address +(?P<static_rp_address>[\\w\\.\\:]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<af>ip|ipv6) +pim( *bsr)? +rp\\-candidate +(?P<bsr_rp_candidate_interface>[\\w\\/\\.\\-]+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ip +pim +(send\\-rp\\-announce|(auto\\-rp +rp\\-candidate)) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ip +pim +send\\-rp\\-discovery +(?P<send_rp_discovery_intf>[\\w\\/\\.\\-]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ip +pim +auto\\-rp +forward +listen$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show platform",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*Cisco +(?P<platform>[a-zA-Z]+) +Operating +System +\\((?P<os>[A-Z\\-]+)\\)? +Software$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Software$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BIOS: +version +(?P<bios_version>[0-9\\.]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*kickstart: +version +(?P<kickstart_version>[\\w\\.\\(\\)\\[\\]\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*system: +version +(?P<system_version>[\\w\\.\\(\\)\\[\\]\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*NXOS: +version +(?P<system_version>[A-Za-z0-9\\.\\(\\)\\[\\]\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*BIOS +compile +time: +(?P<bios_compile_time>[0-9\\/]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*kickstart +image +file +is: +(?P<kickstart_image_file>[\\w\\:\\/\\-\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*kickstart +compile +time: +(?P<kickstart_compile_time>[0-9\\/\\s\\:\\[\\]]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*system +image +file +is: +(?P<system_image_file>[\\w\\:\\/\\-\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*system +compile +time: +(?P<system_compile_time>[0-9\\/\\s\\:\\[\\]]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*NXOS +image +file +is: +(?P<system_image_file>[\\w\\:\\/\\-\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*NXOS +compile +time: +(?P<system_compile_time>[0-9\\/\\s\\:\\[\\]]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Hardware$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*cisco +(?P<model>[a-zA-Z0-9\\-\\s]+)( +\\((?P<slot>[0-9]+) Slot\\))?( +[C|c]hassis)?( +\\(\\\"(?P<rp>( +\\((?P<slot>[0-9]+) Slot\\))?( +[C|c]hassis)( +\\(\\\"(?P<rp>( +\\((?P<slot>[0-9]+) Slot\\))? +[C|c]hassis( +\\(\\\"(?P<rp>[a-zA-Z0-9\\s\\-\\/\\+]+)\\\"\\))?(\\s)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<cpu>.*) +with +(?P<memory>[0-9a-zA-Z\\s]+) +of +memory\\.$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Processor +Board +ID +(?P<processor_board_id>[A-Z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Device name: +(?P<device_name>[a-zA-Z0-9\\-\\_]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*bootflash: +(?P<bootflash>[a-zA-Z0-9\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*slot0: +(?P<slot0>[a-zA-Z0-9\\s]+) +\\(expansion flash\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Kernel +uptime +is +(?P<days>[0-9]+) +day\\(s\\), +(?P<hours>[0-9]+) +hour\\(s\\), +(?P<minutes>[0-9]+) +minute\\(s\\), +(?P<seconds>[0-9]+) +second\\(s\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Reason: +(?P<reason>[a-zA-Z0-9\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*System version: +(?P<system_version>[0-9\\(\\)\\.]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^NAME: +\\\"(?P<name>[\\S\\s]+)\\\", +DESCR: +\\\"(?P<description>[\\S\\s]+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Slot +(?P<slot>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PID: +(?P<pid>[\\S]*) +, +VID: +(?P<vid>[\\S]*) *, +SN: *(?P<serial_number>[\\S]*)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<boot_images>[a-zA-Z\\s]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Kickstart Image: +(?P<kickstart_image>[a-zA-z0-9\\:\\/\\-\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*System Image: +(?P<system_image>[a-zA-z0-9\\:\\/\\-\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Active Packages:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Active Packages on Module #(?P<module_number>[0-9]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<active_package_name>[a-zA-z0-9\\-\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Redundancy mode$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Redundancy +information +not +available +for +this +platform$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*administrative: +(?P<administrative>[a-zA-z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*operational: +(?P<operational>[a-zA-z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(This|Other) +supervisor +\\(sup-(?P<sup_num>\\d+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Redundancy state: +(?P<redundancy_state>[a-zA-z\\W\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Supervisor state: +(?P<supervisor_state>[a-zA-z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Internal state: +(?P<internal_state>[a-zA-z\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*System start time: +(?P<system_start_time>[a-zA-z0-9\\:\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*System uptime: +(?P<system_uptime>[a-zA-z0-9\\:\\,\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Kernel uptime: +(?P<kernel_uptime>[a-zA-z0-9\\:\\,\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Active supervisor uptime: +(?P<active_supervisor_time>[a-zA-z0-9\\:\\,\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Current Boot Variables:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Boot Variables on next reload:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*sup-1$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*sup-2$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*kickstart variable = +(?P<kickstart_variable>[a-zA-z0-9\\:\\-\\.\\/\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*system variable = +(?P<system_variable>[a-zA-z0-9\\:\\-\\.\\/\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*NXOS +variable += +(?P<image>[a-zA-z0-9\\:\\-\\.\\/\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Boot POAP +(?P<boot_poap>[a-zA-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Mod.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Xbar.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<number>[0-9]+) +(?P<ports>[0-9]+) +(?P<module_type>[a-zA-Z0-9\\/\\-\\s\\+]+) +(?P<model>\\S+) +(?P<status>[a-zA-Z\\-\\s]+) *\\*?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<number>[0-9]+) +(?P<ports>[0-9]+) +(?P<module_type>[a-zA-Z0-9\\/\\-\\s\\+]+) +(?P<status>[a-zA-Z\\-\\s]+) *\\*?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<number>[0-9]+) +(?P<software>[A-Z0-9\\(\\)\\.]+) +(?P<hardware>[0-9\\.]+)( +)?(?P<world_wide_name>[\\w\\-]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<number>[0-9]+) +(?P<mac_address>[a-zA-Z0-9\\.\\-\\s]+) +(?P<serial_number>[A-Z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<number>[0-9]+) +(?P<online_diag_status>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<size>[0-9]+) +(?P<month>[a-zA-Z]+) +(?P<day>[0-9]+) +(?P<time>[0-9\\:]+) +(?P<year>[0-9]+) +(?P<file>[a-zA-Z0-9\\.\\/\\_\\-\\+]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<disk_space>[0-9]+) bytes +(?P<type>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Usage +for +(?P<directory_name>[a-z\\:]+).*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Switchwide +mode +is +.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +id: +(?P<id>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +name: +(?P<name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +state: +(?P<state>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +mac +address: +(?P<mac>[a-z0-9\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +ha +policy: +(?P<policy>[A-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +dual-sup +ha +policy: +(?P<dual_policy>[A-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +boot +Order: +(?P<boot_order>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*CPU +Share: +(?P<cpu_share>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*CPU +Share +Percentage: +(?P<cpu_share_percentage>[0-9\\%]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +create +time: +(?P<vdc_create_time>[a-zA-Z0-9\\:\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +reload +count: +(?P<reload_count>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +uptime: +(?P<uptime>[a-z0-9\\(\\)\\s\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +restart +count: +(?P<count>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +restart +time: +(?P<restart_time>[a-zA-Z0-9\\:\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +type: +(?P<type>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc +supported +linecards: +(?P<linecards>[a-zA-Z0-9\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Current +vdc +is +(?P<id>\\d+) *- *(?P<name>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Flags : b - breakout port$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vdc_id: +(?P<id>[0-9]+) +vdc_name: +(?P<name>\\S+) +interfaces:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Port +Status$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<port_type>[a-zA-Z]+)(?P<port_number>[0-9a-z/\\\\(\\)]+) +(?P<status>[A-Z]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show prefix_list",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(ipv6|ip) +prefix\\-list +(?P<name>\\S+)\\: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^seq +(?P<seq>\\d+) +(?P<action>\\w+) +",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show process",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^((?P<pid>\\d+)|\\-)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show rip",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^RIP +Isolate +Mode: +(?P<isolate_mode>(Yes|No))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^MMODE\\: +(?P<mmode>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Process +Name +\\\"(?P<instance>.+)\\\" +VRF +\\\"(?P<vrf>.+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RIP +port +(?P<port>\\d+), +multicast\\-group +(?P<multicast_group>[\\w\\:\\/\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Admin\\-distance\\: +(?P<distance>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Updates +every +(?P<update_interval>\\d+) +sec, +expire +in +(?P<expire_in>\\d+) +sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Collect +garbage +in +(?P<collect_garbage>\\d+) +sec$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Default\\-metric\\: +(?P<default_metric>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Max\\-paths\\: +(?P<maximum_paths>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Default\\-originate\\: *(?P<default_originate>[\\s\\S]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Process +is +(?P<process>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>^(?!None)[\\w\\/\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<redistribute>\\w+)\\s+policy +(?P<route_policy>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Process +Name +\\\"(?P<instance>.+)\\\" +VRF +\\\"(?P<vrf>.+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<best>\\>)? *(?P<route>[a-zA-Z0-9\\.\\/\\:]+) +next\\-hops +(?P<next_hops>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms).*(?P<route_type>((direct +route)|external|external\\-backup|rip))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms).*timeout +(?P<expire_time>[\\d\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms).*redistributed +route$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Process +Name +\\\"(?P<instance>.+)\\\" +VRF +\\\"(?P<vrf>.+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<interface>\\S+), +protocol\\-(?P<protocol_state>(up|down))\\/link\\-(?P<link_state>(up|down))\\/admin\\-(?P<admin_state>(up|down)), +RIP +state *\\: +(?P<oper_status>(up|down))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^address\\/mask +(?P<ipv4>[\\d\\.\\/]+), +metric +(?P<metric>\\d+)(, +(?P<split_horizon>split\\-horizon))?(, +(?P<passive>passive)[a-zA-Z\\(\\) ]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Authentication +Mode\\: +(?P<crypto_algorithm>\\w+) +Keychain\\: +(?P<key_chain>\\w+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show route_map",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*route-map *(?P<name>\\S+)\\,",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*description +(?P<description>[a-zA-Z0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*as-path *\\(as-path *filter\\):",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*as-number *\\(as-path-list *filter\\)\\:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ip *address *prefix-lists:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ip *address *\\(access-lists\\):",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ip *next-hop *prefix-lists:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ipv6 *address *prefix-lists:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ipv6 *address *\\(access-lists\\):",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ipv6 *next-hop *prefix-lists:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*interface: *(?P<match_interface>[a-zA-Z0-9\\/\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*metric: *(?P<match_med_eq>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*community *\\(community-list *filter\\):",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-type: *(?P<match_route_type>[a-z0-9\\-\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*extcommunity *\\(extcommunity-list *filter\\):",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*tag: *(?P<match_tag_list>[0-9\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ip *next-hop *(?P<set_next_hop>[0-9a-z\\.\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ipv6 *next-hop *(?P<set_next_hop_v6>[a-z0-9\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*tag *(?P<set_tag>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*weight *(?P<set_weight>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*metric *(?P<set_med>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*distance: *(?P<set_distance>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*metric-type *(?P<set_metric_type>[0-9a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*level *(?P<set_level>[a-z0-9\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*local-preference *(?P<set_local_pref>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*origin *(?P<set_route_origin>[a-z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*comm-list *(?P<set_community_delete>[a-z]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*community *(?P<set_community>[0-9\\:]+)(?:",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*as-path *prepend",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*extcomm-list",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*extcommunity",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*extcommunity",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<clause>(Set clauses:))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*level *(?P<set_level>([a-z0-9\\s\\-]+))$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show routing",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(IP|IPv6) +(Route|Routing) +Table +for +VRF +\"(?P<vrf>\\S+)\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<ip_mask>[\\w\\:\\.\\/]+), +ubest/mbest: +(?P<ubest>\\d+)/(?P<mbest>\\d+)( +time)?(, +(?P<attach>\\w+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<cast>.*)via +(?P<nexthop>[\\w\\.\\:\\s]+)(%(?P<table>[\\w\\:]+))?, *((?P<int>[a-zA-Z0-9\\./_]+),)? *\\[(?P<preference>\\d+)/(?P<metric>\\d+)\\], *(?P<up_time>[\\w\\:\\.]+), *(?P<protocol>\\w+)(\\-(?P<process>\\w+))?,? *(?P<attribute>\\w+)?,? *(tag *(?P<tag>\\w+))?,? *(?P<vpn>[a-zA-Z\\(\\)\\-]+)?,?( +segid: +(?P<segid>\\d+))?,?( +tunnelid: +(?P<tunnelid>[0-9x]+))?,?( +encap: +(?P<encap>[a-zA-Z0-9]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(IP|IPv6) +(Route|Routing) +Table +for +VRF +\\\"(?P<vrf>\\S+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +number +of +(?P<route_path>\\w+): +(?P<route_path_val>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Best +paths +per +protocol.*$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<best>[\\w-]+) +: +(?P<best_val>\\d+)( +(None|((?P<backup>\\S+) +: +(?P<backup_val>\\d+))))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<route_mask>/\\d+) *: +(?P<route_mask_len>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IP(?:v6)? +Rout(?:e|ing) +Table +for (VRF|Context) +\\\"(?P<vrf>\\S+)\\\"$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<route>[\\w\\/\\.\\:]+), +(ubest/mbest: +(?P<ubest_mbest>[\\d\\/]+)( +time)?)?((?P<ubest>\\d+) +ucast +next-hops, +(?P<mbest>\\d+) +mcast +next-hops)?(, +(?P<attached>[\\w]+))?( +(?P<attached2>[\\w]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<star>[*]+)?via +(?P<next_hop>[\\s\\w\\:\\.\\/\\%]+),( +(?P<interface>[\\w\\/\\.]+))?,? +\\[(?P<route_preference>[\\d\\/]+)\\], +(?P<date>[0-9][\\w\\:]+)?,?( +(?P<source_protocol>[\\w\\-]+))?,?( +(?P<source_protocol_status>[\\w-]+))?,?( +tag +(?P<tag>[\\d]+))?,?( +\\((?P<hidden>hidden)\\))?\\s*(?P<vpn>[a-zA-Z\\(\\)\\-]+)?,?( +segid: +(?P<segid>\\d+))?,?( +tunnelid: +(?P<tunnelid>[0-9x]+))?,?( +encap: +(?P<encap>[a-zA-Z0-9]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^tag +(?P<tag>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show spanning_tree",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^##### MST(?P<mst_id>\\d+) +\\s+vlans\\s+mapped: +\\s+(?P<vlan>\\w+\\-\\w+,\\w+\\-\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge +\\saddress\\s+(?P<b_address>\\w+\\.\\w+.\\w+) +\\spriority +\\s(?P<b_priority>\\d+)\\s+\\(\\d+\\s+sysid\\s+(?P<b_sysid>\\d+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root +\\s(?P<switch>\\w+\\s+\\w+)\\s+for\\s+the\\s+(?P<root>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mst_domain>\\w+) +\\shello\\s+time\\s+(?P<hello_time>\\d+),\\s+forward\\s+delay\\s+(?P<forward_delay>\\d+),\\s+max\\s+age\\s+(?P<max_age>\\d+), ((txholdcount|max hops))\\ *\\s(?P<holdcount_or_maxhops>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<port_channel>\\w+)\\sof\\s+\\w+\\s+is\\s+(?P<port_state>\\w+)\\s+\\(Bridge Assurance\\s+(?P<bridge_assurance_inconsistent>\\w+), VPC Peer-link\\s+(?P<vpc_peer_link_inconsistent>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port\\s+info +\\sport\\s+id +\\s(?P<port_id>\\d+\\.*\\d+) +\\spriority +\\s(?P<port_priority>\\d+) +\\scost +\\s(?P<port_cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Designated\\s+root +\\saddress\\s+(?P<d_root_address>\\w+\\.\\w+\\.\\w+) +\\spriority +\\s(?P<d_priority>\\d+) +\\scost +\\s(?P<d_cost>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Design.\\s+regional\\s+root\\s+address\\s+(?P<designated_regional_root_address>\\w+\\.\\w+\\.\\w+) +\\spriority +\\s(?P<designated_regional_root_priority>\\d+) +\\scost +\\s(?P<designated_regional_root_cost>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Designated\\s+bridge +\\saddress\\s+(?P<d_bridge_address>\\w+\\.\\w+\\.\\w+) +\\spriority +\\s(?P<d_bridge_priority>\\d+) +\\sport\\s+id\\s+(?P<d_bridge_port_id>\\d+(\\.\\d+)*)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timers\\:\\s+message\\s+expires\\s+in\\s+(?P<message_expires_in>\\d+)\\s+sec,\\s+forward\\s+delay\\s+(?P<forward_delay>\\d+),\\s+forward\\s+transitions\\s+(?P<forward_transitions>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bpdus\\s+sent\\s+(?P<bpdus_sent>\\d+),\\s+received\\s+(?P<bpdus_received>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Switch +is +in +(?P<mode>[\\S]+) +mode(?: +\\((?P<mst_type>[\\w\\s]+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root +bridge +for: +(?P<root_bridge_for>[\\S, ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +Type +Default\\s+is +(?P<port_type_default>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Edge\\s+Port\\s+\\[PortFast\\]\\s+BPDU\\s+(?P<port_type>\\w+)\\s+Default\\s+is\\s+(?P<bpdu_bool>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge +Assurance\\s+is +(?P<bridge_assurance>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Loopguard +Default\\s+is +(?P<loop_guard>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?:Configured +)?Pathcost +method +used\\s+is +(?P<path_cost_method>\\w+)(?: +\\(Operational +value +is +(?P<operational_value>\\w+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PVST\\s+Simulation +\\s+is\\s+(?P<pvst_simulation>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^vPC +peer-switch\\s+is +(?P<vpc_peer_switch>\\w+)(?: +\\((?P<vpc_peer_switch_status>[\\S]+)?\\))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^STP-Lite\\s+is +(?P<stp_lite>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<mode_name>\\w+) *\\s+(?P<blocking>\\d+) *\\s+(?P<listening>\\d+) *\\s+(?P<learning>\\d+) *\\s+(?P<forwarding>\\d+) *\\s+(?P<stp_active>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\d+\\s+\\w+ *\\s+(?P<blockings>\\d+) *\\s+(?P<listenings>\\d+) *\\s+(?P<learnings>\\d+) *\\s+(?P<forwardings>\\d+) *\\s+(?P<stp_actives>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<root_bridge_for>(?:(?:[\\w-]+, +)+)?[\\w-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(MST|VLAN)?(?P<inst>\\w+)\\s+is\\s+executing\\s+the\\s+(?P<mode>\\w+)\\s+compatible\\s+Spanning\\s+Tree\\s+protocol$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Bridge\\s+Identifier\\s+has\\s+priority\\s+(?P<bridge_priority>\\d+),\\s+sysid\\s+(?P<bridge_sysid>\\d+),\\s+address\\s+(?P<bridge_address>\\w+\\.\\w+\\.\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configured\\s+hello\\s+time\\s+(?P<hello_time>\\d+)(?:, +fex +hello +time +(?P<fex_hello_time>\\d+))?,\\s+max\\s+age\\s+(?P<max_age>\\d+),\\s+forward\\s+delay\\s+(?P<forwarding_delay>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^We\\s+(?P<root_of_the_spanning_tree>\\w+[\\root\\s+of\\s+the\\s+spanning\\s+tree$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology\\s+change\\s+flag\\s+(?P<topology_change_flag>[\\w\\s]+),\\s+detected\\s+flag\\s+(?P<topology_detected_flag>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number\\s+of\\s+topology\\s+changes\\s+(?P<topology_changes>\\d+)\\s+last\\s+change\\s+occurred\\s+(?P<time_since_topology_change>[\\w\\.\\:]+)(\\s+ago)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Times\\:\\s+hold\\s+(?P<hold>\\d+),\\s+topology\\s+change\\s+(?P<topology_change>\\d+),\\s+notification\\s+(?P<notification>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^hello +(?P<hello>\\d+), +max +age +(?P<max_age>\\d+), +forward +delay +(?P<forwarding_delay>[\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timers:\\s+hello\\s+(?P<hello>\\d+),\\s+topology\\s+change\\s+(?P<topology_change>\\d+),\\s+notification\\s+(?P<notification>\\d+)(,\\s+aging\\s+(?P<aging>\\d+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +(?P<port_num>\\d+) +\\((?P<name>[\\S]+)(?:(, +[\\w\\s\\-]+))?\\) +of +(?P<inst>\\w+) +is +(?P<status>\\w+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ce (?P<bridge_assurance_inconsistent>\\w+)\\,\\s+VPC\\sPeer\\-link\\s+(?P<vpc_peer_link_inconsistent>\\w+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port\\s+path\\s+cost\\s+(?P<cost>\\d+),\\s+Port\\s+priority\\s+(?P<port_priority>\\d+),\\s+Port\\s+Identifier\\s+(?P<port_identifier>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Designated\\s+root\\s+has\\s+priority\\s+(?P<designated_root_priority>\\d+),\\s+address\\s+(?P<designated_root_address>[\\w\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Designated\\s+bridge\\s+has\\s+priority\\s+(?P<designated_bridge_priority>\\d+),\\s+address\\s+(?P<designated_bridge_address>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Designated\\s+port\\s+id\\s+is\\s+(?P<designated_port_id>[\\w\\.]+),\\s+designated\\s+path\\s+cost\\s+(?P<designated_path_cost>\\d+)(, +(?P<topology_change>Topology +change +is +set))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timers:\\s+message\\s+age\\s+(?P<message_age>\\-?\\d+),\\s+forward\\s+delay\\s+(?P<forward_delay>\\d+),\\s+hold\\s+(?P<hold>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number\\s+of\\s+transitions\\s+to\\s+forwarding\\s+state:\\s+(?P<number_of_forward_transitions>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^The +port +type +is +(?P<port_type>[\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Link +type +is +(?P<link_type>[\\w\\-]+)(?: +by +default(?:, +(?P<internal>\\S+))?)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^PVST\\s+Simulation\\s+is\\s+(?P<pvst_simulation>\\w+)\\s+by\\s+default$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^BPDU:\\s+sent\\s+(?P<bpdu_sent>\\d+),\\s+received\\s+(?P<bpdu_received>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^from +(?P<topology_from_port>[\\w\\.\\/\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Root +guard +is (?P<root_guard>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>[\\w\\s\\-]+) +(?P<status>[D|d]isabled|[e|E]nabled)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Timer +interval\\: +(?P<interval>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show static_routing",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*Static-route +for +VRF +\\\"(?P<vrf>[\\w]+)\\\"\\((?P<number>[\\d])\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<route>[\\d\\/\\.]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\(not +installed +in +(?P<urib>[\\w]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*\\(installed +in +(?P<urib>[\\w]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*rnh\\(installed +in +(?P<urib>[\\w]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IPv6 +Configured +Static +Routes +for +VRF +\\\"(?P<vrf>[\\w]+)\\\"\\((?P<index>\\d)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<route>[\\d\\/\\:]+)( +\\-\\> +(?P<nexthop>[\\d\\:\\/]+), )?",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*nh_vrf\\((?P<next_vrf>[\\w]+)\\) +reslv_tid +(?P<resolved_tid>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*real-next-hop: +(?P<real_next_hop>[\\d\\:]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*rnh\\((?P<not>[not]+)? ?installed +in +(?P<urib>[\\w]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*bfd_enabled +(?P<bfd>[\\w]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show system",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Service +\\\"(?P<inst>[\\w\\-]+)\\\" *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^UUID *= *(?P<uuid>\\w+), *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State: *(?P<state>[\\w\\s\\[\\]]+) *",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Restart +count: +(?P<restart_count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Time +of +last +restart: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)The service never crashed since the last reboot.",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)The service has never been started since the last reboot.",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Previous +PID: +(?P<previous_pid>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Reason +of +last +termination: +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Plugin +ID: +(?P<plugin_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Tag *= *(?P<tag>(N\\/A)|(\\S+))$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<entry>[A-Z\\*\\(\\+\\)]+) +(?P<vlan>[0-9]+) ",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show trm",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^advertise +evpn +multicast$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show vdc",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^ *(?P<name>\\S+) +(?P<total_used>\\d+) +used +(?P<total_unused>\\d+) +unused +(?P<total_free>\\d+) +free +(?P<total_avail>\\d+) +avail +(?P<total>\\d+) +total$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^ *(?P<name>\\S+) +(?P<min>\\d+) +(?P<max>\\d+) +(?P<used>\\d+) +(?P<unused>\\d+) +(?P<free>\\d+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show virtual_service",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Infrastructure +version +: +(?P<version>[0-9.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Total +virtual +services +(?P<state>\\S+) +: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Machine +types +(?P<state>\\S+) +: +(?P<kinds>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Maximum +VCPUs +per +virtual +service +: +(?P<count>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<name>(\\S+))\\s+",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Virtual +service +(?P<name>\\S+) +detail$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State +: +(?P<state>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Package information$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Name +: +(?P<name>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Path +: +(?P<path>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Application$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Name +: +(?P<name>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Installed +version +: +(?P<version>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Description +: +(?P<description>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Signing",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Key +type +: +(?P<key_type>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Method +: +(?P<method>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Licensing",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Name +: +(?P<name>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Version +: +(?P<version>.+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Resource reservation$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Disk +: +(?P<disk>\\d+) +MB$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Memory +: +(?P<memory>\\d+) +MB$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CPU +: +(?P<cpu>\\d+)% system CPU",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Attached devices$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Type +Name +Alias$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Memory\\s+Allocation:\\s+(?P<kb>\\d+)\\s+KB$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Memory\\s+Used:\\s+(?P<kb>\\d+)\\s+KB$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Name:\\s+(?P<name>\\S+), Alias:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Capacity\\(1K\\s+blocks\\):\\s+(?P<capacity>\\d+)\\s+Used\\(1K\\s+blocks\\):\\s+(?P<used>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Available\\(1K\\s+blocks\\):\\s+(?P<available>\\d+)\\s+Usage:\\s+(?P<usage_pct>\\d+)\\s*%$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show vlan",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*(?P<vlan_id>[0-9]+) +(?P<name>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<space>\\s{48})(?P<interfaces>[\\w\\s\\/\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<vlan_id>[0-9]+) +(?P<vlan_type>[\\w]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<remote_span_vlans>[^--][0-9\\-\\,]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<primary>\\d+)? +(?P<secondary>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<vlan_id>[0-9]+) +(?P<segment_id>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VLAN_INFO_GLOBAL$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vlan +configuration +(?P<vlan_ids>[0-9\\-\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*vlan +map +(?P<vlan_access_map_tag>[a-zA-Z0-9]+):$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Configured +on +VLANs: +(?P<access_map_vlan_ids>[0-9\\,\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Vlan +access-map +(?P<access_map_id>[a-zA-Z0-9\\\"]+) +(?P<access_map_sequence>[0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*match +(?P<access_map_match_protocol>[a-zA-Z0-9]+): +(?P<access_map_match_protocol_value>[a-zA-Z0-9\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*action: +(?P<access_map_action_value>[a-zA-Z]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<vlan>[0-9]+) +(?P<vn_segment>[0-9]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show vpc",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^vPC +domain +id\\s*: +(?P<domain_id>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer +status\\s*: +(?P<peer_status>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^vPC +keep-alive +status\\s*: +(?P<keepalive_status>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configuration +consistency +status\\s*: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Configuration +consistency +reason\\s*: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Per-vlan +consistency +status\\s*: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Type-2 +consistency +status\\s*: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^vPC +role\\s*: +(?P<vpc_role>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Number +of +(vPC|vPCs) +configured\\s*: +(?P<num_of_vpc>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer +Gateway\\s*: +(?P<peer_gateway>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dual-active +excluded +VLANs\\s*: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Graceful +Consistency +Check\\s*: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Auto-recovery +status\\s*: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Delay-restore +status\\s*: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Delay-restore +SVI +status\\s*: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Operational +Layer3 +Peer-router\\s*: ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Track +object\\s*: +(?P<track_object>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<peer_link_id>\\d+) +(?P<peer_link_ifindex>\\S+) +(?P<peer_link_port_state>\\S+) +(?P<peer_up_vlan_bitset>-|\\S+)( +(?P<vlan_bds>-|\\S+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<vpc_id>\\d+) +(?P<vpc_ifindex>\\S+) ",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^vPC +(p|P)eer-link +status$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^vPC +status$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Id +: +(?P<vpc_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Port +: +(?P<vpc_ifindex>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Status +: +(?P<vpc_port_state>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Consistency +: +(?P<vpc_consistency>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Reason +: +(?P<vpc_consistency_status>[\\S ]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Active +Vlans +: +(?P<up_vlan_bitset>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer +gateway +excluded +VLANs +: +(?P<peer_gateway_exculded_vlans>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer +gateway +excluded +bridge-domains +: +(?P<peer_gateway_exculded_bridge_domains>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Dual-active +excluded +VLANs +and +BDs +: +(?P<dual_active_excluded_vlans_and_bds>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Delay-restore +orphan +ports +status +: +(Timer +is +(?P<timer>\\w+))\\.\\(timeout += +(?P<timeout>\\d+)s\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Self-isolation +: +(?P<self_isolation>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<additional_vlan>(?!--)[\\d\\,\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^vPC[+] +switch +id\\s*: +(?P<vpc_plus_switch_id>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^vPC+ fabricpath+ status\\s*: +(?P<vpc_fabricpath_status>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<additional_vlan>[\\d\\-\\,]+) (?P<additional_vpc_plus_attrib>[\\S\\-\\,\\s\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Peer +gateway +excluded +bridge-domains +: +(?P<peer_gateway_exculded_bridge_domains>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show vrf",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^\\s*(?P<vrf_name>(\\S+)) +(?P<vrf_id>[0-9]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interface +VRF-Name +VRF-ID +Site-of-Origin$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<intf_name>[a-zA-Z0-9\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VRF\\-Name: +(?P<vrf>[\\w\\-]+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^VPNID: +(?P<vpn_id>\\w+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^RD: +(?P<rd>[\\w\\:\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Max +Routes: +(?P<max_routes>\\d+) +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Table\\-ID: +(?P<table_id>\\w+), +",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^vrf +context +(?P<vrf>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*rd +(?P<rd>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*address-family +(?P<af>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*route-target +(?P<rt_type>\\w+) +(?P<rt>\\w+)( +(?P<rt_evpn_mvpn>\\w+))?$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "nxos",
        "command": "show vxlan",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<topo_id>[\\d]+) + (?P<vni>[\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<nve_name>[\\w\\/]+) +(?P<peer_ip>[\\w\\.\\:]+) +(?P<peer_state>[\\w]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nve_name>[\\w\\/]+) +(?P<vni>[\\d]+) +(?P<mcast>[\\w\\.\\/]+) +(?P<vni_state>[\\w]+) +(?P<mode>[\\w]+) +(?P<type>\\w+ +\\[[\\w\\-]+\\])(?: +(?P<flags>[\\w\\-\\s]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*nve(?P<nve>(\\d+)) +is +(?P<nve_state>[\\w]+)( +(?P<other>[\\w\\(\\)]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*nve(?P<nve>(\\d+)) +is +(?P<nve_state>[\\w]+)( +(?P<other>[\\w\\(\\)]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interface: +(?P<nve_name>[\\w\\/]+), +State: +(?P<state>[\\w]+),",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VPC Capability: +(?P<vpc_capability>[\\w\\s\\-\\[\\]]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Local Router MAC: +(?P<local_router_mac>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Host Learning Mode: +(?P<host_learning_mode>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Source-Interface: +(?P<source_if>[\\w\\/]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Source-Interface: +(?P<source_if>[\\w\\/]+) +\\(primary: +(?P<primary_ip>[\\w\\.\\:]+)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Anycast-Interface: +(?P<anycast_if>[\\w\\/]+) +\\(secondary: +(?P<secondary_ip>[\\w\\.\\:]+)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Source +Interface +State: +(?P<source_state>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*IR +Capability +Mode: +(?P<mode>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Virtual +RMAC +Advertisement: +(?P<adv_vmac>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*NVE +Flags:( +(?P<flags>[\\w]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interface +Handle: +(?P<intf_handle>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Source +Interface +hold-down-time: +(?P<hold_down_time>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Source +Interface +hold-up-time: +(?P<hold_up_time>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Remaining +hold-down +time: +(?P<hold_time_left>[\\d]+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Virtual +Router +MAC: +(?P<v_router_mac>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Virtual +Router +MAC +Re\\-origination: +(?P<v_router_mac_re>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interface +state: +(?P<intf_state>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*unknown-peer-forwarding: +(?P<peer_forwarding>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*down-stream +vni +config +mode: +(?P<vni_config_mode>[\\w\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Nve +Src +node +last +notif +sent: +(?P<last_notif_sent>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Nve +Mcast +Src +node +last +notif +sent: +(?P<last_notif_sent>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Nve +MultiSite +Src +node +last +notif +sent: +(?P<notif_sent>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multisite +bgw\\-if +oper +down +reason: +(?P<reason>[\\w\\.\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Multi(-S|s)ite +delay\\-restore +time: +(?P<multisite_convergence_time>\\d+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Multisite +delay-restore +time +left: +(?P<multisite_convergence_time_left>\\d+) +seconds$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Multisite +dci-advertise-pip +configured: +(?P<multisite_dci_advertise_pip>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<if_name>(?!Interface)[\\S]+) +(?P<if_state>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<if_name>(?!Interface)[\\S]+) +(?P<if_state>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ESI: +(?P<esi>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Parent +interface: +(?P<parent_intf>[\\w\\.\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ES +State: +(?P<es_state>[\\w\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Port-channel +state: +(?P<po_state>[\\w\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*NVE +Interface: +(?P<nve_intf>[\\w\\.\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*NVE +State: +(?P<nve_state>[\\w\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Host +Learning +Mode: +(?P<host_learning_mode>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Active +Vlans: +(?P<active_vlans>[\\d\\-\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*DF Vlans: +(?P<df_vlans>[\\d\\-\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*,?(?P<df_vlans>[\\d\\-\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Active +VNIs: +(?P<active_vnis>[\\d\\-\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*CC +failed +for +VLANs:( +(?P<cc_failed_vlans>[\\w\\/]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VLAN +CC +timer: +(?P<cc_timer_left>\\S+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Number +of +ES +members: +(?P<num_es_mem>[\\d]+)?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*My +ordinal: +(?P<local_ordinal>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*DF +timer +start +time: +(?P<df_timer_start_time>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Config +State: +(?P<config_status>[\\w\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*DF +List: +(?P<df_list>[\\d\\s\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*ES +route +added +to +L2RIB: +(?P<is_es_added_to_l2rib>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*EAD\\/ES +routes +added +to +L2RIB: +(?P<ead_rt_added>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*EAD/EVI +route +timer +age: +(?P<ead_evi_rt_timer_age>[\\w\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<ethernet_segment>(?!ESI)[\\w\\.]+) +(?P<originating_rtr>[\\d\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<topo_id>[\\d]+) +(?P<topo_name>[\\w\\-]+) +(?P<topo_type>[\\w\\/]+)(: +(?P<vni>[\\d]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Encap:(?P<encap_type>[\\d]+) +IOD:(?P<iod>[\\d]+) +IfHdl:(?P<if_hdl>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VTEP +IP: +(?P<vtep_ip>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Emulated +IP: +(?P<emulated_ip>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Emulated +RO +IP: +(?P<emulated_ro_ip>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*TX-ID: +(?P<tx_id>[\\d]+) +\\((Rcvd +Ack: +(?P<rcvd_flag>[\\d]+))\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*RMAC: +(?P<rmac>[\\w\\.]+), VRFID: +(?P<vrf_id>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VMAC: +(?P<vmac>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<topo_id>[\\d]+) +(?P<mac_addr>[\\w\\.]+) +(?P<prod_type>[\\w\\,]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Route +Resolution +Type: +(?P<rte_res>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Forwarding +State: +(?P<fwd_state>[\\w]+)( +\\(PeerID: +(?P<peer_id>[\\d]+)\\))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Sent +To: +(?P<sent_to>[\\w\\,]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*SOO: +(?P<soo>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<topo_id>[\\d]+) +(?P<mac_addr>[\\w\\.]+) +(?P<mac_ip_prod_type>[\\w\\,]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Sent +To: +(?P<sent_to>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*SOO: +(?P<soo>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*L3-Info: +(?P<l3_info>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<topo_id>[\\d]+) +(?P<mac_addr>[\\w\\.]+) +(?P<host_ip>[\\w\\/\\.]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Total +Memory: +(?P<total_memory>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Number +of +Converged +Tables: +(?P<numof_converged_tables>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Table +Name: +(?P<table_name>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<producer_name>[\\w]+) +\\((?P<id>[\\d\\s]+)\\) +(?P<objects>[\\d]+) +(?P<memory>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Total +(?P<total_obj>[\\d]+) +(?P<total_mem>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<topo_id>[\\d]+) +(?P<peer_id>[\\d]+) +(?P<flood_list>[\\w\\.d]+) +(?P<is_service_node>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*feature nv overlay$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*evpn multisite border-gateway +(?P<evpn_multisite_border_gateway>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*delay-restore time +(?P<evpn_msite_bgw_delay_restore_time>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*interface +(?P<nve_name>nve[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*no shutdown$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*host-reachability protocol +(?P<host_reachability_protocol>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*advertise virtual-rmac$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*source-interface +(?P<source_if>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*multisite +border\\-gateway +interface +(?P<multisite_bgw_if>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*member vni +(?P<nve_vni>[\\d-]+)( +(?P<associated_vrf>[\\w\\-]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*multisite ingress-replication$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*mcast-group +(?P<mcast_group>[\\d\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*interface +(?P<interface>(?!nve)[\\w\\/]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*evpn multisite +(?P<fabric_dci_tracking>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^global +suppress-arp$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^global +mcast-group +(?P<address>[\\d\\.]+) +(?P<layer>L2|L3)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<nve_name>[\\w]+) +(?P<vni>[\\d]+)( +(?P<replication_list>[\\d\\.]+|[\\w\\:]+) +(?P<source>[\\w\\-]+) +(?P<uptime>[\\w\\:]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<replication_list>[\\d\\.]+|[\\w\\:]+) +(?P<source>[\\w\\-]+) +(?P<uptime>[\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Pruning: +(?P<pruning>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Switch +role:( +(?P<switch_role>[\\w]+))?$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Fabric +Control +Seg: +(?P<fabric_control_seg>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Peer +Fabric +Control +Address: +(?P<peer_fabric_ctrl_addr>[\\w\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Advertising +vPC +RPF +routes: +(?P<advertise_vpc_rpf_routes>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Created +VNI +List: +(?P<created_vni_list>[\\w\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Fwd +Encap: +(?P<fwd_encap>[\\w\\\\(\\)\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Overlay +Distributed\\-DR: +(?P<overlay_distributed_dr>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Overlay +spt\\-only: +(?P<overlay_spt_only>[\\w]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*VRF +\\\"(?P<vrf_name>\\S+)\\\" +MVPN +SA +AD +Route +Database",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Src +Active +AD +Route: +\\((?P<saddr>[\\w\\/\\.]+), +(?P<gaddr>[\\w\\/\\.]+)\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interested Fabric Nodes:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*(?P<interested_fabric_nodes>[\\w\\s\\.]+), +uptime: +(?P<interest_uptime>[\\w\\.\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*EVPN +C\\-Mcast +Route +Database +for +VNI: +(?P<vni>[\\d]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Fabric +L2\\-Mroute: +\\((?P<saddr>[\\w\\/\\.\\*]+), +(?P<gaddr>[\\w\\/\\.]+)\\)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^\\s*Interested Fabric Nodes:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<space>\\s{4})(?P<interested_fabric_nodes>[\\w\\s\\.]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "sros",
        "command": "show isis",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^Rtr Base ISIS Instance (?P<instance>\\d+) Adjacency$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<system_id>\\S+) +(?P<usage>\\S+) +(?P<state>\\S+) +(?P<hold>\\d+) +(?P<interface>\\S+) +(?P<mt_id>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adjacencies : (?P<adjacencies>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Rtr Base ISIS Instance (?P<instance>\\d+) Adjacency \\(detail\\)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hostname +: +(?P<hostname>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^SystemID +: +(?P<system_id>\\S+) +SNPA +: +(?P<snpa>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Interface +: +(?P<interface>\\S+) +Up Time +: +(?P<up_time>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^State +: +(?P<state>\\S+) +Priority +: +(?P<priority>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Nbr Sys Typ +: +(?P<nbr_sys_typ>\\S+) +L. Circ Typ +: +(?P<l_circ_typ>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Hold Time +: +(?P<hold_time>\\d+) +Max Hold +: +(?P<max_hold>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Adj Level +: +(?P<adj_level>\\S+) +MT Enabled +: +(?P<mt_enabled>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Topology +: +(?P<topology>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv6 Neighbor +: +(?P<ipv6_neighbor>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv4 Neighbor +: +(?P<ipv4_neighbor>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^IPv4 Adj SID +: +(?P<ipv4_adj_sid>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Restart Support +: +(?P<restart_support>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Restart Status +: +(?P<restart_status>[\\s\\S]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Restart Supressed +: +(?P<restart_supressed>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number of Restarts: +(?P<number_of_restarts>\\d+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Last Restart at +: +(?P<last_restart_at>\\S+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "sros",
        "command": "show service_sap_using",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)(?P<sap>\\S+) +(?P<service>\\d+) +(?P<ing_qos>\\d+) +(?P<ing_filter>\\S+) +(?P<egr_qos>\\d+) +(?P<egr_filter>\\S+) +(?P<admin>Up|Down)\\s+(?P<oper>Up|Down)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Number of SAPs : (?P<total>\\d+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "sros",
        "command": "show system_ntp_all",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)Configured +: +(?P<configured>\\S+) +Stratum +: +(?P<stratum>\\d+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Admin Status +: +(?P<admin_status>\\S+) +Oper Status +: +(?P<oper_status>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Server Enabled +: +(?P<server_enabled>\\S+) +Server Authenticate +: +(?P<server_authenticate>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Clock Source +: +(?P<clock_source>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Auth Check +: +(?P<auth_check>\\S+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Current Date & Time: +(?P<current_date_time>[\\s\\S]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<state>\\S+) +(?P<refid>\\S+) +(?P<stratum>[-\\d]) +(?P<type>\\S+) +(?P<a>[-]) +(?P<poll>\\d+) +(?P<reach>\\S+) +(?P<offset>[-.\\d]+)",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)(?P<router>\\S+) +(?P<remote>[.\\d]+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "viptela",
        "command": "show boot_partition",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<partition>\\d+) +(?P<active>\\S+) +(?P<version>\\S+) +(?P<timestamp>\\S+)",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "viptela",
        "command": "show omp",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<key>[\\w0-9\\-]+) + (?P<value>[\\d\\w\\:]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^tloc-paths entries +(?P<ip_add>\\S+) +(?P<tloc>\\S+) +(?P<transport>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<ip_add>\\d\\S+) +(?P<type>\\S+) +(?P<domain_id>\\S+) +(?P<overlay_id>\\S+) +(?P<site_id>\\S+) +(?P<state>\\S+) +(?P<uptime>\\S+) +(?P<route>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^tloc entries for +(?P<ip_add>\\S+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<recv>RECEIVED FROM)\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<trans>ipsec|gre)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<tloc>[\\w\\-0-9]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<attr>\\w+)\\:$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^(?P<key>\\S+) +(?P<value>[\\S\\s]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    },
    {
        "hw_type": "viptela",
        "command": "show system_status",
        "sw_type": "unknown",
        "sw_version": [
            "unknown"
        ],
        "prompt": "#",
        "config": [
            {
                "match": "(?ms)^(?P<key>[\\w/\\.\\s\\-]+:) +(?P<value>[\\d\\w/\\.\\:\\s\\,\\%\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^System +logging +to +(?P<type>[\\w/\\s]+) +is +(?P<value>[\\d\\w/\\s]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CPU +allocation: +(?P<total>[\\0-9]+) +total, +(?P<control>[\\0-9]+) +control, +(?P<data>[\\0-9]+) +data$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^CPU +states: +(?P<user>[\\0-9\\%\\.]+) +user, +(?P<system>[\\0-9\\%\\.]+) +system, +(?P<idle>[\\0-9\\%\\.]+) +idle$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Load +average: +1 +minute: +(?P<minute_1>[\\0-9\\%\\.]+), +5 +minutes: +(?P<minute_5>[\\0-9\\%\\.]+), +15 +minutes: +(?P<minute_15>[\\0-9\\%\\.]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Engineering +Signed +(?P<value>[\\d\\w/\\.\\:\\s\\,\\%\\-]+)$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)Memory +usage: +(?P<total_kilo>[\\0-9\\w/\\\\]+) +total, +(?P<used_kilo>[\\0-9\\w/\\\\]+) +used, +(?P<free_kilo>[\\0-9\\w/\\\\]+) +free +(?P<buffers_kilo>[\\0-9\\w/\\\\]+) +buffers, +(?P<cache_kilo>[\\0-9\\w/\\\\]+) +cache$",
                "level": 1,
                "submatch": []
            },
            {
                "match": "(?ms)^Disk +usage: +Filesystem +Size +Used +Avail + Use +% +Mounted +on +(?P<filesystem>[\\d\\w/\\%\\.]+) +(?P<size_mega>[\\d\\w]+) +(?P<used_mega>[\\d\\w]+) +(?P<avail_mega>[\\d\\w]+) +(?P<use_pc>[\\d\\w/\\%\\.]+) +(?P<mounted_on>[\\d\\w/\\%\\.]+)$",
                "level": 1,
                "submatch": []
            }
        ]
    }
]